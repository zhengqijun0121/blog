[{"categories":["wsl"],"content":"wsl 的安装配置","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"categories":["wsl"],"content":"Windows Subsystem for Linux（简称 WSL）是一个在 Windows 上能够运行原生 Linux 二进制可执行文件（ELF格式）的兼容层。 ","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:0:0","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#"},{"categories":["wsl"],"content":" 1 wsl 的安装","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:0","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#wsl-的安装"},{"categories":["wsl"],"content":" 1.1 启用适用于 Linux 的 Windows 子系统需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。使用管理员权限执行以下命令 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart ","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:1","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#启用适用于-linux-的-windows-子系统"},{"categories":["wsl"],"content":" 1.2 启用虚拟机功能安装 WSL2 之前，必须启用“虚拟机平台”可选功能。使用管理员权限执行以下命令 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart ","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:2","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#启用虚拟机功能"},{"categories":["wsl"],"content":" 1.3 安装 WSL2推荐使用 Microsoft Store 安装最新版 wsl，注意在 Microsoft Store 安装应用软件需要先登录用户。 wsl --set-default-version 2 ","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:1:3","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#安装-wsl2"},{"categories":["wsl"],"content":" 2 wsl 安装 Ubuntu","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:0","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#wsl-安装-ubuntu"},{"categories":["wsl"],"content":" 2.1 Microsoft Store 安装推荐使用 Microsoft Store 安装 Ubuntu，注意在 Microsoft Store 安装应用软件需要先登录用户。默认情况下安装在C盘，这样会导致系统盘占用空间大，特别卡。所以接下来我们要把 Ubuntu 安装到非系统盘上。 wsl install ubuntu-22.04 ","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:1","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#microsoft-store-安装"},{"categories":["wsl"],"content":" 2.2 手动安装 # 导出 Ubuntu-22.04 系统 wsl --export Ubuntu-22.04 D:\\Software\\WSL\\Ubuntu-22.04.tar # 删除 Ubuntu-22.04 系统 wsl --unregister Ubuntu-22.04 # 导入 Ubuntu-22.04 系统 wsl --import Ubuntu-22.04 D:\\Software\\WSL D:\\Software\\WSL\\Ubuntu-22.04.tar ","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:2:2","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#手动安装"},{"categories":["wsl"],"content":" 3 wsl 的配置","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:3:0","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#wsl-的配置"},{"categories":["wsl"],"content":" 3.1 启动 systemd修改 /etc/wsl.conf 文件，启动 systemd 并修改默认用户。 [boot] systemd=true [user] default=user ","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:3:1","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#启动-systemd"},{"categories":["wsl"],"content":" 3.2 连接 wsl 端口必须使用管理员权限执行以下命令 # 查看转发端口 netsh interface portproxy show all # 配置转发端口 netsh interface portproxy add v4tov4 listenport=8022 listenaddress=0.0.0.0 connectport=8022 connectaddress=192.168.2.1 # 配置端口通过防火墙 netsh advfirewall firewall add rule name=wsl_ssh_port dir=in action=allow protocol=tcp localport=8022 # 删除配置转发端口 netsh interface portproxy del v4tov4 listenport=8022 listenaddress=0.0.0.0 # 删除配置端口通过防火墙 netsh advfirewall firewall del rule name=wsl_ssh_port ","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:3:2","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#连接-wsl-端口"},{"categories":["wsl"],"content":" 3.3 通过命令行设置 Windows 网络必须使用管理员权限执行以下命令 # 查看电脑 ip 配置 netsh interface ip show config # 设置以太网静态 ip netsh interface ip set address \"以太网\" source=static addr=192.168.2.101 mask=255.255.255.0 gateway=192.168.2.1 netsh interface ip set address \"以太网\" static 192.168.2.101 255.255.255.0 192.168.2.1 # 设置以太网动态 ip netsh interface ip set address \"以太网\" dhcp ","date":"2023-03-22","objectID":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/:3:3","series":["wsl-series"],"tags":["wsl","Windows","Ubuntu"],"title":"wsl 的安装配置","uri":"/blog/020_wsl%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/#通过命令行设置-windows-网络"},{"categories":["dev-tools"],"content":"sshfs 是连接到 SSH 服务器的网络文件系统客户端，方便本地操作远程文件。 ","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:0:0","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#"},{"categories":["dev-tools"],"content":" 1 Ubuntu 平台","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:1:0","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#ubuntu-平台"},{"categories":["dev-tools"],"content":" 1.1 Ubuntu 安装 sshfs sudo apt-get install sshfs ","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:1:1","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#ubuntu-安装-sshfs"},{"categories":["dev-tools"],"content":" 1.2 Ubuntu 使用 sshfs 挂载目录将 user@hostname 的 /home/user 远程目录挂载到 /home/user/sshfs 本地目录下，/home/user/sshfs 本地目录需要先创建，否则会执行失败。 sshfs user@hostname:/home/user/ /home/user/sshfs/ ","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:1:2","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#ubuntu-使用-sshfs-挂载目录"},{"categories":["dev-tools"],"content":" 1.3 Ubuntu 卸载挂载目录 sudo umount /home/user/sshfs ","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:1:3","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#ubuntu-卸载挂载目录"},{"categories":["dev-tools"],"content":" 2 Windows 平台","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:2:0","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#windows-平台"},{"categories":["dev-tools"],"content":" 2.1 Windows 安装 sshfs https://github.com/winfsp/winfsp https://github.com/winfsp/sshfs-win ","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:2:1","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#windows-安装-sshfs"},{"categories":["dev-tools"],"content":" 2.2 Windows 使用 sshfs打开文件资源管理器，点击映射网络驱动器，输入远程目录即可。 \\\\sshfs.r\\user@hostname!port\\path ","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:2:2","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#windows-使用-sshfs"},{"categories":["dev-tools"],"content":" 2.3 Windows 卸载挂载目录打开文件资源管理器，点击断开连接。 ","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:2:3","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#windows-卸载挂载目录"},{"categories":["dev-tools"],"content":" 2.4 sshfs-win 命令说明 sshfs 是相对于 HOME 目录 sshfs.r 是相对于 ROOT 目录 sshfs.k 是相对于 HOME 目录，并使用 ssh 密钥 sshfs.kr 是相对于 ROOT 目录，并使用 ssh 密钥 ","date":"2023-02-23","objectID":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/:2:4","series":[],"tags":["dev-tools","ssh"],"title":"sshfs 挂载远程目录","uri":"/blog/006_sshfs%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E7%9B%AE%E5%BD%95/#sshfs-win-命令说明"},{"categories":["programming"],"content":" 1 Bash 调试技巧bash 脚本是一种常用的脚本。当 bash 脚本执行出现错误的时候，我们可以通过调试的方式来定位问题所在。 ","date":"2023-01-02","objectID":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:1:0","series":[],"tags":["programming","Shell"],"title":"Bash 调试技巧","uri":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/#bash-调试技巧"},{"categories":["programming"],"content":" 1.1 Bash 调试常用选项 选项 说明 -v 打印执行命令 -x 类似 -v，并扩展了命令 -e 发生错误终止执行 -n 只检查语法，不执行脚本 -o pipefail 返回管道的错误状态 ","date":"2023-01-02","objectID":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:1:1","series":[],"tags":["programming","Shell"],"title":"Bash 调试技巧","uri":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/#bash-调试常用选项"},{"categories":["programming"],"content":" 1.2 跟踪脚本的执行 1.2.1 输出调试信息正常情况下，通过 bash test.sh 或 ./test.sh 执行脚本，利用 echo 或者 printf 命令可以输出一些信息，但是不能输出命令的具体执行情况。 下面有两种方式利用 -x 选项，可以打印执行命令，方便调试。 执行命令 bash -x test.sh or bash --debug test.sh 修改脚本 #!/bin/bash set -x # Enable debugging output # some code here set +x # Disable debugging output 1.2.2 输出行号和函数名PS4 是 Linux/Unix 下的一个用于控制脚本调试显示信息的环境变量。 其中常用的变量有： ${BASH_SOURCE}：表示当前执行脚本的相对路径 ${LINENO}：表示行号 ${FUNCNAME}：表示当前执行函数名 #!/bin/bash PS4='+${BASH_SOURCE}:${LINENO} ${FUNCNAME}: ' function hello() { echo \"Hello World\" } ","date":"2023-01-02","objectID":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:1:2","series":[],"tags":["programming","Shell"],"title":"Bash 调试技巧","uri":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/#跟踪脚本的执行"},{"categories":["programming"],"content":" 1.2 跟踪脚本的执行 1.2.1 输出调试信息正常情况下，通过 bash test.sh 或 ./test.sh 执行脚本，利用 echo 或者 printf 命令可以输出一些信息，但是不能输出命令的具体执行情况。 下面有两种方式利用 -x 选项，可以打印执行命令，方便调试。 执行命令 bash -x test.sh or bash --debug test.sh 修改脚本 #!/bin/bash set -x # Enable debugging output # some code here set +x # Disable debugging output 1.2.2 输出行号和函数名PS4 是 Linux/Unix 下的一个用于控制脚本调试显示信息的环境变量。 其中常用的变量有： ${BASH_SOURCE}：表示当前执行脚本的相对路径 ${LINENO}：表示行号 ${FUNCNAME}：表示当前执行函数名 #!/bin/bash PS4='+${BASH_SOURCE}:${LINENO} ${FUNCNAME}: ' function hello() { echo \"Hello World\" } ","date":"2023-01-02","objectID":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:1:2","series":[],"tags":["programming","Shell"],"title":"Bash 调试技巧","uri":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/#输出调试信息"},{"categories":["programming"],"content":" 1.2 跟踪脚本的执行 1.2.1 输出调试信息正常情况下，通过 bash test.sh 或 ./test.sh 执行脚本，利用 echo 或者 printf 命令可以输出一些信息，但是不能输出命令的具体执行情况。 下面有两种方式利用 -x 选项，可以打印执行命令，方便调试。 执行命令 bash -x test.sh or bash --debug test.sh 修改脚本 #!/bin/bash set -x # Enable debugging output # some code here set +x # Disable debugging output 1.2.2 输出行号和函数名PS4 是 Linux/Unix 下的一个用于控制脚本调试显示信息的环境变量。 其中常用的变量有： ${BASH_SOURCE}：表示当前执行脚本的相对路径 ${LINENO}：表示行号 ${FUNCNAME}：表示当前执行函数名 #!/bin/bash PS4='+${BASH_SOURCE}:${LINENO} ${FUNCNAME}: ' function hello() { echo \"Hello World\" } ","date":"2023-01-02","objectID":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:1:2","series":[],"tags":["programming","Shell"],"title":"Bash 调试技巧","uri":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/#输出行号和函数名"},{"categories":["programming"],"content":" 1.3 检查语法错误语法错误是 shell 脚本执行错误的原因之一。执行脚本的时候加上 -n 选项, 当脚本有语法错误，不会继续执行，而是打印错误信息。 bash -n test.sh ","date":"2023-01-02","objectID":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:1:3","series":[],"tags":["programming","Shell"],"title":"Bash 调试技巧","uri":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/#检查语法错误"},{"categories":["programming"],"content":" 1.4 发生错误终止运行一般情况下，脚本执行时发生错误了，还是会继续执行后面的命令。执行脚本的时候加上 -e 选项，可以避免发生错误的时候，脚本继续执行。 bash -e test.sh ","date":"2023-01-02","objectID":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:1:4","series":[],"tags":["programming","Shell"],"title":"Bash 调试技巧","uri":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/#发生错误终止运行"},{"categories":["programming"],"content":" 1.5 管道命令错误终止运行-e 选项有个特殊的情况，不适用于管道命令。执行脚本的时候加上 -o pipefail 选项，可以检测管道命令发生错误。 bash -o pipefail test.sh ","date":"2023-01-02","objectID":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:1:5","series":[],"tags":["programming","Shell"],"title":"Bash 调试技巧","uri":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/#管道命令错误终止运行"},{"categories":["programming"],"content":" 1.6 检查不存在的变量执行脚本的时候，遇到不存在的变量，默认会忽略它。执行脚本的时候加上 -u 选项，可以检测变量是否存在。 bash -u test.sh ","date":"2023-01-02","objectID":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:1:6","series":[],"tags":["programming","Shell"],"title":"Bash 调试技巧","uri":"/blog/002_bash%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/#检查不存在的变量"},{"categories":["programming"],"content":" 1 Bash 基础语法详解 ","date":"2023-01-02","objectID":"/blog/001_bash%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:0","series":[],"tags":["programming","Shell"],"title":"Bash 语法详解","uri":"/blog/001_bash%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#bash-基础语法详解"},{"categories":["dev-config"],"content":" 1 Shell 启动方式","date":"2022-11-27","objectID":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/:1:0","series":[],"tags":["dev-config","shell"],"title":"Shell 配置文件的加载","uri":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/#shell-启动方式"},{"categories":["dev-config"],"content":" 1.1 启动方式Shell 的启动方式有以下四种： 交互式登录 非交互式登录 交互式非登录 非交互式非登录 其中交互式是指需要使用者手动输入的方式，而非交互式指的是脚本方式运行，不需要使用者手动输入。登录指的是使用者需要输入用户名和密码的方式，需要特定用户才能执行，而非登录不需要输入用户名和密码，任何用户都能执行。 比如：GNOME Terminal 默认是交互式非登录 Shell，iTerm2 Terminal 默认是交互式登录 Shell，ssh 连接也是交互式非登录 Shell，在终端上运行一般脚本是非交互式非登录 Shell，ssh 连接直接执行命令是非交互式登陆 Shell 等。 ","date":"2022-11-27","objectID":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/:1:1","series":[],"tags":["dev-config","shell"],"title":"Shell 配置文件的加载","uri":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/#启动方式"},{"categories":["dev-config"],"content":" 1.2 区分方式 交互式区分方式 根据 $- 变量区分，含有 i (interactive) 为交互式 Shell。 echo \"$-\" himBHs 根据 $PS1 变量区分，不为空的是交互式 Shell。 echo \"$PS1\" [\\u@\\h \\W]\\$ 指定 -c 选项运行非交互式 Shell，指定 -i 选项运行交互式 Shell。 登录式区分方式 根据 $0 变量区分，带 - 为登录 Shell。 echo \"$0\" -bash 根据 shopt login_shell，Bash 独有。 login_shell on 执行 logout 命令，只有登录 Shell 才能运行这条命令 logout bash: logout: not login shell: use `exit' 指定 -l 或者 --login 选项运行登陆 Shell。 ","date":"2022-11-27","objectID":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/:1:2","series":[],"tags":["dev-config","shell"],"title":"Shell 配置文件的加载","uri":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/#区分方式"},{"categories":["dev-config"],"content":" 2 Shell 配置文件的加载顺序","date":"2022-11-27","objectID":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/:2:0","series":[],"tags":["dev-config","shell"],"title":"Shell 配置文件的加载","uri":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/#shell-配置文件的加载顺序"},{"categories":["dev-config"],"content":" 2.1 Bash ","date":"2022-11-27","objectID":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/:2:1","series":[],"tags":["dev-config","shell"],"title":"Shell 配置文件的加载","uri":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/#bash"},{"categories":["dev-config"],"content":" 2.2 Zsh ","date":"2022-11-27","objectID":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/:2:2","series":[],"tags":["dev-config","shell"],"title":"Shell 配置文件的加载","uri":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/#zsh"},{"categories":["dev-config"],"content":" 2.3 Ash ","date":"2022-11-27","objectID":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/:2:3","series":[],"tags":["dev-config","shell"],"title":"Shell 配置文件的加载","uri":"/blog/005_shell%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/#ash"},{"categories":["develop"],"content":"为了提高软件安装和更新速度，需要配置成国内源！ ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:0:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#"},{"categories":["develop"],"content":" 1 Ubuntu 设置国内源Ubuntu 的软件源配置文件是 /etc/apt/sources.list，修改之前可以先做个备份。 ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#ubuntu-设置国内源"},{"categories":["develop"],"content":" 1.1 amd64 平台 1.1.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial universe deb http://archive.ubuntu.com/ubuntu/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.1.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic universe deb http://archive.ubuntu.com/ubuntu/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsin","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:1","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#amd64-平台"},{"categories":["develop"],"content":" 1.1 amd64 平台 1.1.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial universe deb http://archive.ubuntu.com/ubuntu/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.1.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic universe deb http://archive.ubuntu.com/ubuntu/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsin","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:1","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#ubuntu-1604"},{"categories":["develop"],"content":" 1.1 amd64 平台 1.1.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial universe deb http://archive.ubuntu.com/ubuntu/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.1.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic universe deb http://archive.ubuntu.com/ubuntu/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsin","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:1","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#ubuntu-1804"},{"categories":["develop"],"content":" 1.1 amd64 平台 1.1.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial universe deb http://archive.ubuntu.com/ubuntu/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.1.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic universe deb http://archive.ubuntu.com/ubuntu/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsin","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:1","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#ubuntu-2004"},{"categories":["develop"],"content":" 1.1 amd64 平台 1.1.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial universe deb http://archive.ubuntu.com/ubuntu/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.1.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic universe deb http://archive.ubuntu.com/ubuntu/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsin","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:1","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#ubuntu-2204"},{"categories":["develop"],"content":" 1.2 arm64 平台 1.2.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial universe deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.2.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic universe deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-u","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:2","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#arm64-平台"},{"categories":["develop"],"content":" 1.2 arm64 平台 1.2.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial universe deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.2.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic universe deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-u","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:2","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#ubuntu-1604-1"},{"categories":["develop"],"content":" 1.2 arm64 平台 1.2.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial universe deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.2.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic universe deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-u","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:2","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#ubuntu-1804-1"},{"categories":["develop"],"content":" 1.2 arm64 平台 1.2.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial universe deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.2.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic universe deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-u","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:2","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#ubuntu-2004-1"},{"categories":["develop"],"content":" 1.2 arm64 平台 1.2.1 Ubuntu 16.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ xenial universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial universe deb http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ xenial-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-proposed main restricted universe multiverse 命令更新 sudo sed -i \"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list sudo sed -i \"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g\" /etc/apt/sources.list 1.2.2 Ubuntu 18.04 原始软件源配置文件 # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic main restricted ## Major bug fix updates produced after the final release of the ## distribution. deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates main restricted ## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## universe WILL NOT receive any review or updates from the Ubuntu security ## team. deb http://archive.ubuntu.com/ubuntu-ports/ bionic universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic universe deb http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe # deb-src http://archive.ubuntu.com/ubuntu-ports/ bionic-updates universe 更新后软件源配置文件 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-u","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:1:2","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#ubuntu-2204-1"},{"categories":["develop"],"content":" 2 Alpine 设置国内源 sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:2:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#alpine-设置国内源"},{"categories":["develop"],"content":" 3 pip 设置国内源 临时使用 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 默认使用 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:3:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#pip-设置国内源"},{"categories":["develop"],"content":" 4 brew 设置国内源 ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:4:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#brew-设置国内源"},{"categories":["develop"],"content":" 5 docker 设置国内源修改 /etc/docker/daemon.json 文件 { \"registry-mirrors\": [ https://registry.docker-cn.com, http://hub-mirror.c.163.com, https://docker.mirrors.ustc.edu.cn ] } ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:5:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#docker-设置国内源"},{"categories":["develop"],"content":" 6 npm 设置国内源 npm config set registry https://registry.npm.taobao.org ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:6:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#npm-设置国内源"},{"categories":["develop"],"content":" 7 rust 设置国内源 export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:7:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#rust-设置国内源"},{"categories":["develop"],"content":" 8 cargo 设置国内源 [source.crates-io] replace-with = 'tuna' [source.tuna] registry = \"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git\" ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:8:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#cargo-设置国内源"},{"categories":["develop"],"content":" 9 go 设置国内源 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct # or export GO111MODULE=on export GOPROXY=https://goproxy.cn ","date":"2022-11-26","objectID":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/:9:0","series":["develop-series"],"tags":["develop"],"title":"国内源设置","uri":"/blog/001_%E5%9B%BD%E5%86%85%E6%BA%90%E8%AE%BE%E7%BD%AE/#go-设置国内源"},{"categories":["Docker"],"content":" 1 Docker apt-get install git ","date":"2022-11-06","objectID":"/blog/002_docker%E4%BD%BF%E7%94%A8buildx%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0%E9%95%9C%E5%83%8F/:1:0","series":[],"tags":["Docker"],"title":"Docker 使用 buildx 构建多平台镜像","uri":"/blog/002_docker%E4%BD%BF%E7%94%A8buildx%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0%E9%95%9C%E5%83%8F/#docker"},{"categories":["Docker"],"content":" 2 git 配置文件git 配置文件有三个： /etc/gitconfig 是系统级配置文件，使用 git config --system 命令进行修改。 ~/.gitconfig 或 ~/.config/git/config 是用户级配置文件，使用 git config --global 命令进行修改。 local_dir/.git/config 是仓库级配置文件，使用 git config --local 命令进行修改。 ","date":"2022-11-06","objectID":"/blog/002_docker%E4%BD%BF%E7%94%A8buildx%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0%E9%95%9C%E5%83%8F/:2:0","series":[],"tags":["Docker"],"title":"Docker 使用 buildx 构建多平台镜像","uri":"/blog/002_docker%E4%BD%BF%E7%94%A8buildx%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0%E9%95%9C%E5%83%8F/#git-配置文件"},{"categories":["Docker"],"content":" 2.1 设置用户信息 $ git config --global user.name \"username\" $ git config --global user.email username@example.com ","date":"2022-11-06","objectID":"/blog/002_docker%E4%BD%BF%E7%94%A8buildx%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0%E9%95%9C%E5%83%8F/:2:1","series":[],"tags":["Docker"],"title":"Docker 使用 buildx 构建多平台镜像","uri":"/blog/002_docker%E4%BD%BF%E7%94%A8buildx%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0%E9%95%9C%E5%83%8F/#设置用户信息"},{"categories":["Docker"],"content":" 2.2 设置 git 默认编辑器 git config --global core.editor emacs ","date":"2022-11-06","objectID":"/blog/002_docker%E4%BD%BF%E7%94%A8buildx%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0%E9%95%9C%E5%83%8F/:2:2","series":[],"tags":["Docker"],"title":"Docker 使用 buildx 构建多平台镜像","uri":"/blog/002_docker%E4%BD%BF%E7%94%A8buildx%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0%E9%95%9C%E5%83%8F/#设置-git-默认编辑器"},{"categories":["code format"],"content":" 1 Astyle 工具下载 ","date":"2022-08-20","objectID":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/:1:0","series":[],"tags":["Astyle","code format"],"title":"Astyle 配置使用","uri":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/#astyle-工具下载"},{"categories":["code format"],"content":" 2 Astyle 参数详解","date":"2022-08-20","objectID":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/:2:0","series":[],"tags":["Astyle","code format"],"title":"Astyle 配置使用","uri":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/#astyle-参数详解"},{"categories":["code format"],"content":" 2.1 括号类型 2.1.1 default brace style默认采用大括号样式，开口大括号不变，闭合大括号将与上一行断开。 2.1.2 –style=allman / –style=bsd / –style=break / -A1 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.3 –style=java / –style=attach / -A2 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.4 –style=kr / –style=k\u0026r / –style=k/r / -A3 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.5 –style=stroustrup / -A4 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } ","date":"2022-08-20","objectID":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/:2:1","series":[],"tags":["Astyle","code format"],"title":"Astyle 配置使用","uri":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/#括号类型"},{"categories":["code format"],"content":" 2.1 括号类型 2.1.1 default brace style默认采用大括号样式，开口大括号不变，闭合大括号将与上一行断开。 2.1.2 –style=allman / –style=bsd / –style=break / -A1 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.3 –style=java / –style=attach / -A2 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.4 –style=kr / –style=k\u0026r / –style=k/r / -A3 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.5 –style=stroustrup / -A4 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } ","date":"2022-08-20","objectID":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/:2:1","series":[],"tags":["Astyle","code format"],"title":"Astyle 配置使用","uri":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/#default-brace-style"},{"categories":["code format"],"content":" 2.1 括号类型 2.1.1 default brace style默认采用大括号样式，开口大括号不变，闭合大括号将与上一行断开。 2.1.2 –style=allman / –style=bsd / –style=break / -A1 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.3 –style=java / –style=attach / -A2 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.4 –style=kr / –style=k\u0026r / –style=k/r / -A3 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.5 –style=stroustrup / -A4 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } ","date":"2022-08-20","objectID":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/:2:1","series":[],"tags":["Astyle","code format"],"title":"Astyle 配置使用","uri":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/#--styleallman----stylebsd----stylebreak---a1"},{"categories":["code format"],"content":" 2.1 括号类型 2.1.1 default brace style默认采用大括号样式，开口大括号不变，闭合大括号将与上一行断开。 2.1.2 –style=allman / –style=bsd / –style=break / -A1 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.3 –style=java / –style=attach / -A2 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.4 –style=kr / –style=k\u0026r / –style=k/r / -A3 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.5 –style=stroustrup / -A4 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } ","date":"2022-08-20","objectID":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/:2:1","series":[],"tags":["Astyle","code format"],"title":"Astyle 配置使用","uri":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/#--stylejava----styleattach---a2"},{"categories":["code format"],"content":" 2.1 括号类型 2.1.1 default brace style默认采用大括号样式，开口大括号不变，闭合大括号将与上一行断开。 2.1.2 –style=allman / –style=bsd / –style=break / -A1 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.3 –style=java / –style=attach / -A2 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.4 –style=kr / –style=k\u0026r / –style=k/r / -A3 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.5 –style=stroustrup / -A4 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } ","date":"2022-08-20","objectID":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/:2:1","series":[],"tags":["Astyle","code format"],"title":"Astyle 配置使用","uri":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/#--stylekr----stylekr----stylekr---a3"},{"categories":["code format"],"content":" 2.1 括号类型 2.1.1 default brace style默认采用大括号样式，开口大括号不变，闭合大括号将与上一行断开。 2.1.2 –style=allman / –style=bsd / –style=break / -A1 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.3 –style=java / –style=attach / -A2 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.4 –style=kr / –style=k\u0026r / –style=k/r / -A3 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } 2.1.5 –style=stroustrup / -A4 int Foo(bool isBar) { if (isBar) { bar(); return 1; } else return 0; } ","date":"2022-08-20","objectID":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/:2:1","series":[],"tags":["Astyle","code format"],"title":"Astyle 配置使用","uri":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/#--stylestroustrup---a4"},{"categories":["code format"],"content":" 3 在 Keil 中的使用 ","date":"2022-08-20","objectID":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/:3:0","series":[],"tags":["Astyle","code format"],"title":"Astyle 配置使用","uri":"/blog/001_astyle%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/#在-keil-中的使用"},{"categories":["programming"],"content":" 1 容器的定义在数据存储上，有一种对象类型，它可以持有其它对象或指向其它对像的指针，这种对象类型就叫做容器。 ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:1:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#容器的定义"},{"categories":["programming"],"content":" 2 容器的分类 顺序容器 顺序容器是一种各元素之间有顺序关系的线性表，是一种线性结构的有序集合。这种顺序不依赖于元素的值，而是与元素加入容器的顺序相对应。顺序容器提供控制元素存储和访问顺序的能力。 顺序容器包括vector、dequeue、list、forward_list、array、string。 关联容器 关联式容器是非线性的树结构，各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。但是关联式容器提供了另一种根据元素特点排序的功能。 有序关联容器包括：set、multiset、map、multimap。 无序关联容器包括：unordered_map、unordered_multimap、unordered_set、unordered_multiset。 容器适配器 适配器是使一种不同的行为类似于另一事物的行为的一种机制。容器适配器让一种已存在的容器类型采用另一种不同的抽象类型的工作方式实现。适配器是容器的接口，它本身不能直接保存元素，它保存元素的机制是调用另一种顺序容器去实现。 容器适配器包括stack、queue、priority_queue。 ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:2:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#容器的分类"},{"categories":["programming"],"content":" 3 array","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:3:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#array"},{"categories":["programming"],"content":" 3.1 定义数组是固定大小的序列容器，不通过分配器管理其元素的分配。因此不能动态的扩容和收缩。元素存储在连续的内存位置，允许对元素进行恒定时间随机访问。 原型如下： template \u003cclass T, size_t N\u003e class array; API 定义 template \u003cclass T, size_t N\u003e class array { public: // Iterators iterator begin() noexcept; const_iterator begin() const noexcept; iterator end() noexcept; const_iterator end() const noexcept; reverse_iterator rbegin() noexcept; const_reverse_iterator rbegin() const noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rend() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; // Capacity constexpr size_type size() noexcept; constexpr size_type max_size() noexcept; constexpr bool empty() noexcept; // Element Access reference operator[](size_type n); const_reference operator[](size_type n) const; reference at(size_type n); const_reference at(size_type n) const; reference front(); const_reference front() const; reference back(); const_reference back() const; value_type* data() noexcept; const value_type* data() const noexcept; // Modifiers void fill(const value_type\u0026 val); void swap(array\u0026 x) noexcept(noexcept(swap(declval\u003cvalue_type\u0026\u003e(), declval\u003cvalue_type\u0026\u003e()))); }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:3:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义"},{"categories":["programming"],"content":" 3.2 使用 头文件 #include \u003carray\u003e 新增操作 array 在初始化的时候已经定义好数组大小，不能新增元素！ 删除操作 array 在初始化的时候已经定义好数组大小，不能删除元素！ 修改操作 std::array\u003cint, 10\u003e arr; arr[0] = 1; arr.at(1) = 2; std::get\u003c2\u003e(arr) = 3; 查找操作 if (arr[3] == 4) { ... } 遍历操作 按元素大小遍历 for (size_t i = 0; i \u003c arr.size(); ++i) { std::cout \u003c\u003c arr[i] \u003c\u003c std::endl; } 迭代器遍历 for (const auto\u0026 it : arr) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } // or for (auto it = arr.begin(); it != arr.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:3:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用"},{"categories":["programming"],"content":" 4 string","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:4:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#string"},{"categories":["programming"],"content":" 4.1 定义string 表示可变长的字符序列。 原型如下： typedef basic_string\u003cchar\u003e string; API 定义 class string { public: string(); string(const string\u0026 str); string(const string\u0026 str, size_t pos, size_t len = npos); string(const char* s); string(const char* s, size_t n); string(size_t n, char c); template \u003cclass InputIterator\u003e string(InputIterator first, InputIterator last); string(initializer_list\u003cchar\u003e il); string(string\u0026\u0026 str) noexcept; ~string(); string\u0026 operator=(const string\u0026 str); string\u0026 operator=(const char* s); string\u0026 operator=(char c); string\u0026 operator=(initializer_list\u003cchar\u003e il); string\u0026 operator=(string\u0026\u0026 str) noexcept; // Iterators iterator begin() noexcept; const_iterator begin() const noexcept; iterator end() noexcept; const_iterator end() const noexcept; reverse_iterator rbegin() noexcept; const_reverse_iterator rbegin() const noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rend() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; // Capacity size_t size() const noexcept; size_t length() const noexcept; size_t max_size() const noexcept; void resize(size_t n); void resize(size_t n, char c); size_t capacity() const noexcept; void reserve(size_t n = 0); void clear() noexcept; bool empty() const noexcept; void shrink_to_fit(); // Element Access char\u0026 operator[](size_t pos); const char\u0026 operator[](size_t pos) const; char\u0026 at(size_t pos); const char\u0026 at(size_t pos) const; char\u0026 back(); const char\u0026 back() const; char\u0026 front(); const char\u0026 front() const; // Modifiers string\u0026 operator+=(const string\u0026 str); string\u0026 operator+=(const char* s); string\u0026 operator+=(char c); string\u0026 operator+=(initializer_list\u003cchar\u003e il); string\u0026 append(const string\u0026 str); string\u0026 append(const string\u0026 str, size_t subpos, size_t sublen); string\u0026 append(const char* s); string\u0026 append(const char* s, size_t n); string\u0026 append(size_t n, char c); template \u003cclass InputIterator\u003e string\u0026 append(InputIterator first, InputIterator last); string\u0026 append(initializer_list\u003cchar\u003e il); void push_back(char c); string\u0026 assign(const string\u0026 str); string\u0026 assign(const string\u0026 str, size_t subpos, size_t sublen); string\u0026 assign(const char* s); string\u0026 assign(const char* s, size_t n); string\u0026 assign(size_t n, char c); template \u003cclass InputIterator\u003e string\u0026 assign(InputIterator first, InputIterator last); string\u0026 assign(initializer_list\u003cchar\u003e il); string\u0026 assign(string\u0026\u0026 str) noexcept; string\u0026 insert(size_t pos, const string\u0026 str); string\u0026 insert(size_t pos, const string\u0026 str, size_t subpos, size_t sublen); string\u0026 insert(size_t pos, const char* s); string\u0026 insert(size_t pos, const char* s, size_t n); string\u0026 insert(size_t pos, size_t n, char c); iterator insert(const_iterator p, size_t n, char c); iterator insert(const_iterator p, char c); template \u003cclass InputIterator\u003e iterator insert(iterator p, InputIterator first, InputIterator last); string\u0026 insert(const_iterator p, initializer_list\u003cchar\u003e il); string\u0026 erase(size_t pos = 0, size_t len = npos); iterator erase(const_iterator p); iterator erase(const_iterator first, const_iterator last); string\u0026 replace(size_t pos, size_t len, const string\u0026 str); string\u0026 replace(const_iterator i1, const_iterator i2, const string\u0026 str); string\u0026 replace(size_t pos, size_t len, const string\u0026 str, size_t subpos, size_t sublen); string\u0026 replace(size_t pos, size_t len, const char* s); string\u0026 replace(const_iterator i1, const_iterator i2, const char* s); string\u0026 replace(size_t pos, size_t len, const char* s, size_t n); string\u0026 replace(const_iterator i1, const_iterator i2, const char* s, size_t n); string\u0026 replace(size_t pos, size_t len, size_t n, char c); string\u0026 replace(const_iterator i1, const_iterator i2, size_t n, char c); template \u003cclass InputIterator\u003e string\u0026 replace(const_iterator i1, const_iterator i2, InputIterator first, InputIterator last); string\u0026 replace(const_iterator i1, const_iterator i2, in","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:4:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-1"},{"categories":["programming"],"content":" 4.2 使用 头文件 #include \u003cstring\u003e 新增操作 std::string str(\"\"); str += \"Hello\"; str.append(\"World\"); str.push_back('\\0'); // 新增'\\0'字符 删除操作 str.erase(5, 3); // 删除第5个字符往后3个 str.erase(str.begin() + 3); // 删除第4个字符 str.erase(str.begin(), str.end() - 3); // 删除开始到最后3个字符 str.clear(); // 清空字符 str.pop_back(); // 删除最后1个字符 修改操作 str.replace(3, 4, \"just\"); str.replace(4, 1, 3, '!'); str.replace(str.begin(), str.end() - 3, str2); str = \"Hello\"; str[0] = 'W'; str.at(1) = 'S'; 查找操作 std::size_t found = str.find(str2); if (found != std::string::npos) { std::cout \u003c\u003c \"first 'needle' found at: \" \u003c\u003c found \u003c\u003c std::endl; } 遍历操作 std::cout \u003c\u003c str.c_str() \u003c\u003c std::endl; std::cout \u003c\u003c str.data() \u003c\u003c std::endl; 字符串转换 string 转 char* str.c_str() or str.data(); printf(\"%s\", str.c_str()); char* 转 string std::string str = \"Hello\"; string 转 int std::string str = \"123\"; int num = atoi(str.c_str()); // 123 int 转 string std::cout \u003c\u003c std::to_string(123) \u003c\u003c std::endl; // \"123\" stringstream 转 string std::stringstream ss; ss \u003c\u003c 123; std::cout \u003c\u003c ss.str() \u003c\u003c std::endl; // 123 其他操作 std::cout \u003c\u003c str.size() \u003c\u003c std::endl; // 长度 std::cout \u003c\u003c str.length() \u003c\u003c std::endl; // 长度 if (str1.compare(str2) != 0) { // 字符串比较 std::cout \u003c\u003c str1 \u003c\u003c \" is not \" \u003c\u003c str2 \u003c\u003c std::endl; } std::cout \u003c\u003c str.substr() \u003c\u003c std::endl; // 子串 ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:4:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-1"},{"categories":["programming"],"content":" 5 vector","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:5:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#vector"},{"categories":["programming"],"content":" 5.1 定义向量是表示可以更改大小的数组的序列容器。和数组一样，其元素使用连续的存储位置，但不同的是向量大小是可以动态变化。 原型如下： template \u003cclass T, class Alloc = allocator\u003cT\u003e\u003e class vector; API 定义 template \u003cclass T, class Alloc = allocator\u003cT\u003e\u003e class vector { public: explicit vector(const allocator_type\u0026 alloc = allocator_type()); explicit vector(size_type n); vector(size_type n, const value_type\u0026 val, const allocator_type\u0026 alloc = allocator_type()); template \u003cclass InputIterator\u003e vector(InputIterator first, InputIterator last, const allocator_type\u0026 alloc = allocator_type()); vector(const vector\u0026 x); vector(const vector\u0026 x, const allocator_type\u0026 alloc); vector(vector\u0026\u0026 x); vector(vector\u0026\u0026 x, const allocator_type\u0026 alloc); vector(initializer_list\u003cvalue_type\u003e il, const allocator_type\u0026 alloc = allocator_type()); ~vector(); vector\u0026 operator=(const vector\u0026 x); vector\u0026 operator=(vector\u0026\u0026 x); vector\u0026 oerator=(initializer_list\u003cvalue_type\u003e il); // Iterators iterator begin() noexcept; const_iterator begin() const noexcept; iterator end() noexcept; const_iterator end() const noexcept; reverse_iterator rbegin() noexcept; const_reverse_iterator rbegin() const noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rend() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; // Capacity size_type size() const noexcept; size_type max_size() const noexcept; void resize(size_type n); void resize(size_type n, const value_type\u0026 val); size_type capacity() const noexcept; bool empty() const noexcept; void reserve(size_type n); void shrink_to_fit(); // Element Access reference operator[](size_type n); const_reference operator[](size_type n) const; reference at(size_type n); const_reference at(size_type n) const; reference front(); const_reference front() const; reference back(); const_reference back() const; value_type* data() noexcept; const value_type* data() const noexcept; // Modifiers template \u003cclass InputIterator\u003e void assign(InputIterator first, InputIterator last); void assign(size_type n, const value_type\u0026 val); void assign(initializer_list\u003cvalue_type\u003e il); void push_back(const value_type\u0026 val); void push_back(value_type\u0026\u0026 val); void pop_back(); iterator insert(const_iterator position, const value_type\u0026 val); iterator insert(const_iterator position, size_type n, const value_type\u0026 val); template \u003cclass InputIterator\u003e iterator insert(const_iterator position, InputIterator first, InputIterator last); iterator insert(const_iterator position, value_type\u0026\u0026 val); iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il); iterator erase(const_iterator position); iterator erase(const_iterator first, const_iterator last); void swap(vector\u0026 x); void clear() noexcept; template \u003cclass... Args\u003e iterator emplace(const_iterator position, Args\u0026\u0026... args); template \u003cclass... Args\u003e void emplace_back(Args\u0026\u0026... args); // Allocator allocator_type get_allocator() const noexcept; }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:5:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-2"},{"categories":["programming"],"content":" 5.2 使用 头文件 #include \u003cvector\u003e 新增操作 std::vector\u003cint\u003e vec; vec.push_back(1); vec.insert(vec.begin(), 2); vec.emplace(vec.begin(), 3); vec.emplace_back(4); 删除操作 std::vector\u003cint\u003e vec; vec.pop_back(); vec.erase(vec.begin()); vec.clear(); std::vector\u003cint\u003e().swap(vec); 修改操作 std::vector\u003cint\u003e vec; vec[0] = 10; int *p = vec.data(); *p = 11; 查找操作 auto it = find(vec.begin(), vec.end(), 11); if (it != vec.end()) { std::cout \u003c\u003c \"found\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"not found\" \u003c\u003c std::endl; } 遍历操作 for (size_t i = 0; i \u003c vec.size(); ++i) { std::cout \u003c\u003c vec[i] \u003c\u003c std::endl; } // or for (const auto\u0026 it : vec) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } // or for (auto it = vec.begin(); it != vec.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:5:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-2"},{"categories":["programming"],"content":" 6 list","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:6:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#list"},{"categories":["programming"],"content":" 6.1 定义列表是序列容器，允许在序列中的任何位置进行恒定时间插入和擦除操作，并允许双向迭代。列表容器实现为双链接列表。 原型如下: template \u003cclass T, class Alloc = allocator\u003cT\u003e\u003e class list; API 定义 template \u003cclass T, class Alloc = allocator\u003cT\u003e\u003e class list { public: explicit list(const allocator_type\u0026 alloc = allocator_type()); explicit list(size_type n); list(size_type n, const value_type\u0026 val, const allocator_type\u0026 alloc = allocator_type()); template \u003cclass InputIterator\u003e list(InputIterator first, InputIterator last, const allocator_type\u0026 alloc = allocator_type()); list(const list\u0026 x); list(const list\u0026 x, const allocator_type\u0026 alloc); list(list\u0026\u0026 x); list(list\u0026\u0026 x, const allocator_type\u0026 alloc); list(initializer_list\u003cvalue_type\u003e il, const allocator_type\u0026 alloc = allocator_type()); ~list(); list\u0026 operator=(const list\u0026 x); list\u0026 operator=(list\u0026\u0026 x); list\u0026 operator=(initializer_list\u003cvalue_type\u003e il); // Iterators iterator begin() noexcept; const_iterator begin() const noexcept; iterator end() noexcept; const_iterator end() const noexcept; reverse_iterator rbegin() noexcept; const_reverse_iterator rbegin() const noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rend() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; // Capacity size_type size() const noexcept; size_type max_size() const noexcept; bool empty() const noexcept; // Element Access reference front(); const_reference front() const; reference back(); const_reference back() const; // Modifiers template \u003cclass InputIterator\u003e void assign(InputIterator first, InputIterator last); void assign(size_type n, const value_type\u0026 val); void assign(initializer_list\u003cvalue_type\u003e il); template \u003cclass... Args\u003e void emplace_front(Args\u0026\u0026... args); void push_back(const value_type\u0026 val); void push_back(value_type\u0026\u0026 val); void pop_back(); template \u003cclass... Args\u003e iterator emplace(const_iterator position, Args\u0026\u0026... args); iterator insert(const_iterator position, const value_type\u0026 val); iterator insert(const_iterator position, size_type n, const value_type\u0026 val); template \u003cclass InputIterator\u003e iterator insert(const_iterator position, InputIterator first, InputIterator last); iterator insert(const_iterator position, value_type\u0026\u0026 val); iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il); iterator erase(const_iterator position); iterator erase(const_iterator first, const_iterator last); void swap(vector\u0026 x); void resize(size_type n); void resize(size_type n, const value_type\u0026 val); void clear() noexcept; // Operations void splice(const_iterator position, list\u0026 x); void splice(const_iterator position, list\u0026\u0026 x); void splice(const_iterator position, list\u0026 x, const_iterator i); void splice(const_iterator position, list\u0026\u0026 x, const_iterator i); void splice(const_iterator position, list\u0026 x, const_iterator first, const_iterator last); void splice(const_iterator position, list\u0026\u0026 x, const_iterator first, const_iterator last); void remove(const value_type\u0026 val); template \u003cclass Predicate\u003e void remove_if(Predicate pred); void unique(); template \u003cclass BinaryPredicate\u003e void unique(BinaryPredicate binary_pred); void merge(list\u0026 x); void merge(list\u0026\u0026 x); template \u003cclass Compare\u003e void merge(list\u0026 x, Compare comp); template \u003cclass Compare\u003e void merge(list\u0026\u0026 x, Compare comp); void sort(); template \u003cclass Compare\u003e void sort(Compare comp); void reverse() noexcept; // Allocator allocator_type get_allocator() const noexcept; }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:6:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-3"},{"categories":["programming"],"content":" 6.2 使用 头文件 #include \u003clist\u003e 新增操作 std::list\u003cint\u003e li; li.emplace_front(1); li.emplace_back(2); li.push_front(3); li.push_back(4); li.emplace(li.begin(), 5); li.insert(li.begin(), 6); 删除操作 std::list\u003cint\u003e li; li.pop_front(); li.pop_back(); li.remove(7); li.clear(); li.erase(li.begin()); 修改操作 列表只能用迭代器进行访问元素。 查找操作 auto it = find(li.begin(), li.end(), 11); if (it != li.end()) { std::cout \u003c\u003c \"found\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"not found\" \u003c\u003c std::endl; } 遍历操作 for (const auto\u0026 it : li) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } // or for (auto it = li.begin(); it != li.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:6:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-3"},{"categories":["programming"],"content":" 7 forward_list","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:7:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#forward_list"},{"categories":["programming"],"content":" 7.1 定义前向列表是序列容器，允许恒定时间插入和擦除序列中的任何地方操作。前向列表实现为单链接列表。 原型如下: template \u003cclass T, class Alloc = allocator\u003cT\u003e\u003e class forward_list; API 定义 template \u003cclass T, class Alloc = allocator\u003cT\u003e\u003e class forward_list { public: explicit forward_list(const allocator_type\u0026 alloc = allocator_type()); explicit forward_list(size_type n); forward_list(size_type n, const value_type\u0026 val, const allocator_type\u0026 alloc = allocator_type()); template \u003cclass InputIterator\u003e forward_list(InputIterator first, InputIterator last, const allocator_type\u0026 alloc = allocator_type()); forward_list(const forward_list\u0026 fwdlst); forward_list(const forward_list\u0026 fwdlst, const allocator_type\u0026 alloc); forward_list(forward_list\u0026\u0026 fwdlst); forward_list(forward_list\u0026\u0026 fwdlst, const allocator_type\u0026 alloc); forward_list(initializer_list\u003cvalue_type\u003e il, const allocator_type\u0026 alloc = allocator_type()); ~forward_list(); forward_list\u0026 operator=(const forward_list\u0026 fwdlst); forward_list\u0026 operator=(forward_list\u0026\u0026 fwdlst); forward_list\u0026 operator=(initializer_list\u003cvalue_type\u003e il); // Iterators iterator before_begin() noexcept; const_iterator before_begin() const noexcept; iterator begin() noexcept; const_iterator begin() const noexcept; iterator end() noexcept; const_iterator end() const noexcept; const_iterator cbefore_begin() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; // Capacity size_type max_size() const noexcept; bool empty() const noexcept; // Element Access reference front(); const_reference front() const; // Modifiers template \u003cclass InputIterator\u003e void assign(InputIterator first, InputIterator last); void assign(size_type n, const value_type\u0026 val); void assign(initializer_list\u003cvalue_type\u003e il); template \u003cclass... Args\u003e void emplace_front(Args\u0026\u0026... args); void push_front(const value_type\u0026 val); void push_front(value_type\u0026\u0026 val); void pop_front(); template \u003cclass... Args\u003e iterator emplace_after(const_iterator position, Args\u0026\u0026... args); iterator insert_after(const_iterator position, const value_type\u0026 val); iterator insert_after(const_iterator position, value_type\u0026\u0026 val); iterator insert_after(const_iterator position, size_type n, const value_type\u0026 val); template \u003cclass InputIterator\u003e iterator insert_after(const_iterator position, InputIterator first, InputIterator last); iterator insert_after(const_iterator position, initializer_list\u003cvalue_type\u003e il); iterator erase_after(const_iterator position); iterator erase_after(const_iterator position, const_iterator last); void swap(forward_list\u0026 fwdlst); void resize(size_type n); void resize(size_type n, const value_type\u0026 val); void clear() noexcept; // Operations void remove(const value_type\u0026 val); template \u003cclass Predicate\u003e void remove_if(Predicate pred); void unique(); template \u003cclass BinaryPredicate\u003e void unique(BinaryPredicate binary_pred); void merge(forward_list\u0026 fwdlst); void merge(forward_list\u0026\u0026 fwdlst); template \u003cclass Compare\u003e void merge(forward_list\u0026 fwdlst, Compare comp); template \u003cclass Compare\u003e void merge(forward_list\u0026\u0026 fwdlst, Compare comp); void sort(); template \u003cclass Compare\u003e void sort(Compare comp); void reverse() noexcept; // Allocator allocator_type get_allocator() const noexcept; }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:7:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-4"},{"categories":["programming"],"content":" 7.2 使用 头文件 #include \u003cforward_list\u003e 新增操作 std::forward_list\u003cint\u003e fl; fl.emplace_front(10); fl.push_front(11); fl.emplace_back(fl.begin(), 12); fl.insert_after(fl.begin(), 13); 删除操作 std::forward_list\u003cint\u003e fl; fl.pop_front(); fl.erase_after(fl.begin()); fl.remove(14); fl.remove_if([](const int\u0026 value) { return value \u003c 15; }); 修改操作 前向列表只能用迭代器进行访问元素。 查找操作 auto it = find(fl.begin(), fl.end(), 11); if (it != fl.end()) { std::cout \u003c\u003c \"found\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"not found\" \u003c\u003c std::endl; } 遍历操作 for (const auto\u0026 it : fl) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } // or for (auto it = fl.begin(); it != fl.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:7:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-4"},{"categories":["programming"],"content":" 8 deque","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:8:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#deque"},{"categories":["programming"],"content":" 8.1 定义原型如下: template \u003cclass T, class Alloc = allocator\u003cT\u003e\u003e class deque; API 定义 template \u003cclass T, class Alloc = allocator\u003cT\u003e\u003e class deque { public: explicit deque(const allocator_type\u0026 alloc = allocator_type()); explicit deque(size_type n); deque(size_type n, const value_type\u0026 val, const allocator_type\u0026 alloc = allocator_type()); template \u003cclass InputIterator\u003e deque(InputIterator first, InputIterator last, const allocator_type\u0026 alloc = allocator_type()); deque(const deque\u0026 x); deque(const deque\u0026 x, const allocator_type\u0026 alloc); deque(deque\u0026\u0026 x); deque(deque\u0026\u0026 x, const allocator_type\u0026 alloc); deque(initializer_list\u003cvalue_type\u003e il, const allocator_type\u0026 alloc = allocator_type()); ~deque(); deque\u0026 operator=(const deque\u0026 x); deque\u0026 operator=(deque\u0026\u0026 x); deque\u0026 operator=(initializerlist\u003cvalue_type\u003e il); // Iterators iterator begin() noexcept; const_iterator begin() const noexcept; iterator end() noexcept; const_iterator end() const noexcept; reverse_iterator rbegin() noexcept; const_reverse_iterator rbegin() const noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rend() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; // Capacity size_type size() const noexcept; size_type max_size() const noexcept void resize(size_type n); void resize(size_type n, const value_type\u0026 val); bool empty() const noexcept; void shrink_to_fit(); // Element Access reference operator[](size_type n); const_reference operator[](size_type n) const; reference at(size_type n); const_reference at(size_type n) const; reference front(); const_reference front() const; reference back(); const_reference back() const; // Modifiers template \u003cclass InputIterator\u003e void assign(InputIterator first, InputIterator last); void assign(size_type n, const value_type\u0026 val); void assign(initializer_list\u003cvalue_type\u003e il); template \u003cclass... Args\u003e void emplace_front(Args\u0026\u0026... args); void push_front(const value_type\u0026 val); void push_front(value_type\u0026\u0026 val); void push_back(const value_type\u0026 val); void push_back(value_type\u0026\u0026 val); void pop_front(); void pop_back(); iterator insert(const_iterator position, const value_type\u0026 val); iterator insert(const_iterator position, size_type n, const value_type\u0026 val); template \u003cclass InputIterator\u003e iterator insert(const_iterator position, InputIterator first, InputIterator last); iterator insert(const_iterator position, value_type\u0026\u0026 val); iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il); iterator erase(const_iterator position); iterator erase(const_iterator first, const_iterator last); void swap(deque\u0026 x); void clear() noexcept; template \u003cclass... Args\u003e iterator emplace(const_iterator position, Args\u0026\u0026... args); template \u003cclass... Args\u003e void emplace_front(Args\u0026\u0026... args); template \u003cclass... Args\u003e void emplace_back(Args\u0026\u0026... args); // Allocator allocator_type get_allocator() const noexcept; }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:8:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-5"},{"categories":["programming"],"content":" 8.2 使用 头文件 #include \u003cdeque\u003e 新增操作 std::deque\u003cint\u003e q; q.push_front(1); q.push_back(2); q.insert(q.begin(), 3); q.emplace(q.begin(), 4); q.emplace_front(5); q.emplace_back(6); 删除操作 std::deque\u003cint\u003e q; q.pop_front(); q.pop_back(); q.erase(q.begin()); q.clear(); 修改操作 std::deque\u003cint\u003e q; q[0] = 7; q.at(1) = 8; 查找操作 auto it = find(q.begin(), q.end(), 11); if (it != q.end()) { std::cout \u003c\u003c \"found\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"not found\" \u003c\u003c std::endl; } 遍历操作 for (size_t i = 0; i \u003c q.size(); ++i) { std::cout \u003c\u003c q[i] \u003c\u003c std::endl; } // or for (const auto\u0026 it : q) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } // or for (auto it = q.begin(); it != q.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:8:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-5"},{"categories":["programming"],"content":" 9 map","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:9:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#map"},{"categories":["programming"],"content":" 9.1 定义map 是有序关联容器，其元素是由键值对的方式存储，底层是用红黑树实现的，可以快速的查找对象。 原型如下: template \u003cclass Key, // map::key_type class T, // map::mapped_type class Compare = less\u003cKey\u003e, // map::key_compare class Alloc = allocator\u003cpair\u003cconst Key, T\u003e\u003e // map::allocator_type \u003e class map; API 定义 template \u003cclass Key, // map::key_type class T, // map::mapped_type class Compare = less\u003cKey\u003e, // map::key_compare class Alloc = allocator\u003cpair\u003cconst Key, T\u003e\u003e\u003e // map::allocator_type class map { public: explicit map(const key_compare\u0026 comp = key_compare(), const allocator_type\u0026 alloc = allocator_type()); explicit map(const allocator_type\u0026 alloc); template \u003cclass InputIterator\u003e map(InputIterator first, InputIterator last, const key_compare\u0026 comp = key_compare(), const allocator_type\u0026 = allocator_type()); map(const map\u0026 x); map(const map\u0026 x, const allocator_type\u0026 alloc); map(map\u0026\u0026 x); map(map\u0026\u0026 x, const allcator_type\u0026 alloc); map(initializer_list\u003cvalue_type\u003e il, const key_compare\u0026 comp = key_compare(), const allocator_type\u0026 alloc = allocator_type()); ~map(); map\u0026 operator=(const map\u0026 x); map\u0026 operator=(map\u0026\u0026 x); map\u0026 operator=(initializer_list\u003cvalue_type\u003e il); // Iterators iterator begin() noexcept; const_iterator begin() const noexcept; iterator end() noexcept; const_iterator end() const noexcept; reverse_iterator rbegin() noexcept; const_reverse_iterator rbegin() const noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rend() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; // Capacity size_type size() const noexcept; size_type max_size() const noexcept bool empty() const noexcept; // Element Access mapped_type\u0026 operator[](const key_type\u0026 k); mapped_type\u0026 operator[](key_type\u0026\u0026 k); mapped_type\u0026 at(const key_type\u0026 k); const mapped_type\u0026 at(const key_type\u0026 k) const; // Modifiers pair\u003citerator, bool\u003e insert(const value_type\u0026 val); template \u003cclass P\u003e pair\u003citerator, bool\u003e insert(P\u0026\u0026 val); iterator insert(const_iterator position, const value_type\u0026 val); template \u003cclass P\u003e iterator insert(const_iterator position, P\u0026\u0026 val); template \u003cclass InputIterator\u003e void insert(InputIterator first, InputIterator last); void insert(initializer_list\u003cvalue_type\u003e il); iterator erase(const_iterator position); size_type erase(const key_type\u0026 k); iterator erase(const_iterator first, const_iterator last); void swap(map\u0026 x); void clear() noexcept; template \u003cclass... Args\u003e pair\u003citerator, bool\u003e emplace(Args\u0026\u0026... args); template \u003cclass... Args\u003e iterator emplace_hint(const_iterator position, Args\u0026\u0026... args); // Observers key_compare key_comp() const; value_compare value_comp() const; // Operations iterator find(const key_type\u0026 k); const_iterator find(const key_type\u0026 k) const; size_type count(const key_type\u0026 k) const; iterator lower_bound(const key_type\u0026 k); const_iterator lower_bound(const key_type\u0026 k) const; iterator upper_bound(const key_type\u0026 k); const_iterator upper_bound(const key_type\u0026 k) const; pair\u003cconst_iterator, const_iterator\u003e equal_range(const key_type\u0026 k) const; pair\u003citerator, iterator\u003e equal_range(const key_type\u0026 k); // Allocator allocator_type get_allocator() const noexcept; }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:9:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-6"},{"categories":["programming"],"content":" 9.2 使用 头文件 #include \u003cmap\u003e 新增操作 std::map\u003cint, std::string\u003e m; m[1] = \"Hello\"; a.at(2) = \" \"; m.insert(std::pair\u003cint, std::string\u003e(3, \"World\")); m.emplace(4, \"!\"); m.emplace_hint(5, \"hahhh\"); 删除操作 std::map\u003cint, std::string\u003e m; m.erase(m.begin()); m.erase(2); m.clear(); 修改操作 std::map\u003cint, std::string\u003e m; m[2] = \"OK\"; 查找操作 auto\u0026 it = m.find(2); if (it != m.end()) { m.erase(it); } 遍历操作 for (auto\u0026 it : m) { std::cout \u003c\u003c \"m[\" \u003c\u003c it.first \u003c\u003c \"] = \" \u003c\u003c it.second \u003c\u003c std::endl; } // or for (auto\u0026 it = m.begin(); it != m.end(); ++it) { std::cout \u003c\u003c \"m[\" \u003c\u003c it-\u003efirst \u003c\u003c \"] = \" \u003c\u003c it-\u003esecond \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:9:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-6"},{"categories":["programming"],"content":" 10 unordered_map","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:10:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#unordered_map"},{"categories":["programming"],"content":" 10.1 定义unordered_map 是无序关联容器，其元素是由键值对的方式存储，底层是用哈希表实现的，可以根据单个元素的密钥快速检索。 原型如下: template \u003cclass Key, // unordered_map::key_type class T, // unordered_map::mapped_type class Hash = hash\u003cKey\u003e, // unordered_map::hasher class Pred = equal_to\u003cKey\u003e, // unordered_map::key_equal class Alloc = allocator\u003cpair\u003cconst Key, T\u003e\u003e // unordered_map::allocator_type \u003e class unordered_map; API 定义 template \u003cclass Key, // unordered_map::key_type class T, // unordered_map::mapped_type class Hash = hash\u003cKey\u003e, // unordered_map::hasher class Pred = equal_to\u003cKey\u003e, // unordered_map::key_equal class Alloc = allocator\u003cpair\u003cconst Key, T\u003e\u003e\u003e // unordered_map::allocator_type class unordered_map { public: explicit unordered_map(size_type n = /* see below */, const hasher\u0026 hf = hasher(), const key_equal\u0026 eql = key_equal(), const allocator_type\u0026 alloc = allocator_type()); explicit unordered_map(const allocator_type\u0026 alloc); template \u003cclass InputIterator\u003e unordered_map(InputIterator first, InputIterator last, size_type n = /* see below */, const hasher\u0026 hf = hasher(), const key_equal\u0026 eql = key_equal(), const allocator_type\u0026 alloc = allocator_type()); unordered_map(const unordered_map\u0026 ump); unordered_map(const unordered_map\u0026 ump, const allocator_type\u0026 alloc); unordered_map(unordered_map\u0026\u0026 ump); unordered_map(unordered_map\u0026\u0026 ump, const allocator_type\u0026 alloc); unordered_map(initializer_list\u003cvalue_type\u003e il, size_type n = /* see below */, const hasher\u0026 hf = hasher(), const key_equal\u0026 eql = key_equal(), const allocator_type\u0026 alloc = allocator_type()); ~unordered_map(); unordered_map\u0026 operator=(const unordered_map\u0026 ump); unordered_map\u0026 operator=(unordered_map\u0026\u0026 ump); unordered_map\u0026 operator=(initializer_list\u003cvalue_type\u003e il); // Iterators iterator begin() noexcept; const_iterator begin() const noexcept; local_iterator begin(size_type n); const_local_iterator begin(size_type n) const; iterator end() noexcept; const_iterator end() const noexcept; local_iterator end(size_type n); const_local_iterator end(size_type n) const; const_iterator cbegin() const noexcept; const_local_iterator cbegin(size_type n) const; const_iterator cend() const noexcept; const_local_iterator cend(size_type n)const; // Capacity size_type size() const noexcept; size_type max_size() const noexcept bool empty() const noexcept; // Element Access mapped_type\u0026 operator[](const key_type\u0026 k); mapped_type\u0026 operator[](key_type\u0026\u0026 k); mapped_type\u0026 at(const key_type\u0026 k); const mapped_type\u0026 at(const key_type\u0026 k) const; // Element Lookup iterator find(const key_type\u0026 k); const_iterator find(const key_type\u0026 k) const; size_type count(const key_type\u0026 k) const; pair\u003citerator, iterator\u003e equal_range(const key_type\u0026 k); pair\u003cconst_iterator, const_iterator\u003e equal_range(const key_type\u0026 k) const; // Modifiers template \u003cclass... Args\u003e pair\u003citerator, bool\u003e emplace(Args\u0026\u0026... args); template \u003cclass... Args\u003e iterator emplace_hint(const_iterator position, Args\u0026\u0026... args); pair\u003citerator, bool\u003e insert(const value_type\u0026 val); template \u003cclass P\u003e pair\u003citerator, bool\u003e insert(P\u0026\u0026 val); iterator insert(const_iterator hint, const value_type\u0026 val); template \u003cclass P\u003e iterator insert(const_iterator hint, P\u0026\u0026 val); template \u003cclass InputIterator\u003e void insert(InputIterator first, InputIterator last); void insert(initializer_list\u003cvalue_type\u003e il); iterator erase(const_iterator position); size_type erase(const key_type\u0026 k); iterator erase(const_iterator first, const_iterator last); void clear() noexcept; void swap(unordered_map\u0026 ump); // Buckets size_type bucket_count() const noexcept; size_type max_bucket_count() const noexcept; size_type bucket_size(size_type n) const; size_type bucket(const key_type\u0026 k) const; // Hash Policy float load_factor() const noexcept; float max_load_factor() const noexcept; void max_load_factor(float z); void rehash( size_type n); void reserve(size_type n); // Observers hasher hash_function() const; key_equal key_eq() const; allocator_type get_allocator() const noexcept; }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:10:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-7"},{"categories":["programming"],"content":" 10.2 使用 头文件 #include \u003cunordered_map\u003e 新增操作 std::unordered_map\u003cint, std::string\u003e umap; umap[1] = \"Hello\"; umap.at(2) = \"World\"; umap.emplace(3, \"Face\"); umap.emplace(umap.begin(), \"To\"); umap.insert({4, \"Smile\"}); umap.insert(std::make_pair\u003cint, std::string\u003e(5, \"OK\")); 删除操作 std::unordered_map\u003cint, std::string\u003e umap; umap.erase(umap.begin()); umap.clear(); 修改操作 std::unordered_map\u003cint, std::string\u003e umap; umap[1] = \"Map\"; 查找操作 auto\u0026 it = umap.find(2); if (it != umap.end()) { umap.erase(it); } 遍历操作 for (auto\u0026 it : umap) { std::cout \u003c\u003c \"umap[\" \u003c\u003c it.first \u003c\u003c \"] = \" \u003c\u003c it.second \u003c\u003c std::endl; } // or for (auto\u0026 it = umap.begin(); it != umap.end(); ++it) { std::cout \u003c\u003c \"umap[\" \u003c\u003c it-\u003efirst \u003c\u003c \"] = \" \u003c\u003c it-\u003esecond \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:10:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-7"},{"categories":["programming"],"content":" 11 set","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:11:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#set"},{"categories":["programming"],"content":" 11.1 定义集合是按照特定顺序存储唯一元素的容器。底层是用红黑树实现的，可以快速的查找对象。 原型如下: template \u003cclass T, // set::key_type/value_type class Compare = less\u003cT\u003e, // set::key_compare/value_compare class Alloc = allocator\u003cT\u003e // set::allocator_type \u003e class set; API 定义 template \u003cclass T, // set::key_type/value_type class Compare = less\u003cT\u003e, // set::key_compare/value_compare class Alloc = allocator\u003cT\u003e\u003e // set::allocator_type class set { public: explicit set(const key_compare\u0026 comp = key_compare(), const allocator_type\u0026 alloc = allocator_type()); explicit set(const allocator_type\u0026 alloc); template \u003cclass InputIterator\u003e set(InputIterator first, InputIterator last, const key_compare\u0026 comp = key_compare(), const allocator_type\u0026 = allocator_type()); set(const set\u0026 x); set(const set\u0026 x, const allocator_type\u0026 alloc); set(set\u0026\u0026 x); set(set\u0026\u0026 x, const allocator_type\u0026 alloc); set(initializer_list\u003cvalue_type\u003e il, const key_compare\u0026 comp = key_compare(), const allocator_type\u0026 alloc = allocator_type()); ~set(); set\u0026 operator=(const set\u0026 x); set\u0026 operator=(set\u0026\u0026 x); set\u0026 operator=(initializer_list\u003cvalue_type\u003e il); // Iterators iterator begin() noexcept; const_iterator begin() const noexcept; iterator end() noexcept; const_iterator end() const noexcept; reverse_iterator rbegin() noexcept; const_reverse_iterator rbegin() const noexcept; reverse_iterator rend() noexcept; const_reverse_iterator rend() const noexcept; const_iterator cbegin() const noexcept; const_iterator cend() const noexcept; const_reverse_iterator crbegin() const noexcept; const_reverse_iterator crend() const noexcept; // Capacity size_type size() const noexcept; size_type max_size() const noexcept bool empty() const noexcept; // Modifiers pair\u003citerator, bool\u003e insert(const value_type\u0026 val); pair\u003citerator, bool\u003e insert(value_type\u0026\u0026 val); iterator insert(const_iterator position, const value_type\u0026 val); iterator insert(const_iterator position, value_type\u0026\u0026 val); template \u003cclass InputIterator\u003e void insert(InputIterator first, InputIterator last); void insert(initializer_list\u003cvalue_type\u003e il); iterator erase(const_iterator position); size_type erase(const value_type\u0026 val); iterator erase(const_iterator first, const_iterator last); void clear() noexcept; void swap(set\u0026 ump); template \u003cclass... Args\u003e pair\u003citerator, bool\u003e emplace(Args\u0026\u0026... args); template \u003cclass... Args\u003e iterator emplace_hint(const_iterator position, Args\u0026\u0026... args); // Observers key_compare key_comp() const; value_compare value_comp() const; // Operations const_iterator find(const value_type\u0026 val) const; iterator find(const value_type\u0026 val); size_type count(const value_type\u0026 val) const; iterator lower_bound(const value_type\u0026 val); const_iterator lower_bound(const value_type\u0026 val) const; iterator upper_bound(const value_type\u0026 val); const_iterator upper_bound(const value_type\u0026 val) const; pair\u003cconst_iterator, const_iterator\u003e equal_range(const value_type\u0026 val) const; pair\u003citerator, iterator\u003e equal_range(const value_type\u0026 val); // Allocator allocator_type get_allocator() const noexcept; }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:11:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-8"},{"categories":["programming"],"content":" 11.2 使用 头文件 #include \u003cset\u003e 新增操作 std::set\u003cint\u003e s; s.insert(10); s.emplace(11); s.emplace_hint(s.begin(), 12); 删除操作 std::set\u003cint\u003e s; s.erase(s.begin()); s.erase(13); s.clear(); 修改操作 集合中元素的值是常量，不能在容器中进行修改，但它们可以从容器中插入或删除。 查找操作 auto\u0026 it = s.find(2); if (it != s.end()) { s.erase(it); } 遍历操作 for (auto\u0026 it : s) { std::cout \u003c\u003c \"s[\" \u003c\u003c it.first \u003c\u003c \"] = \" \u003c\u003c it.second \u003c\u003c std::endl; } // or for (auto\u0026 it = s.begin(); it != s.end(); ++it) { std::cout \u003c\u003c \"s[\" \u003c\u003c it-\u003efirst \u003c\u003c \"] = \" \u003c\u003c it-\u003esecond \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:11:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-8"},{"categories":["programming"],"content":" 12 unordered_set","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:12:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#unordered_set"},{"categories":["programming"],"content":" 12.1 定义unordered_set 是无序关联容器，底层是用哈希表实现的，可以根据元素的值快速检索。 原型如下: template \u003cclass Key, // unordered_set::key_type/value_type class Hash = hash\u003cKey\u003e, // unordered_set::hasher class Pred = equal_to\u003cKey\u003e, // unordered_set::key_equal class Alloc = allocator\u003cKey\u003e // unordered_set::allocator_type \u003e class unordered_set; API 定义 template \u003cclass Key, // unordered_set::key_type/value_type class Hash = hash\u003cKey\u003e, // unordered_set::hasher class Pred = equal_to\u003cKey\u003e, // unordered_set::key_equal class Alloc = allocator\u003cKey\u003e\u003e // unordered_set::allocator_type class unordered_set { public: explicit unordered_set(size_type n = /* see below */, const hasher\u0026 hf = hasher(), const key_equal\u0026 eql = key_equal(), const allocator_type\u0026 alloc = allocator_type()); explicit unordered_set(const allocator_type\u0026 alloc); template \u003cclass InputIterator\u003e unordered_set(InputIterator first, InputIterator last, size_type n = /* see below */, const hasher\u0026 hf = hasher(), const key_equal\u0026 eql = key_equal(), const allocator_type\u0026 alloc = allocator_type()); unordered_set(const unordered_set\u0026 ust); unordered_set(const unordered_set\u0026 ust, const allocator_type\u0026 alloc); unordered_set(unordered_set\u0026\u0026 ust); unordered_set(unordered_set\u0026\u0026 ust, const allocator_type\u0026 alloc); unordered_set(initializer_list\u003cvalue_type\u003e il, size_type n = /* see below */, const hasher\u0026 hf = hasher(), const key_equal\u0026 eql = key_equal(), const allocator_type\u0026 alloc = allocator_type()); ~unordered_set(); unordered_set\u0026 operator=(const unordered_set\u0026 ust); unordered_set\u0026 operator=(unordered_set\u0026\u0026 ust); unordered_set\u0026 operator=(initializer_list\u003cvalue_type\u003e il); // Iterators iterator begin() noexcept; const_iterator begin() const noexcept; local_iterator begin(size_type n); const_local_iterator begin(size_type n) const; iterator end() noexcept; const_iterator end() const noexcept; local_iterator end(size_type n); const_local_iterator end(size_type n) const; const_iterator cbegin() const noexcept; const_local_iterator cbegin(size_type n) const; const_iterator cend() const noexcept; const_local_iterator cend(size_type n) const; // Element Lookup iterator find(const key_type\u0026 k); const_iterator find(const key_type\u0026 k) const; size_type count(const key_type\u0026 k) const; pair\u003citerator, iterator\u003e equal_range(const key_type\u0026 k); pair\u003cconst_iterator, const_iterator\u003e equal_range(const key_type\u0026 k) const; // Modifiers template \u003cclass... Args\u003e pair\u003citerator, bool\u003e emplace(Args\u0026\u0026... args); template \u003cclass... Args\u003e iterator emplace_hint(const_iterator position, Args\u0026\u0026... args); pair\u003citerator, bool\u003e insert(const value_type\u0026 val); pair\u003citerator, bool\u003e insert(value_type\u0026\u0026 val); iterator insert(const_iterator hint, const value_type\u0026 val); iterator insert(const_iterator hint, value_type\u0026\u0026 val); template \u003cclass InputIterator\u003e void insert(InputIterator first, InputIterator last); void insert(initializer_list\u003cvalue_type\u003e il); iterator erase(const_iterator position); size_type erase(const key_type\u0026 k); iterator erase(const_iterator first, const_iterator last); void clear() noexcept; void swap(unordered_set\u0026 ump); // Buckets size_type bucket_count() const noexcept; size_type max_bucket_count() const noexcept; size_type bucket_size(size_type n) const; size_type bucket(const key_type\u0026 k) const; // Hash Policy float load_factor() const noexcept; float max_load_factor() const noexcept; void max_load_factor(float z); void rehash(size_type n); void reserve(size_type n); // Observers hasher hash_function() const; key_equal key_eq() const; allocator_type get_allocator() const noexcept; }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:12:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-9"},{"categories":["programming"],"content":" 12.2 使用 头文件 #include \u003cunordered_set\u003e 新增操作 std::unordered_set\u003cint\u003e uset; uset.insert(10); uset.emplace(11); uset.emplace_hint(uset.begin(), 13); 删除操作 std::unordered_set\u003cint\u003e uset; uset.erase(uset.begin()); uset.erase(12); uset.clear(); 修改操作 unordered_set 元素的值同时是其密钥，可以唯一地标识它。键是不可变的，因此 unordered_set 中的元素不能修改。不过，它们可以插入和删除。 查找操作 auto\u0026 it = uset.find(2); if (it != uset.end()) { uset.erase(it); } 遍历操作 for (auto\u0026 it : uset) { std::cout \u003c\u003c \"uset[\" \u003c\u003c it.first \u003c\u003c \"] = \" \u003c\u003c it.second \u003c\u003c std::endl; } // or for (auto\u0026 it = uset.begin(); it != uset.end(); ++it) { std::cout \u003c\u003c \"uset[\" \u003c\u003c it-\u003efirst \u003c\u003c \"] = \" \u003c\u003c it-\u003esecond \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:12:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-9"},{"categories":["programming"],"content":" 13 stack","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:13:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#stack"},{"categories":["programming"],"content":" 13.1 定义栈是一种容器适配器，专门设计用于先进先出，其中元素仅从容器的一端插入和提取。 原型如下: template \u003cclass T, class Container = deque\u003cT\u003e\u003e class stack; API 定义 template \u003cclass T, class Container = deque\u003cT\u003e\u003e class stack { public: explicit stack(const container_type\u0026 ctnr); explicit stack(container_type\u0026\u0026 ctnr = container_type()); template \u003cclass Alloc\u003e explicit stack(const Alloc\u0026 alloc); template \u003cclass Alloc\u003e stack(const container_type\u0026 ctnr, const Alloc\u0026 alloc); template \u003cclass Alloc\u003e stack(container_type\u0026\u0026 ctnr, const Alloc\u0026 alloc); template \u003cclass Alloc\u003e stack(const stack\u0026 x, const Alloc\u0026 alloc); template \u003cclass Alloc\u003e stack(stack\u0026\u0026 x, const Alloc\u0026 alloc); ~stack(); bool empty() const; size_type size() const; reference top(); const_reference top() const; void push(const value_type\u0026 val); void push(value_type\u0026\u0026 val); void pop(); void swap(stack\u0026 x) noexcept(/*see below*/); }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:13:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-10"},{"categories":["programming"],"content":" 13.2 使用 头文件 #include \u003cstack\u003e 新增操作 std::stack\u003cint\u003e s; s.push(1); s.emplace(2); 删除操作 std::stack\u003cint\u003e s; s.pop(); 修改操作 std::stack\u003cint\u003e s; s.top() = 3; 查找操作 无查找操作 遍历操作 std::stack\u003cint\u003e s; while (!s.empty()) { int item = s.top(); s.pop(); std::cout \u003c\u003c item \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:13:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-10"},{"categories":["programming"],"content":" 14 queue","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:14:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#queue"},{"categories":["programming"],"content":" 14.1 定义队列是一种容器适配器，专门设计用于先入先出，其中元素插入容器的一端并从另一端提取。 原型如下: template \u003cclass T, class Container = deque\u003cT\u003e\u003e class queue; API 定义 template \u003cclass T, class Container = deque\u003cT\u003e\u003e class queue { public: explicit queue(const container_type\u0026 ctnr); explicit queue(container_type\u0026\u0026 ctnr = container_type()); template \u003cclass Alloc\u003e explicit queue(const Alloc\u0026 alloc); template \u003cclass Alloc\u003e queue(const container_type\u0026 ctnr, const Alloc\u0026 alloc); template \u003cclass Alloc\u003e queue(container_type\u0026\u0026 ctnr, const Alloc\u0026 alloc); template \u003cclass Alloc\u003e queue(const queue\u0026 x, const Alloc\u0026 alloc); template \u003cclass Alloc\u003e queue(queue\u0026\u0026 x, const Alloc\u0026 alloc); ~queue(); bool empty() const; size_type size() const; reference\u0026 front(); const_reference\u0026 front() const; reference\u0026 back(); const_reference\u0026 back() const; void push(const value_type\u0026 val); void push(value_type\u0026\u0026 val); void pop(); template \u003cclass... Args\u003e void emplace(Args\u0026\u0026... args); void swap(queue\u0026 x) noexcept(/*see below*/); }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:14:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-11"},{"categories":["programming"],"content":" 14.2 使用 头文件 #include \u003cqueue\u003e 新增操作 std::queue\u003cint\u003e q; q.push(1); q.emplace(2); 删除操作 std::queue\u003cint\u003e q; q.pop(); 修改操作 std::queue\u003cint\u003e q; q.front() = 3; q.back() = 4; 查找操作 无查找操作 遍历操作 std::queue\u003cint\u003e q; while (!q.empty()) { int item = q.front(); q.pop(); std::cout \u003c\u003c item \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:14:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-11"},{"categories":["programming"],"content":" 15 priority_queue","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:15:0","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#priority_queue"},{"categories":["programming"],"content":" 15.1 定义优先级队列是一种容器适配器，专门设计使其第一个元素始终是其包含的最大元素。 原型如下: template \u003cclass T, class Container = vector\u003cT\u003e, class Compare = less\u003ctypename Container::value_type\u003e \u003e class priority_queue; API 定义 template \u003cclass T, class Container = vector\u003cT\u003e, class Compare = less\u003ctypename Container::value_type\u003e\u003e class priority_queue { public: priority_queue(const Compare\u0026 comp, const Container\u0026 ctnr); template \u003cclass InputIterator\u003e priority_queue(InputIterator first, InputIterator last, const Compare\u0026 comp, const Container\u0026 ctnr); explicit priority_queue(const Compare\u0026 comp = Compare(), Container\u0026\u0026 ctnr = Container()); template \u003cclass InputIterator\u003e priority_queue(InputIterator first, InputIterator last, const Compare\u0026 comp, Container\u0026\u0026 ctnr = Container()); template \u003cclass Alloc\u003e explicit priority_queue(const Alloc\u0026 alloc); template \u003cclass Alloc\u003e priority_queue(const Compare\u0026 comp, const Alloc\u0026 alloc); tmplate \u003cclass Alloc\u003e priority_queue(const Compare\u0026 comp, const Container\u0026 ctnr, const Alloc\u0026 alloc); template \u003cclass Alloc\u003e priority_queue(const Compare\u0026 comp, Container\u0026\u0026 ctnr, const Alloc\u0026 alloc); template \u003cclass Alloc\u003e priority_queue(const priority_queue\u0026 x, const Alloc\u0026 alloc); template \u003cclass Alloc\u003e priority_queue(priority_queue\u0026\u0026 x, const Alloc\u0026 alloc); ~priority_queue(); bool empty() const; size_type size() const; const_reference top() const; void push(const value_type\u0026 val); void push(value_type\u0026\u0026 val); void pop(); template \u003cclass... Args\u003e void emplace(Args\u0026\u0026... args); void swap(priority_queue\u0026 x) noexcept(/*see below*/); }; ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:15:1","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#定义-12"},{"categories":["programming"],"content":" 15.2 使用 头文件 #include \u003cpriority_queue\u003e 新增操作 std::priority_queue\u003cint\u003e pq; pq.push(1); pq.emplace(2); 删除操作 std::priority_queue\u003cint\u003e pq; pq.pop(); 修改操作 std::priority_queue\u003cint\u003e pq; pq.top() = 3; 查找操作 无查找操作 遍历操作 std::priority_queue\u003cint\u003e pq; while (!pq.empty()) { int item = pq.top(); pq.pop(); std::cout \u003c\u003c item \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/:15:2","series":[],"tags":["programming","Cpp","Cpp11"],"title":"C++11 标准容器使用","uri":"/blog/010_%E6%A0%87%E5%87%86%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/#使用-12"},{"categories":["LeetCode"],"content":" 1 力扣142. 环形链表 II给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。 注意 注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改链表。 示例 1： 输入：head = [3, 2, 0, -4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1, 2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 注意 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 \u003c= Node.val \u003c= 105 pos 的值为 -1 或者链表中的一个有效索引 进阶：你是否可以使用 O(1) 空间解决此题？ 引用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/linked-list-cycle-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:1:0","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#力扣142-环形链表-ii"},{"categories":["LeetCode"],"content":" 2 哈希表","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:2:0","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#哈希表"},{"categories":["LeetCode"],"content":" 2.1 思路与算法遍历链表中的每个节点，并记录下来。一旦遇到之前保存过的节点，就可以判定为环形链表。为了方便查询，使用哈希表结构实现。 ","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:2:1","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#思路与算法"},{"categories":["LeetCode"],"content":" 2.2 代码实现 C++ 实现 class Solution { public: ListNode *detectCycle(ListNode *head) { unordered_set\u003cListNode *\u003e visited; while (head != nullptr) { if (visited.count(head)) { return head; } visited.insert(head); head = head-\u003enext; } return nullptr; } }; Java 实现 public class Solution { public ListNode detectCycle(ListNode head) { ListNode pos = head; Set\u003cListNode\u003e visited = new HashSet\u003cListNode\u003e(); while (pos != null) { if (visited.contains(pos)) { return pos; } else { visited.add(pos); } pos = pos.next; } return null; } } ","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:2:2","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#代码实现"},{"categories":["LeetCode"],"content":" 2.3 复杂度分析时间复杂度：O(N)，其中 N 为链表中节点的数目。需要访问链表中的每一个节点。 空间复杂度：O(N)，其中 N 为链表中节点的数目。需要将链表中的每个节点都保存在哈希表当中。 ","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:2:3","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#复杂度分析"},{"categories":["LeetCode"],"content":" 3 快慢指针","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:3:0","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#快慢指针"},{"categories":["LeetCode"],"content":" 3.1 思路与算法使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。 ","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:3:1","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#思路与算法-1"},{"categories":["LeetCode"],"content":" 3.2 代码实现 C++ 实现 class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head; ListNode *fast = head; while (fast != nullptr) { slow = slow-\u003enext; if (fast-\u003enext == nullptr) { return nullptr; } fast = fast-\u003enext-\u003enext; if (fast == slow) { ListNode *ptr = head; while (ptr != slow) { ptr = ptr-\u003enext; slow = slow-\u003enext; } return ptr; } } return nullptr; } }; Java 实现 public class Solution { public ListNode detectCycle(ListNode head) { if (head == null) { return null; } ListNode slow = head; ListNode fast = head; while (fast != null) { slow = slow.next; if (fast.next != null) { fast = fast.next.next; } else { return null; } if (fast == slow) { ListNode ptr = head; while (ptr != slow) { ptr = ptr.next; slow = slow.next; } return ptr; } } return null; } } ","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:3:2","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#代码实现-1"},{"categories":["LeetCode"],"content":" 3.3 复杂度分析 时间复杂度：O(N)，其中 N 为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。 空间复杂度：O(1)。只使用了三个指针。 ","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:3:3","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#复杂度分析-1"},{"categories":["LeetCode"],"content":" 4 快慢指针的数学分析","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:4:0","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#快慢指针的数学分析"},{"categories":["LeetCode"],"content":" 4.1 快慢指针的相遇问题如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a + n(b + c) + b = a + (n + 1)b + nc。 设 fast 指针走过的距离都为 slow 指针的 x 倍，因此有 a + (n + 1)b + nc = x(a + b) ⟹ (b + c)n = (x − 1)(a + b)。即从相遇点到入环点的距离加上 n 圈的环长，恰好等于从链表头部到入环点的距离的 x - 1 倍。 若 x = 2，快指针步长为慢指针的 2 倍，(b + c)n = a + b 方程组有解。若 x = 3，快指针步长为慢指针的 3 倍，(b + c)n = 2(a + b) 方程组有解。 ","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:4:1","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#快慢指针的相遇问题"},{"categories":["LeetCode"],"content":" 4.2 循环圈的起始位置问题由 (b + c)n = (x - 1)(a + b) 方程可知从相遇点到入环点的距离是环长的倍数。因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始位置指向链表头部，随后它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。 ","date":"2022-05-01","objectID":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:4:2","series":[],"tags":["LeetCode"],"title":"力扣142. 环形链表","uri":"/blog/0142_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/#循环圈的起始位置问题"},{"categories":["life"],"content":" 1 酒的分类 🍶白酒按香型分类有十二种。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:0","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#酒的分类-"},{"categories":["life"],"content":" 1.1 浓香型浓香型白酒的执行标准：GB/T 10781-2006。 浓香型白酒：浓香型白酒以四川泸州老窖、五粮液位典型代表，也称为沪香型酒。 浓香型白酒的生产工艺采用泥土老窖为发酵窖，以高粱为主要原料。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:1","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#浓香型"},{"categories":["life"],"content":" 1.2 清香型清香型白酒的执行标准：GB/T 10781.2-2006. 清香型白酒：以山西汾酒为典型代表，也称为汾香型白酒。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:2","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#清香型"},{"categories":["life"],"content":" 1.3 米香型米香型白酒的执行标准：GB/T 10781.3-2006. 米香型白酒：也称为蜜香型酒，传统的米香型白酒以桂林三花为代表，属小曲酒类。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:3","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#米香型"},{"categories":["life"],"content":" 1.4 特香型特香型的执行标准：GB/T 20823-2007. 特香型白酒：以江西“四特酒”为代表。特香型酒口味柔和持久，甜味明显。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:4","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#特香型"},{"categories":["life"],"content":" 1.5 凤香型凤香型的执行标准：GB/T 14867-2007. 凤香型白酒：西凤酒是典型的凤香型白酒，产于陕西省。 西凤酒的特点是醇香优雅，甘润挺爽，诸味谐调，尾净悠长。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:5","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#凤香型"},{"categories":["life"],"content":" 1.6 鼓香型豉香型的执行标准：GB/T 16289-2007. 鼓香型白酒：广东珠江三角洲盛产玉冰烧，以广东佛山“玉冰烧酒”为代表。 它的官语评价是：“玉洁冰清，鼓香独特，醇厚甘润，余味爽净。” ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:6","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#鼓香型"},{"categories":["life"],"content":" 1.7 兼香型兼香型的执行标准：GB/T 23547-2009. 兼香型白酒：香气和口感兼具泸香型酒和茅香型酒的特点，所以称之为兼香型白酒，常又称为复合香型。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:7","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#兼香型"},{"categories":["life"],"content":" 1.8 酱香型酱香型的执行标准：GB/T 26760-2011. 酱香型白酒：以贵州茅台酒、四川郎酒为典型代表，也称为茅香型酒。 茅香就是由酱香、醇甜和窖底香三种混合而成的，所以香味成分比较复杂。 酱香酒的特点是微黄透明，具特殊芳香，酱香突出，优雅细腻，酒体醇厚，回味悠长。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:8","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#酱香型"},{"categories":["life"],"content":" 1.9 药香型药香型白酒：产于贵州遵义市的董酒，略带药香，所以称为药香型。 董酒具有“清澈透明、浓香带药香、香气典雅、酸味适中、香味谐调、尾净味长”的特点。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:9","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#药香型"},{"categories":["life"],"content":" 1.10 芝麻香型芝麻香型的执行标准：GB/T 20824-2007. 芝麻香型白酒：芝麻香型白酒一芝麻香型为主体。它的典型代表是山东的景芝白干和一品景芝系列。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:10","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#芝麻香型"},{"categories":["life"],"content":" 1.11 馥郁香型馥郁香型白酒：以湖南酒鬼酒为代表。 它的特点是芳香秀雅，绵柔甘洌，醇厚细腻，后味怡畅，香味馥郁，酒体净爽。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:11","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#馥郁香型"},{"categories":["life"],"content":" 1.12 老白干香型老白干香型的执行标准：GB/T 20825-2007. 老白干香型白酒：以河北衡水老白干酒为代表。 它的口感官方评语：无色或微黄透明，醇香清雅，酒体谐调，醇厚挺拔，回味悠长。 ","date":"2022-04-17","objectID":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/:1:12","series":[""],"tags":["life","Chinese Baijiu"],"title":"酒的分类","uri":"/blog/001_%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/#老白干香型"},{"categories":["life"],"content":" 1 什么是执行标准号产品执行标准是指反映质量特性的全方位产品标准，包括国家标准、行业标准、地方标准和企业标准。 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:1:0","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#什么是执行标准号"},{"categories":["life"],"content":" 1.1 执行标准号构成标准代号 标准顺序号 - 标准发布年号 其中，标准代号有国家标准 (GB)、行业标准、地方标准 (DB)、企业标准 (Q)、推荐 (T)。 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:1:1","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#执行标准号构成"},{"categories":["life"],"content":" 2 食品","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:2:0","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#食品"},{"categories":["life"],"content":" 2.1 大米 🍚 黑龙江五常大米，执行标准：GB/T 19266 河南原阳黄金晴，执行标准：GB/T 22438 辽宁方正富硒大米，执行标准：GB/T 20040 黑龙江盘锦大米，执行标准：GB/T 18824 松江大米，执行标准：DB31/T 908 黑龙江好粮油稻花香大米，执行标准：T/HLHX 002 黑龙江好粮油大米，执行标准：T/HLHX 001 定安富硒大米，执行标准：DB46/T 239 普通大米，执行标准：GB/T 1354 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:2:1","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#大米-"},{"categories":["life"],"content":" 2.2 面粉 🍜 高筋面粉，执行标准：GB/T 8607 中筋面粉，执行标准：GB/T 1355 低筋面粉，执行标准：GB/T 8608 专用小麦面粉，执行标准：LS/T 3201-3208 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:2:2","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#面粉-"},{"categories":["life"],"content":" 2.3 油 葵花籽油，执行标准：GB 10464 玉米油，执行标准：GB/T 19111 纯菜籽油，执行标准：GB 1536 纯花生油，执行标准：GB/T 1534 调合食用油，执行标准：GB 2716 大豆油，执行标准：GB 1535 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:2:3","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#油"},{"categories":["life"],"content":" 2.4 醋 酿造醋，执行标准：GB 18187 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:2:4","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#醋"},{"categories":["life"],"content":" 2.5 盐 🧂 盐，执行标准：GB 2721-2015 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:2:5","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#盐-"},{"categories":["life"],"content":" 2.6 酱油 酿造酱油，执行标准：GB 18186-2000 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:2:6","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#酱油"},{"categories":["life"],"content":" 2.7 食糖 🍬 食糖，执行标准：GB 13104-2014 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:2:7","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#食糖-"},{"categories":["life"],"content":" 2.8 豆瓣酱 豆瓣酱，执行标准：GB/T 20560-2006 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:2:8","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#豆瓣酱"},{"categories":["life"],"content":" 3 婴幼儿 👶","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:3:0","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#婴幼儿-"},{"categories":["life"],"content":" 3.1 奶粉 🥛 婴儿配方食品，执行标准：GB 10765-2010 较大婴儿和幼儿配方食品，执行标准：GB 10767-2010 婴幼儿谷类辅助食品，执行标准：GB 10769-2010 婴幼儿罐装辅助食品，执行标准：GB 10770-2010 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:3:1","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#奶粉-"},{"categories":["life"],"content":" 4 医疗","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:4:0","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#医疗"},{"categories":["life"],"content":" 4.1 口罩 😷 医用防护口罩，执行标准：GB 19083—2010 医用外科口罩，执行标准：YY 0469—2011 一次性医用口罩，执行标准：YY/T 0969—2013 ","date":"2022-04-15","objectID":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/:4:1","series":[""],"tags":["life"],"title":"日常购物选择","uri":"/blog/001_%E6%97%A5%E5%B8%B8%E8%B4%AD%E7%89%A9%E9%80%89%E6%8B%A9/#口罩-"},{"categories":["Android"],"content":" 1 设备没有权限执行 adb devices 命令输出 List of devices attached 3ed62e70 no permissions ","date":"2022-03-24","objectID":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/:1:0","series":[],"tags":["Android","adb"],"title":"adb 设备无法识别","uri":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/#设备没有权限"},{"categories":["Android"],"content":" 2 查看 USB 设备执行 lsusb 命令输出 Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 094: ID 17ef:6050 Lenovo Bus 001 Device 124: ID 05c6:901d Qualcomm, Inc. -\u003e 新增 usb 设备 Bus 001 Device 002: ID 060b:7a03 Solid Year Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub ","date":"2022-03-24","objectID":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/:2:0","series":[],"tags":["Android","adb"],"title":"adb 设备无法识别","uri":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/#查看-usb-设备"},{"categories":["Android"],"content":" 3 配置 USB 设备权限修改 /etc/udev/rules.d/android.rules 文件内容 SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"05c6\", ATTRS{idProduct}==\"901d\", MODE=\"0666\" ","date":"2022-03-24","objectID":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/:3:0","series":[],"tags":["Android","adb"],"title":"adb 设备无法识别","uri":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/#配置-usb-设备权限"},{"categories":["Android"],"content":" 4 使配置生效执行 sudo service udev restart 命令 ","date":"2022-03-24","objectID":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/:4:0","series":[],"tags":["Android","adb"],"title":"adb 设备无法识别","uri":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/#使配置生效"},{"categories":["Android"],"content":" 1 adb 命令安装 查看当前设备已安装包名 adb shell pm list packages 安装 APK adb install -r app-debug.apk 卸载 APK adb uninstall com.test.demo ","date":"2022-03-24","objectID":"/blog/002_android%E5%AE%89%E8%A3%85apk/:1:0","series":[],"tags":["Android","adb","apk"],"title":"Android 安装 APK","uri":"/blog/002_android%E5%AE%89%E8%A3%85apk/#adb-命令安装"},{"categories":["Android"],"content":" 2 pm 命令安装先用 adb 命令将安装包推到机器中 查看当前设备已安装包名 pm list packages 安装 APK pm install -r app-debug.apk 卸载 APK pm uninstall com.test.demo ","date":"2022-03-24","objectID":"/blog/002_android%E5%AE%89%E8%A3%85apk/:2:0","series":[],"tags":["Android","adb","apk"],"title":"Android 安装 APK","uri":"/blog/002_android%E5%AE%89%E8%A3%85apk/#pm-命令安装"},{"categories":["Android"],"content":" 1 Android 打包 aar 运行编译命令 ./gradlew build ","date":"2022-03-24","objectID":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/:1:0","series":[],"tags":["Android","aar","Gradle"],"title":"Android 打包 aar 并集成","uri":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/#android-打包-aar"},{"categories":["Android"],"content":" 2 Gradle 本地集成 aar 将生成的 aar 放到 app/libs 目录下 修改 app/build.gradle 文件 android { ... repositories { flatDir { dirs 'libs' } } } dependencies { ... implementation(name:'aar_name', ext:'aar') } 重新编译 app ","date":"2022-03-24","objectID":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/:2:0","series":[],"tags":["Android","aar","Gradle"],"title":"Android 打包 aar 并集成","uri":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/#gradle-本地集成-aar"},{"categories":["Android"],"content":" 3 Gradle 迁移 Maven 构建 修改 app/build.gradle 文件 android { ... repositories { maven { url 'https://nexus2.com/repository/maven/' } } } dependencies { ... implementation 'com.demo:demolib:1.0.0-20220211.010237-47@aar' } 重新编译 app ","date":"2022-03-24","objectID":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/:3:0","series":[],"tags":["Android","aar","Gradle"],"title":"Android 打包 aar 并集成","uri":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/#gradle-迁移-maven-构建"},{"categories":["dev-tools"],"content":" 1 简单介绍 Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS、Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:0","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#简单介绍"},{"categories":["dev-tools"],"content":" 2 基本语法 Workspace：工作区 Index/Stage：暂存区 Repository：本地仓库 Remote：远程仓库 ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:0","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#基本语法"},{"categories":["dev-tools"],"content":" 2.1 新建仓库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:1","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#新建仓库"},{"categories":["dev-tools"],"content":" 2.2 配置Git 有三种级别类型的配置文件，名字为 .gitconfig。 系统级：/etc/gitconfig，使用 --system 选项进行读写 用户级：~/.gitconfig，使用 --global 选项进行读写 仓库级：仓库目录/.git/config，使用 --local 选项进行读写 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:2","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#配置"},{"categories":["dev-tools"],"content":" 2.3 增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:3","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#增加删除文件"},{"categories":["dev-tools"],"content":" 2.4 代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:4","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#代码提交"},{"categories":["dev-tools"],"content":" 2.5 分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:5","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#分支"},{"categories":["dev-tools"],"content":" 2.6 标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:6","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#标签"},{"categories":["dev-tools"],"content":" 2.7 查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:7","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#查看信息"},{"categories":["dev-tools"],"content":" 2.8 统计代码量 # 总变更代码量 $ git log --pretty=tformat: --numstat | awk '{ add += $1; subs += $2 } END { printf \"added lines: %s, removed lines: %s\\n\", add, subs }' # 指定时间段代码修改量 $ git log --since=2022-01-01 --until=2022-12-31 --pretty=tformat: --numstat | awk '{ add += $1; subs += $2 } END { printf \"added lines: %s, removed lines: %s\\n\", add, subs }' # 指定开发者代码变更量 $ git log --author=\"root\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2 } END { printf \"added lines: %s, removed lines: %s\\n\", add, subs }' ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:8","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#统计代码量"},{"categories":["dev-tools"],"content":" 2.9 远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:9","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#远程同步"},{"categories":["dev-tools"],"content":" 2.10 撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:10","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#撤销"},{"categories":["dev-tools"],"content":" 2.11 其他 # 生成一个可供发布的压缩包 $ git archive ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:11","series":[],"tags":["dev-tools","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#其他"},{"categories":["dev-tools"],"content":" 1 Ubuntu 安装 git 命令 apt-get install git ","date":"2022-03-24","objectID":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":[],"tags":["dev-tools","git"],"title":"git 使用和配置","uri":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ubuntu-安装-git-命令"},{"categories":["dev-tools"],"content":" 2 git 配置文件git 配置文件有三个： /etc/gitconfig 是系统级配置文件，使用 git config --system 命令进行修改。 ~/.gitconfig 或 ~/.config/git/config 是用户级配置文件，使用 git config --global 命令进行修改。 local_dir/.git/config 是仓库级配置文件，使用 git config --local 命令进行修改。 ","date":"2022-03-24","objectID":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":[],"tags":["dev-tools","git"],"title":"git 使用和配置","uri":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#git-配置文件"},{"categories":["dev-tools"],"content":" 2.1 设置用户信息 $ git config --global user.name \"username\" $ git config --global user.email username@example.com ","date":"2022-03-24","objectID":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:1","series":[],"tags":["dev-tools","git"],"title":"git 使用和配置","uri":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#设置用户信息"},{"categories":["dev-tools"],"content":" 2.2 设置 git 默认编辑器 git config --global core.editor emacs ","date":"2022-03-24","objectID":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:2","series":[],"tags":["dev-tools","git"],"title":"git 使用和配置","uri":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#设置-git-默认编辑器"},{"categories":["Android"],"content":" 1 显示的错误信息 javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 导致这个错误的原因是没有有效的证书，因此导入相应的证书就可以正常访问了。 证书可以通过网站 -\u003e Certificate -\u003e Details -\u003e Export 获取。 ","date":"2022-03-24","objectID":"/blog/004_jdk%E5%AF%BC%E5%85%A5ca%E8%AF%81%E4%B9%A6/:1:0","series":[],"tags":["Android","jdk","CA"],"title":"JDK 导入 CA 证书","uri":"/blog/004_jdk%E5%AF%BC%E5%85%A5ca%E8%AF%81%E4%B9%A6/#显示的错误信息"},{"categories":["Android"],"content":" 2 证书管理 导入证书 keytool -import -keystore ~/Opt/jdk1.8.0_181/jre/lib/security/cacerts -alias ca -storepass changeit -keypass changeit -file ~/Downloads/ca.crt 删除证书 keytool -delete -keystore ~/Opt/jdk1.8.0_181/jre/lib/security/cacerts -alias ca -storepass changeit 查看证书 keytool -list -keystore ~/Opt/jdk1.8.0_181/jre/lib/security/cacerts -alias ca ","date":"2022-03-24","objectID":"/blog/004_jdk%E5%AF%BC%E5%85%A5ca%E8%AF%81%E4%B9%A6/:2:0","series":[],"tags":["Android","jdk","CA"],"title":"JDK 导入 CA 证书","uri":"/blog/004_jdk%E5%AF%BC%E5%85%A5ca%E8%AF%81%E4%B9%A6/#证书管理"},{"categories":["dev-tools"],"content":" 1 Ubuntu 安装 ssh 命令 sudo apt-get install openssh-server ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ubuntu-安装-ssh-命令"},{"categories":["dev-tools"],"content":" 2 ssh 使用和配置","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-使用和配置"},{"categories":["dev-tools"],"content":" 2.1 ssh 配置 生成 ssh 密钥和公钥 ssh-keygen -t rsa 其中在 ~/.ssh 文件夹下，id_rsa 是私钥，id_rsa.pub 是公钥。 将公钥放在服务器上 测试 ssh 连接 ssh -p port user@hostname 连接成功会出现 Welcome to Gerrit Code Review 字样！ ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:1","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-配置"},{"categories":["dev-tools"],"content":" 2.2 ssh 和 sshd/etc/ssh/ssh_config 和 /etc/ssh/sshd_config 都是 ssh 的配置文件，区别在于 ssh_config 是客户端的配置文件，sshd_config 是服务端的配置文件。 /etc/ssh/sshd_config 部分文件内容 Port 22 # 默认端口号为 22 PermitRootLogin no # 禁止 root 用户登录 X11Forwarding yes # 允许 X11 图形化 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:2","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-和-sshd"},{"categories":["dev-tools"],"content":" 2.3 ssh 服务端控制命令 service sshd start # 启动 sshd service sshd stop # 停止 sshd service sshd restart # 重启 sshd ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:3","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-服务端控制命令"},{"categories":["dev-tools"],"content":" 2.4 ssh config 配置文件修改 ~/.ssh/config 文件设置别名 Host Alias HostName ip[192.168.XXX.XXX] Port 22 User zhengqijun IdentityFile ~/.ssh/id_rsa 直接输入 ssh Alias 命令就可以直接连接了！十分方便！ ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:4","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-config-配置文件"},{"categories":["dev-tools"],"content":" 2.5 ssh 免密登录将 ssh 生成的公钥拷贝到目标机的 ~/.ssh/authorized_keys 中，就可以实现免密登录了。ssh 连接连密码都省了，偷懒小能手！ ssh-copy-id user@hostname ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:5","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-免密登录"},{"categories":["dev-tools"],"content":" 3 传输文件","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:3:0","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#传输文件"},{"categories":["dev-tools"],"content":" 3.1 scp 传输文件scp 是基于 ssh 登陆进行安全的远程文件拷贝命令，所以可以通过网络传输文件。 scp local_file remote_username@remote_ip:remote_folder # 传输本地文件到目标机 scp -r local_folder remote_username@remote_ip:remote_folder # 传输本地目录到目标机 scp remote_username@remote_ip:remote_folder local_file # 传输本地文件到目标机 scp -r remote_username@remote_ip:remote_folder local_folder # 传输本地目录到目标机 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:3:1","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#scp-传输文件"},{"categories":["dev-tools"],"content":" 4 跳板机","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:4:0","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#跳板机"},{"categories":["dev-tools"],"content":" 4.1 ssh 通过跳板机直连原本访问不到的机器~/.ssh/config 中配置如下： Host gateway HostName 192.168.168.52 User gateway Host chej HostName 192.168.211.100 Port 22 User root ProxyJump gateway 通过命令直接登录，无需先到跳板机 gateway 。 ssh chej ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:4:1","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-通过跳板机直连原本访问不到的机器"},{"categories":["dev-tools"],"content":" 5 ssh 图形化连接","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:0","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-图形化连接"},{"categories":["dev-tools"],"content":" 5.1 X11 是什么Linux 本身是没有图形化界面的，所谓的图形化界面系统只不过中 Linux 下的应用程序。这一点和 Windows 不一样。Windows 从 Windows 95 开始，图形界面就直接在系统内核中实现了，是操作系统不可或缺的一部分。Linux 的图形化界面，底层都是基于 X 协议。 X11 是 X 协议的某个版本,，应用程序通过 X 协议告诉服务器端需要显示什么图形，然后服务器端通过 X server 来显示。 但是在远程连接时，服务器是本地的机器，客户端是远程服务器上的程序。因为我们是想要在本地显示远程服务器上的应用结果。 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:1","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#x11-是什么"},{"categories":["dev-tools"],"content":" 5.2 Mac 下的 X11通过安装 XQuartz，Mac 就可以做一个 X11 server，这样在 Mac 上就能显示远程服务器的应用程序。当 XQuartz 在运行时，会显示图标。 通过 xclock 命令测试，如果一切顺利，应该在 Mac 上会弹出界面。 xclock ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:2","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#mac-下的-x11"},{"categories":["dev-tools"],"content":" 5.3 VSCode 下的 Remote X11能够做到远程执行命令显示图形界面并调试，还是很诱人的。 这个插件就可以在 vscode 终端中使用 X11 forwarding 了。 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:3","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#vscode-下的-remote-x11"},{"categories":["dev-tools"],"content":" 5.4 Windows 下的 X11Windows 下有一个终端 MobaXterm，自带 X server。 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:4","series":[],"tags":["dev-tools","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#windows-下的-x11"},{"categories":["Ubuntu"],"content":" 1 创建新用户账户 sudo useradd -s /bin/bash -m -G sudo test -s /bin/bash: 将 /bin/bash 设置为新账户的登录 shell -m: 创建用户的主目录 -G sudo: 确保用户可以使用 sudo ","date":"2022-03-24","objectID":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/:1:0","series":[],"tags":["Ubuntu"],"title":"Ubuntu 创建新用户账户","uri":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/#创建新用户账户"},{"categories":["Ubuntu"],"content":" 2 设置新用户账户密码 sudo passwd test ","date":"2022-03-24","objectID":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/:2:0","series":[],"tags":["Ubuntu"],"title":"Ubuntu 创建新用户账户","uri":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/#设置新用户账户密码"},{"categories":["Ubuntu"],"content":" 3 删除用户账户 userdel -r test -r: 删除用户主目录 ","date":"2022-03-24","objectID":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/:3:0","series":[],"tags":["Ubuntu"],"title":"Ubuntu 创建新用户账户","uri":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/#删除用户账户"},{"categories":["programming"],"content":" 1 Docker 容器使用","date":"2022-03-09","objectID":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:1:0","series":[],"tags":["programming","Docker"],"title":"Docker 基本使用","uri":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#docker-容器使用"},{"categories":["programming"],"content":" 2 Docker 镜像使用 镜像列表 获取镜像列表命令如下所示： docker images ","date":"2022-03-09","objectID":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:2:0","series":[],"tags":["programming","Docker"],"title":"Docker 基本使用","uri":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#docker-镜像使用"},{"categories":["programming"],"content":" 3 Docker 容器连接","date":"2022-03-09","objectID":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:3:0","series":[],"tags":["programming","Docker"],"title":"Docker 基本使用","uri":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#docker-容器连接"},{"categories":["programming"],"content":" 4 Docker 仓库管理 登录和退出 从某些私有仓库拉取 Docker 镜像，可能需要进行登录。 登录命令如下： docker login url 登陆成功后，密码会被加密保存在 ~/.docker/config.json 文件中。 退出命令如下： docker logout 拉取镜像 docker pull image_name:tag 如果没有指定 tag，默认为 latest。 推送镜像 docker push username/image_name:tag ","date":"2022-03-09","objectID":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:4:0","series":[],"tags":["programming","Docker"],"title":"Docker 基本使用","uri":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#docker-仓库管理"},{"categories":["Ubuntu"],"content":"\u003c200d\u003e ","date":"2022-03-09","objectID":"/blog/001_zero_width_joiners/:0:0","series":[],"tags":["Ubuntu"],"title":"zero-width-joiners","uri":"/blog/001_zero_width_joiners/#"},{"categories":["dev-tools"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2021-03-24","objectID":"/blog/004_emoji/:0:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#"},{"categories":["dev-tools"],"content":" 1 表情与情感","date":"2021-03-24","objectID":"/blog/004_emoji/:1:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#表情与情感"},{"categories":["dev-tools"],"content":" 1.1 笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:1","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#笑脸表情"},{"categories":["dev-tools"],"content":" 1.2 爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:2","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#爱意表情"},{"categories":["dev-tools"],"content":" 1.3 吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:3","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#吐舌头表情"},{"categories":["dev-tools"],"content":" 1.4 带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:4","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#带手的表情"},{"categories":["dev-tools"],"content":" 1.5 中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:5","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#中性表情"},{"categories":["dev-tools"],"content":" 1.6 困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:6","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#困倦的表情"},{"categories":["dev-tools"],"content":" 1.7 不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:7","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#不适的表情"},{"categories":["dev-tools"],"content":" 1.8 戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:8","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#戴帽子的表情"},{"categories":["dev-tools"],"content":" 1.9 戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:9","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#戴眼镜的表情"},{"categories":["dev-tools"],"content":" 1.10 担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:10","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#担心的表情"},{"categories":["dev-tools"],"content":" 1.11 否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:11","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#否定的表情"},{"categories":["dev-tools"],"content":" 1.12 特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:12","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#特殊打扮的表情"},{"categories":["dev-tools"],"content":" 1.13 猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:13","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#猫脸表情"},{"categories":["dev-tools"],"content":" 1.14 猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:14","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#猴脸表情"},{"categories":["dev-tools"],"content":" 1.15 情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:15","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#情感"},{"categories":["dev-tools"],"content":" 2 人与身体","date":"2021-03-24","objectID":"/blog/004_emoji/:2:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人与身体"},{"categories":["dev-tools"],"content":" 2.1 张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:1","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#张开手掌的手势"},{"categories":["dev-tools"],"content":" 2.2 部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:2","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#部分手指的手势"},{"categories":["dev-tools"],"content":" 2.3 一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:3","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#一根手指的手势"},{"categories":["dev-tools"],"content":" 2.4 握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:4","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#握紧的手势"},{"categories":["dev-tools"],"content":" 2.5 两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:5","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#两只手"},{"categories":["dev-tools"],"content":" 2.6 握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:6","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#握住东西的手势"},{"categories":["dev-tools"],"content":" 2.7 身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:7","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#身体部位"},{"categories":["dev-tools"],"content":" 2.8 人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:8","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人"},{"categories":["dev-tools"],"content":" 2.9 身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇 bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:9","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#身体动作"},{"categories":["dev-tools"],"content":" 2.10 人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:10","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人物角色"},{"categories":["dev-tools"],"content":" 2.11 幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:11","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#幻想的人物"},{"categories":["dev-tools"],"content":" 2.12 人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:12","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人物活动"},{"categories":["dev-tools"],"content":" 2.13 体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:13","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#体育"},{"categories":["dev-tools"],"content":" 2.14 休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:14","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#休息"},{"categories":["dev-tools"],"content":" 2.15 家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:15","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#家庭"},{"categories":["dev-tools"],"content":" 2.16 人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:16","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人物符号"},{"categories":["dev-tools"],"content":" 3 动物与自然","date":"2021-03-24","objectID":"/blog/004_emoji/:3:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#动物与自然"},{"categories":["dev-tools"],"content":" 3.1 哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:1","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#哺乳动物"},{"categories":["dev-tools"],"content":" 3.2 鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:2","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#鸟类"},{"categories":["dev-tools"],"content":" 3.3 两栖动物 icon code icon code 🐸 frog ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:3","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#两栖动物"},{"categories":["dev-tools"],"content":" 3.4 爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:4","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#爬虫类"},{"categories":["dev-tools"],"content":" 3.5 海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:5","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#海洋动物"},{"categories":["dev-tools"],"content":" 3.6 虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:6","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#虫类"},{"categories":["dev-tools"],"content":" 3.7 花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:7","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#花类植物"},{"categories":["dev-tools"],"content":" 3.8 其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:8","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#其它植物"},{"categories":["dev-tools"],"content":" 4 食物与饮料","date":"2021-03-24","objectID":"/blog/004_emoji/:4:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#食物与饮料"},{"categories":["dev-tools"],"content":" 4.1 水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:1","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#水果"},{"categories":["dev-tools"],"content":" 4.2 蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:2","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#蔬菜"},{"categories":["dev-tools"],"content":" 4.3 快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:3","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#快餐"},{"categories":["dev-tools"],"content":" 4.4 亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:4","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#亚洲食物"},{"categories":["dev-tools"],"content":" 4.5 海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:5","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#海鲜"},{"categories":["dev-tools"],"content":" 4.6 甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:6","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#甜点"},{"categories":["dev-tools"],"content":" 4.7 饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:7","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#饮料"},{"categories":["dev-tools"],"content":" 4.8 餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:8","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#餐具"},{"categories":["dev-tools"],"content":" 5 旅游与地理","date":"2021-03-24","objectID":"/blog/004_emoji/:5:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#旅游与地理"},{"categories":["dev-tools"],"content":" 5.1 地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:1","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#地图"},{"categories":["dev-tools"],"content":" 5.2 地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:2","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#地理现象"},{"categories":["dev-tools"],"content":" 5.3 建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:3","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#建筑物"},{"categories":["dev-tools"],"content":" 5.4 宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:4","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#宗教建筑"},{"categories":["dev-tools"],"content":" 5.5 其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:5","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#其它地点"},{"categories":["dev-tools"],"content":" 5.6 陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:6","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#陆路运输"},{"categories":["dev-tools"],"content":" 5.7 水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:7","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#水路运输"},{"categories":["dev-tools"],"content":" 5.8 空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:8","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#空中运输"},{"categories":["dev-tools"],"content":" 5.9 旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:9","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#旅馆"},{"categories":["dev-tools"],"content":" 5.10 时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:10","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#时间"},{"categories":["dev-tools"],"content":" 5.11 天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:11","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#天空与天气"},{"categories":["dev-tools"],"content":" 6 活动","date":"2021-03-24","objectID":"/blog/004_emoji/:6:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#活动"},{"categories":["dev-tools"],"content":" 6.1 事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:1","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#事件"},{"categories":["dev-tools"],"content":" 6.2 奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:2","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#奖杯与奖牌"},{"categories":["dev-tools"],"content":" 6.3 体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:3","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#体育运动"},{"categories":["dev-tools"],"content":" 6.4 游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:4","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#游戏"},{"categories":["dev-tools"],"content":" 6.5 艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:5","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#艺术与工艺"},{"categories":["dev-tools"],"content":" 7 物品","date":"2021-03-24","objectID":"/blog/004_emoji/:7:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#物品"},{"categories":["dev-tools"],"content":" 7.1 服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:1","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#服装"},{"categories":["dev-tools"],"content":" 7.2 声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:2","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#声音"},{"categories":["dev-tools"],"content":" 7.3 音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:3","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#音乐"},{"categories":["dev-tools"],"content":" 7.4 乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:4","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#乐器"},{"categories":["dev-tools"],"content":" 7.5 电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:5","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#电话"},{"categories":["dev-tools"],"content":" 7.6 电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:6","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#电脑"},{"categories":["dev-tools"],"content":" 7.7 灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:7","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#灯光与影像"},{"categories":["dev-tools"],"content":" 7.8 书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:8","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#书与纸张"},{"categories":["dev-tools"],"content":" 7.9 钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:9","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#钱"},{"categories":["dev-tools"],"content":" 7.10 邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:10","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#邮件"},{"categories":["dev-tools"],"content":" 7.11 书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:11","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#书写"},{"categories":["dev-tools"],"content":" 7.12 办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:12","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#办公"},{"categories":["dev-tools"],"content":" 7.13 锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:13","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#锁"},{"categories":["dev-tools"],"content":" 7.14 工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:14","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#工具"},{"categories":["dev-tools"],"content":" 7.15 科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:15","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#科学"},{"categories":["dev-tools"],"content":" 7.16 医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:16","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#医疗"},{"categories":["dev-tools"],"content":" 7.17 生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:17","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#生活用品"},{"categories":["dev-tools"],"content":" 7.18 其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:18","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#其它物品"},{"categories":["dev-tools"],"content":" 8 符号","date":"2021-03-24","objectID":"/blog/004_emoji/:8:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#符号"},{"categories":["dev-tools"],"content":" 8.1 交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:1","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#交通标识"},{"categories":["dev-tools"],"content":" 8.2 警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:2","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#警告"},{"categories":["dev-tools"],"content":" 8.3 箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:3","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#箭头"},{"categories":["dev-tools"],"content":" 8.4 宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:4","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#宗教"},{"categories":["dev-tools"],"content":" 8.5 生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:5","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#生肖"},{"categories":["dev-tools"],"content":" 8.6 影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:6","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#影像符号"},{"categories":["dev-tools"],"content":" 8.7 数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:7","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#数学"},{"categories":["dev-tools"],"content":" 8.8 标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:8","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#标点符号"},{"categories":["dev-tools"],"content":" 8.9 货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:9","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#货币"},{"categories":["dev-tools"],"content":" 8.10 按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:10","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#按键符号"},{"categories":["dev-tools"],"content":" 8.11 字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:11","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#字母符号"},{"categories":["dev-tools"],"content":" 8.12 几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:12","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#几何符号"},{"categories":["dev-tools"],"content":" 8.13 其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:13","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#其它符合"},{"categories":["dev-tools"],"content":" 9 旗帜","date":"2021-03-24","objectID":"/blog/004_emoji/:9:0","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#旗帜"},{"categories":["dev-tools"],"content":" 9.1 常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2021-03-24","objectID":"/blog/004_emoji/:9:1","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#常用旗帜"},{"categories":["dev-tools"],"content":" 9.2 国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2021-03-24","objectID":"/blog/004_emoji/:9:2","series":[],"tags":["dev-tools","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#国家和地区旗帜"},{"categories":["961"],"content":" 1 一、软件过程","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:0","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#一软件过程"},{"categories":["961"],"content":" 1.1 软件过程的概念软件过程是指工作产品构建时所执行的一系列活动、动作和任务的集合． 软件过程是指软件整个生命周期，从需求获取、需求分析、设计、实现、测试、发布和维护一个过程模型． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:1","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件过程的概念"},{"categories":["961"],"content":" 1.2 经典软件过程模型的特点 1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#经典软件过程模型的特点"},{"categories":["961"],"content":" 1.2 经典软件过程模型的特点 1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#瀑布模型"},{"categories":["961"],"content":" 1.2 经典软件过程模型的特点 1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#增量模型"},{"categories":["961"],"content":" 1.2 经典软件过程模型的特点 1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#演化模型"},{"categories":["961"],"content":" 1.2 经典软件过程模型的特点 1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#统一过程模型"},{"categories":["961"],"content":" 1.3 过程评估与CMM/CMMI的基本概念CMM（Capability Maturity Model）即能力成熟度模型，用于评价软件机构的软件过程能力成熟度的模型． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#过程评估与cmmcmmi的基本概念"},{"categories":["961"],"content":" 1.4 敏捷宣言与敏捷过程的特点敏捷宣言 个体和交互胜过过程和工具 可工作软件胜过宽泛的文档 客户合作胜过合同谈判 响应变化胜过遵循计划 右边的各项很有价值，但左边的价值更大 敏捷过程 敏捷开发的过程有着更强的适应性而不是预设性 敏捷开发的过程中，更加的注重人的因素 在敏捷开发的过程中，整个项目是测试驱动的而不是文档驱动的 ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:4","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#敏捷宣言与敏捷过程的特点"},{"categories":["961"],"content":" 2 二、软件需求","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:0","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#二软件需求"},{"categories":["961"],"content":" 2.1 软件需求的概念需求分析是研究用户要求，以得到目标系统的需求定义的过程． 需求分析的基本任务是软件开发人员和用户一起完全弄清用户对系统的确切要求． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:1","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件需求的概念"},{"categories":["961"],"content":" 2.2 需求工程的基本过程软件需求工程细分为：需求获取、需求分析与协商、系统建模、需求规约、需求验证和需求管理六个阶段． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:2","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#需求工程的基本过程"},{"categories":["961"],"content":" 2.3 分层数据流模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#分层数据流模型"},{"categories":["961"],"content":" 2.4 用例和场景建模及其UML表达 2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图 2.4.3 泳道图 2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#用例和场景建模及其uml表达"},{"categories":["961"],"content":" 2.4 用例和场景建模及其UML表达 2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图 2.4.3 泳道图 2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#用例图"},{"categories":["961"],"content":" 2.4 用例和场景建模及其UML表达 2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图 2.4.3 泳道图 2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#活动图"},{"categories":["961"],"content":" 2.4 用例和场景建模及其UML表达 2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图 2.4.3 泳道图 2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#泳道图"},{"categories":["961"],"content":" 2.4 用例和场景建模及其UML表达 2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图 2.4.3 泳道图 2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#顺序图"},{"categories":["961"],"content":" 2.5 数据模型建模及其UML表达 2.5.1 类图类图展示系统中类的静态结构，即类与类之间的相互联系． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:5","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#数据模型建模及其uml表达"},{"categories":["961"],"content":" 2.5 数据模型建模及其UML表达 2.5.1 类图类图展示系统中类的静态结构，即类与类之间的相互联系． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:5","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#类图"},{"categories":["961"],"content":" 2.6 行为模型建模及其UML表达 2.6.1 状态图状态图通常是对类描述的补充，它说明该类的对象所有可能的状态以及哪些事件将导致状态的变化． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:6","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#行为模型建模及其uml表达"},{"categories":["961"],"content":" 2.6 行为模型建模及其UML表达 2.6.1 状态图状态图通常是对类描述的补充，它说明该类的对象所有可能的状态以及哪些事件将导致状态的变化． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:6","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#状态图"},{"categories":["961"],"content":" 3 三、软件设计与构造","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:0","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#三软件设计与构造"},{"categories":["961"],"content":" 3.1 软件体系结构及体系结构风格的概念程序或计算机系统的软件体系结构是指系统的一个或者多个结构，它包括软件构件、构件的外部可见属性以及它们之间的相互关系． 体系结构风格就是施加在整个系统上的一种变换，目的是为系统的所有构件建立一个结构． 体系结构风格的简单分类 以数据为中心的体系结构 数据流体系结构 调用和返回体系结构 面向对象体系结构 层次体系结构 ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:1","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件体系结构及体系结构风格的概念"},{"categories":["961"],"content":" 3.2 设计模式的概念设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结．使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:2","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#设计模式的概念"},{"categories":["961"],"content":" 3.3 模块化设计的基本思想及概念 3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#模块化设计的基本思想及概念"},{"categories":["961"],"content":" 3.3 模块化设计的基本思想及概念 3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#抽象"},{"categories":["961"],"content":" 3.3 模块化设计的基本思想及概念 3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#分解"},{"categories":["961"],"content":" 3.3 模块化设计的基本思想及概念 3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#模块化"},{"categories":["961"],"content":" 3.3 模块化设计的基本思想及概念 3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#封装"},{"categories":["961"],"content":" 3.3 模块化设计的基本思想及概念 3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#信息隐藏"},{"categories":["961"],"content":" 3.3 模块化设计的基本思想及概念 3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#功能独立"},{"categories":["961"],"content":" 3.4 软件重构的概念软件重构是指在不改变软件的功能和外部可见性的情况下，为了改善软件的结构，提高软件的清晰性、可扩展性和可重用性而对其进行的改造． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:4","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件重构的概念"},{"categories":["961"],"content":" 3.5 软件体系结构的UML建模 3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件体系结构的uml建模"},{"categories":["961"],"content":" 3.5 软件体系结构的UML建模 3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#包图"},{"categories":["961"],"content":" 3.5 软件体系结构的UML建模 3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#类图-1"},{"categories":["961"],"content":" 3.5 软件体系结构的UML建模 3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#构件图"},{"categories":["961"],"content":" 3.5 软件体系结构的UML建模 3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#顺序图-1"},{"categories":["961"],"content":" 3.5 软件体系结构的UML建模 3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#部署图"},{"categories":["961"],"content":" 3.6 接口的概念接口提供关于通信和协作的重要信息，然而接口表示的随意性会使构件图趋于复杂化． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:6","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#接口的概念"},{"categories":["961"],"content":" 3.7 面向对象设计原则 3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#面向对象设计原则"},{"categories":["961"],"content":" 3.7 面向对象设计原则 3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#单一职责原则"},{"categories":["961"],"content":" 3.7 面向对象设计原则 3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#开闭原则"},{"categories":["961"],"content":" 3.7 面向对象设计原则 3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#liskov替换原则"},{"categories":["961"],"content":" 3.7 面向对象设计原则 3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#依赖转置原则"},{"categories":["961"],"content":" 3.7 面向对象设计原则 3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#接口隔离原则"},{"categories":["961"],"content":" 3.8 内聚与耦合的概念内聚是模块相对功能性的度量，即一个模块内部各个元素彼此结合的紧密程度的度量． 耦合是模块间相对独立性的度量，即模块间相互连接的紧密程度的度量． 模块独立性比较强的模块应是高内聚低耦合的模块． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:8","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#内聚与耦合的概念"},{"categories":["961"],"content":" 3.9 常见的内聚和耦合类型内聚类型 偶然内聚 逻辑内聚 时间内聚 过程内聚 通信内聚 顺序内聚 功能内聚 耦合类型 数据耦合 控制耦合 特征耦合 公共环境耦合 内容耦合 ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:9","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#常见的内聚和耦合类型"},{"categories":["961"],"content":" 4 四、软件测试","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:0","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#四软件测试"},{"categories":["961"],"content":" 4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件测试及测试用例的概念"},{"categories":["961"],"content":" 4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#单元测试"},{"categories":["961"],"content":" 4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#集成测试"},{"categories":["961"],"content":" 4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#确认测试"},{"categories":["961"],"content":" 4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#系统测试"},{"categories":["961"],"content":" 4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#回归测试"},{"categories":["961"],"content":" 4.2 调试的概念调试不是测试，但总是发生在测试之后．当测试用例发现错误时，调试是使错误消除的过程． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:2","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#调试的概念"},{"categories":["961"],"content":" 4.3 调试与测试的关系测试主要是发现错误，调试则是确定错误的原因和准确位置，并加以纠正． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:3","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#调试与测试的关系"},{"categories":["961"],"content":" 4.4 测试覆盖度的概念","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:4","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#测试覆盖度的概念"},{"categories":["961"],"content":" 4.5 白盒测试、黑盒测试的概念白盒测试是把测试对象看作一个透明的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，检查程序中的所有逻辑路径是否都按预定的要求正确的工作． 黑盒测试是把测试对象看作一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:5","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#白盒测试黑盒测试的概念"},{"categories":["961"],"content":" 4.6 代码圈复杂度的计算方法圈复杂度是一种软件度量，它为程序的逻辑复杂度提供了一个量化的测度．在基本路径测试方法的环境下，圈复杂度的值定义了程序基本集合中的独立路径数，并提供了保证所有语句至少执行一次所需要测试数量的上限． 圈复杂度以图论为基础，计算方法如下 流图中域的数量与圈复杂度相对应(划分成几个区域) 流图G中，圈复杂度V(G) = E - N + 2，其中E为边数，N为结点数 流图G中，圈复杂度V(G) = P + 1，其中P为判定节点数(IF/CASE语句) ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:6","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#代码圈复杂度的计算方法"},{"categories":["961"],"content":" 4.7 白盒测试中的基本路径测试方法","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:7","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#白盒测试中的基本路径测试方法"},{"categories":["961"],"content":" 4.8 黑盒测试中的等价类划分方法 ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:8","series":[],"tags":["961","se"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#黑盒测试中的等价类划分方法"},{"categories":["961"],"content":" 1 一、处理器体系结构","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:0","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#一处理器体系结构"},{"categories":["961"],"content":" 1.1 CPU中的时序电路 1.1.1 组合电路和时序电路是什么，它们有什么区别 组合电路：将逻辑门组合成一张网，所构成的计算块 时序电路：逻辑门电路和反馈逻辑回路或器件（寄存器）组成 核心区别是：时序电路的输出不仅取决于当时的输入值，而且还与电路过去的状态有关；任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:1","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#cpu中的时序电路"},{"categories":["961"],"content":" 1.1 CPU中的时序电路 1.1.1 组合电路和时序电路是什么，它们有什么区别 组合电路：将逻辑门组合成一张网，所构成的计算块 时序电路：逻辑门电路和反馈逻辑回路或器件（寄存器）组成 核心区别是：时序电路的输出不仅取决于当时的输入值，而且还与电路过去的状态有关；任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:1","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#组合电路和时序电路是什么它们有什么区别"},{"categories":["961"],"content":" 1.2 单周期处理器的设计单周期处理器：在一个时钟周期内完成单条指令：取指、译码、执行、访存、写回、更新PC 1、取指：从内存中读取指令，加载至处理器 2、译码：对取指令操作中得到的指令进行分析并译码，确定这条指令需要完成的操作，从而产生相的操作控制信号 3、执行：进行相应的逻辑或算术运算 4、访存：内存访问（非必要） 5、写回：将指令结果写回至寄存器（非必要） 6、更新PC：更新程序计数器（将程序计数器指向接下来要执行的指令的地址） ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:2","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#单周期处理器的设计"},{"categories":["961"],"content":" 1.3 流水线处理器的基本原理 1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线处理器的基本原理"},{"categories":["961"],"content":" 1.3 流水线处理器的基本原理 1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线处理器的概念及基本原理"},{"categories":["961"],"content":" 1.3 流水线处理器的基本原理 1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线处理器的局限性"},{"categories":["961"],"content":" 1.3 流水线处理器的基本原理 1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线冒险冒险的种类及对应解决方法"},{"categories":["961"],"content":" 1.3 流水线处理器的基本原理 1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#影响流水线效率的因素"},{"categories":["961"],"content":" 1.3 流水线处理器的基本原理 1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线插入气泡技术"},{"categories":["961"],"content":" 1.4 Data Hazard的处理","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:4","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#data-hazard的处理"},{"categories":["961"],"content":" 1.5 流水线设计中的其他问题 1.5.1 流水线若干问题及注意点 流水线并不能减少(而且一般是增加)单条指令的执行时间，但却能提高系统吞吐率。 适当增加流水线的深度(段数)可以提高流水线的性能。（参考流水线的局限性-不一致的划分） 流水线的深度(级数)受限于流水线的延迟和流水线的额外开销 如果流水线中的指令相互独立 ，则可以充分发挥流水线的性能。但在实际中 ，指令间可能会是相互依赖，这会降低流水线的性能。 1.5.2 解决流水线的局限性-不一致的划分，超标量技术（选看）Intel处理器中的超线程技术的本质就是超标量技术。 在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。其实质是以时间换取空间。 处理器的执行阶段往往是处理器中最耗时的阶段，也就是说执行阶段往往是处理器的瓶颈。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:5","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线设计中的其他问题"},{"categories":["961"],"content":" 1.5 流水线设计中的其他问题 1.5.1 流水线若干问题及注意点 流水线并不能减少(而且一般是增加)单条指令的执行时间，但却能提高系统吞吐率。 适当增加流水线的深度(段数)可以提高流水线的性能。（参考流水线的局限性-不一致的划分） 流水线的深度(级数)受限于流水线的延迟和流水线的额外开销 如果流水线中的指令相互独立 ，则可以充分发挥流水线的性能。但在实际中 ，指令间可能会是相互依赖，这会降低流水线的性能。 1.5.2 解决流水线的局限性-不一致的划分，超标量技术（选看）Intel处理器中的超线程技术的本质就是超标量技术。 在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。其实质是以时间换取空间。 处理器的执行阶段往往是处理器中最耗时的阶段，也就是说执行阶段往往是处理器的瓶颈。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:5","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线若干问题及注意点"},{"categories":["961"],"content":" 1.5 流水线设计中的其他问题 1.5.1 流水线若干问题及注意点 流水线并不能减少(而且一般是增加)单条指令的执行时间，但却能提高系统吞吐率。 适当增加流水线的深度(段数)可以提高流水线的性能。（参考流水线的局限性-不一致的划分） 流水线的深度(级数)受限于流水线的延迟和流水线的额外开销 如果流水线中的指令相互独立 ，则可以充分发挥流水线的性能。但在实际中 ，指令间可能会是相互依赖，这会降低流水线的性能。 1.5.2 解决流水线的局限性-不一致的划分，超标量技术（选看）Intel处理器中的超线程技术的本质就是超标量技术。 在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。其实质是以时间换取空间。 处理器的执行阶段往往是处理器中最耗时的阶段，也就是说执行阶段往往是处理器的瓶颈。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:5","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#解决流水线的局限性-不一致的划分超标量技术选看"},{"categories":["961"],"content":" 2 二、优化程序性能","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:0","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#二优化程序性能"},{"categories":["961"],"content":" 2.1 优化程序性能","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:1","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#优化程序性能"},{"categories":["961"],"content":" 2.2 优化编译器的能力和局限性以及表示程序性能 1、高级设计：选择合适的算法和数据结构。 2、基本编码原则：避免限制优化的因素，使编译器产生高效的代码 1)、消除连续的函数调用（消除低效率循环、减少过程调用）：在可能时，将计算移到循环外。 2)、消除不必要的内存引用：引入临时变量来保存中间结果，只有在最后的值计算出来时，才将结果存放到数组或全局变量中。 3、低级优化：结构化代码以利用硬件功能。 1)、展开循环，降低开销 2)、提高指令级并行：通过多个累积变量和重新结合技术 3)、用功能性的风格重写条件操作，使得编译采用数据传送。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:2","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#优化编译器的能力和局限性以及表示程序性能"},{"categories":["961"],"content":" 2.3 特定体系结构或应用特性的性能优化","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#特定体系结构或应用特性的性能优化"},{"categories":["961"],"content":" 2.4 限制因素 1、寄存器溢出：并行度超过了可用寄存器的数量，就会发生溢出。将某些临时值放到内存中，通常是在运行时堆栈上分配空间。 2、分支预测和预测错误的惩罚：分支预测逻辑不能正确预测分支是否要跳转，这时条件分支可能会招致很大的预测错误处罚 不要过分关心可预测分支 书写适合用条件传送实现的代码 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:4","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#限制因素"},{"categories":["961"],"content":" 2.5 确认和消除性能瓶颈程序剖析运行版本的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间．再根据Amdahl定律进行优化。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:5","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#确认和消除性能瓶颈"},{"categories":["961"],"content":" 2.6 Amdahl定律Amdahl定律的主要思想是当我们加快系统的一个部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少． 公式：S = 1 / ((1 - a) + a / k) 其中a为某部分需要时间的百分比，k为性能提升倍数． 主要观点是要想大幅度提高整个系统的速度，我们必须提高整个系统很大一部分的速度． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:6","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#amdahl定律"},{"categories":["961"],"content":" 3 三、存储器结构及虚拟存储器","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:0","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#三存储器结构及虚拟存储器"},{"categories":["961"],"content":" 3.1 局部性局部性通常有两种形式：时间局部性(temporal locality)和空间局部性(spatial locality)． 在一个具有良好时间局部性的程序中，被引用过一次的存储器位置很可能在不远的将来再被多次引用． 在一个具有良好空间局部性的程序中，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:1","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#局部性"},{"categories":["961"],"content":" 3.2 存储器层级结构 3.2.1 存储器的层级结构从高层往低层走，存储设备逐渐从小而快变得更大、更慢、更便宜，每层都会缓存来自较低一层的数据对象。被缓存的数据对象一般是处理器近期可能会需要的信息，这样可以有效提高读/写效率。 寄存器 L1高速缓存 L2高速缓存 L3高速缓存 主存 本地二级存储（本地磁盘） 远程二级存储（分布式文件系统，WEB服务器） 主要思想：上一层的存储器作为低一层的存储器的高速缓存。利用高速缓存的局部性原理：程序具有访问局部区域里的数据和代码的趋势。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:2","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#存储器层级结构"},{"categories":["961"],"content":" 3.2 存储器层级结构 3.2.1 存储器的层级结构从高层往低层走，存储设备逐渐从小而快变得更大、更慢、更便宜，每层都会缓存来自较低一层的数据对象。被缓存的数据对象一般是处理器近期可能会需要的信息，这样可以有效提高读/写效率。 寄存器 L1高速缓存 L2高速缓存 L3高速缓存 主存 本地二级存储（本地磁盘） 远程二级存储（分布式文件系统，WEB服务器） 主要思想：上一层的存储器作为低一层的存储器的高速缓存。利用高速缓存的局部性原理：程序具有访问局部区域里的数据和代码的趋势。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:2","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#存储器的层级结构"},{"categories":["961"],"content":" 3.3 计算机高速缓存器原理","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#计算机高速缓存器原理"},{"categories":["961"],"content":" 3.4 高速缓存对性能的影响","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:4","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#高速缓存对性能的影响"},{"categories":["961"],"content":" 3.5 地址空间地址空间是一个非负整数地址的有序集合． 如果地址空间中的整数是连续的，那么就是一个线性地址空间． 在一个带虚拟存储器的系统中，CPU从一个有2^n个地址的地址空间中生产虚拟地址，这个地址空间称为虚拟地址空间． 物理地址空间与系统中的物理存储器相对应． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:5","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#地址空间"},{"categories":["961"],"content":" 3.6 虚拟存储器虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的、私有地址空间． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:6","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#虚拟存储器"},{"categories":["961"],"content":" 3.7 虚拟内存的管理、翻译和映射","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:7","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#虚拟内存的管理翻译和映射"},{"categories":["961"],"content":" 3.8 TLBTLB(Translation Lookaside Buffer)叫做翻译后备缓冲器． TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由PTE组成的块． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:8","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#tlb"},{"categories":["961"],"content":" 3.9 动态存储器分配","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:9","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#动态存储器分配"},{"categories":["961"],"content":" 3.10 垃圾收集 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:10","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#垃圾收集"},{"categories":["961"],"content":" 4 四、链接、进程及并发编程","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:0","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#四链接进程及并发编程"},{"categories":["961"],"content":" 4.1 静态链接","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:1","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#静态链接"},{"categories":["961"],"content":" 4.2 目标文件","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:2","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#目标文件"},{"categories":["961"],"content":" 4.3 符号和符号表","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#符号和符号表"},{"categories":["961"],"content":" 4.4 重定位和加载","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:4","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#重定位和加载"},{"categories":["961"],"content":" 4.5 动态链接库","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:5","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#动态链接库"},{"categories":["961"],"content":" 4.6 异常","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:6","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#异常"},{"categories":["961"],"content":" 4.7 进程","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:7","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#进程"},{"categories":["961"],"content":" 4.8 进程控制和信号","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:8","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#进程控制和信号"},{"categories":["961"],"content":" 4.9 进程间的通信","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:9","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#进程间的通信"},{"categories":["961"],"content":" 4.10 进程间信号量的控制、信号量","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:10","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#进程间信号量的控制信号量"},{"categories":["961"],"content":" 4.11 各种并发编程模式","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:11","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#各种并发编程模式"},{"categories":["961"],"content":" 4.12 共享变量","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:12","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#共享变量"},{"categories":["961"],"content":" 4.13 线程同步","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:13","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#线程同步"},{"categories":["961"],"content":" 4.14 其他并行问题 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:14","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#其他并行问题"},{"categories":["961"],"content":" 5 五、系统级I/O和网络编程","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:0","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#五系统级io和网络编程"},{"categories":["961"],"content":" 5.1 I/O相关概念","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:1","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#io相关概念"},{"categories":["961"],"content":" 5.2 文件及文件操作","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:2","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#文件及文件操作"},{"categories":["961"],"content":" 5.3 共享文件","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:3","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#共享文件"},{"categories":["961"],"content":" 5.4 网络编程","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:4","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#网络编程"},{"categories":["961"],"content":" 5.5 客户端-服务器模型","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:5","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#客户端-服务器模型"},{"categories":["961"],"content":" 5.6 套接字接口","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:6","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#套接字接口"},{"categories":["961"],"content":" 5.7 HTTP请求","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:7","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#http请求"},{"categories":["961"],"content":" 5.8 Web服务器","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:8","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#web服务器"},{"categories":["961"],"content":" 6 RISC和CISC（20年考到了但是考纲中没有） ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:6:0","series":[],"tags":["961","cs"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#risc和cisc20年考到了但是考纲中没有"},{"categories":["961"],"content":" 1 一、栈（Stack）、队列（Queue）和向量（Vector）","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:0","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#一栈stack队列queue和向量vector"},{"categories":["961"],"content":" 1.1 链表 1.1.1 单链表 1.1.2 双向链表 1.1.3 环形链表 1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#链表"},{"categories":["961"],"content":" 1.1 链表 1.1.1 单链表 1.1.2 双向链表 1.1.3 环形链表 1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#单链表"},{"categories":["961"],"content":" 1.1 链表 1.1.1 单链表 1.1.2 双向链表 1.1.3 环形链表 1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#双向链表"},{"categories":["961"],"content":" 1.1 链表 1.1.1 单链表 1.1.2 双向链表 1.1.3 环形链表 1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#环形链表"},{"categories":["961"],"content":" 1.1 链表 1.1.1 单链表 1.1.2 双向链表 1.1.3 环形链表 1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#带哨兵节点的链表"},{"categories":["961"],"content":" 1.2 栈 1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质 1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\" #include \u003cstdlib.h\u003e // for malloc #include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\" #include \u003cstdlib.h\u003e // for malloc #include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Erro","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈"},{"categories":["961"],"content":" 1.2 栈 1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质 1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Erro","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的基本概念"},{"categories":["961"],"content":" 1.2 栈 1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质 1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Erro","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的性质"},{"categories":["961"],"content":" 1.2 栈 1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质 1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Erro","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的adt"},{"categories":["961"],"content":" 1.2 栈 1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质 1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Erro","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的实现"},{"categories":["961"],"content":" 1.2 栈 1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质 1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Erro","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的数组实现"},{"categories":["961"],"content":" 1.2 栈 1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质 1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Erro","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的链表实现"},{"categories":["961"],"content":" 1.2 栈 1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质 1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Erro","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的应用"},{"categories":["961"],"content":" 1.2 栈 1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质 1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\" #include // for malloc #include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Erro","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈与递归"},{"categories":["961"],"content":" 1.3 队列 1.3.1 队列的基本概念 1.3.2 队列的性质 1.3.3 队列的ADT 1.3.4 队列的实现 1.3.4.1 队列的顺序实现 1.3.4.2 队列的链表实现 1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列"},{"categories":["961"],"content":" 1.3 队列 1.3.1 队列的基本概念 1.3.2 队列的性质 1.3.3 队列的ADT 1.3.4 队列的实现 1.3.4.1 队列的顺序实现 1.3.4.2 队列的链表实现 1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的基本概念"},{"categories":["961"],"content":" 1.3 队列 1.3.1 队列的基本概念 1.3.2 队列的性质 1.3.3 队列的ADT 1.3.4 队列的实现 1.3.4.1 队列的顺序实现 1.3.4.2 队列的链表实现 1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的性质"},{"categories":["961"],"content":" 1.3 队列 1.3.1 队列的基本概念 1.3.2 队列的性质 1.3.3 队列的ADT 1.3.4 队列的实现 1.3.4.1 队列的顺序实现 1.3.4.2 队列的链表实现 1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的adt"},{"categories":["961"],"content":" 1.3 队列 1.3.1 队列的基本概念 1.3.2 队列的性质 1.3.3 队列的ADT 1.3.4 队列的实现 1.3.4.1 队列的顺序实现 1.3.4.2 队列的链表实现 1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的实现"},{"categories":["961"],"content":" 1.3 队列 1.3.1 队列的基本概念 1.3.2 队列的性质 1.3.3 队列的ADT 1.3.4 队列的实现 1.3.4.1 队列的顺序实现 1.3.4.2 队列的链表实现 1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的顺序实现"},{"categories":["961"],"content":" 1.3 队列 1.3.1 队列的基本概念 1.3.2 队列的性质 1.3.3 队列的ADT 1.3.4 队列的实现 1.3.4.1 队列的顺序实现 1.3.4.2 队列的链表实现 1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的链表实现"},{"categories":["961"],"content":" 1.3 队列 1.3.1 队列的基本概念 1.3.2 队列的性质 1.3.3 队列的ADT 1.3.4 队列的实现 1.3.4.1 队列的顺序实现 1.3.4.2 队列的链表实现 1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的应用"},{"categories":["961"],"content":" 1.4 向量 1.4.1 向量的基本概念 1.4.2 向量的性质 1.4.3 向量的ADT 1.4.4 向量的实现 1.4.4.1 向量的数组实现 1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量"},{"categories":["961"],"content":" 1.4 向量 1.4.1 向量的基本概念 1.4.2 向量的性质 1.4.3 向量的ADT 1.4.4 向量的实现 1.4.4.1 向量的数组实现 1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的基本概念"},{"categories":["961"],"content":" 1.4 向量 1.4.1 向量的基本概念 1.4.2 向量的性质 1.4.3 向量的ADT 1.4.4 向量的实现 1.4.4.1 向量的数组实现 1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的性质"},{"categories":["961"],"content":" 1.4 向量 1.4.1 向量的基本概念 1.4.2 向量的性质 1.4.3 向量的ADT 1.4.4 向量的实现 1.4.4.1 向量的数组实现 1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的adt"},{"categories":["961"],"content":" 1.4 向量 1.4.1 向量的基本概念 1.4.2 向量的性质 1.4.3 向量的ADT 1.4.4 向量的实现 1.4.4.1 向量的数组实现 1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的实现"},{"categories":["961"],"content":" 1.4 向量 1.4.1 向量的基本概念 1.4.2 向量的性质 1.4.3 向量的ADT 1.4.4 向量的实现 1.4.4.1 向量的数组实现 1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的数组实现"},{"categories":["961"],"content":" 1.4 向量 1.4.1 向量的基本概念 1.4.2 向量的性质 1.4.3 向量的ADT 1.4.4 向量的实现 1.4.4.1 向量的数组实现 1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的链表实现"},{"categories":["961"],"content":" 2 二、树","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:0","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二树"},{"categories":["961"],"content":" 2.1 树的基本概念和术语","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:1","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#树的基本概念和术语"},{"categories":["961"],"content":" 2.2 树的遍历 2.2.1 前序遍历 2.2.2 中序遍历 2.2.3 后序遍历 2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#树的遍历"},{"categories":["961"],"content":" 2.2 树的遍历 2.2.1 前序遍历 2.2.2 中序遍历 2.2.3 后序遍历 2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#前序遍历"},{"categories":["961"],"content":" 2.2 树的遍历 2.2.1 前序遍历 2.2.2 中序遍历 2.2.3 后序遍历 2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#中序遍历"},{"categories":["961"],"content":" 2.2 树的遍历 2.2.1 前序遍历 2.2.2 中序遍历 2.2.3 后序遍历 2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#后序遍历"},{"categories":["961"],"content":" 2.2 树的遍历 2.2.1 前序遍历 2.2.2 中序遍历 2.2.3 后序遍历 2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#层序遍历"},{"categories":["961"],"content":" 2.3 二叉树的定义和性质","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二叉树的定义和性质"},{"categories":["961"],"content":" 2.4 普通树与二叉树的转换","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#普通树与二叉树的转换"},{"categories":["961"],"content":" 2.5 树的存储结构 2.5.1 标准形式 2.5.2 完全树的数组形式","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#树的存储结构"},{"categories":["961"],"content":" 2.5 树的存储结构 2.5.1 标准形式 2.5.2 完全树的数组形式","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#标准形式"},{"categories":["961"],"content":" 2.5 树的存储结构 2.5.1 标准形式 2.5.2 完全树的数组形式","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#完全树的数组形式"},{"categories":["961"],"content":" 2.6 树的应用 2.6.1 Huffman树的定义与应用 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:6","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#树的应用"},{"categories":["961"],"content":" 2.6 树的应用 2.6.1 Huffman树的定义与应用 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:6","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#huffman树的定义与应用"},{"categories":["961"],"content":" 3 三、查找(search)","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:0","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#三查找search"},{"categories":["961"],"content":" 3.1 查找的基本概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:1","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#查找的基本概念"},{"categories":["961"],"content":" 3.2 对线性关系结构的查找 3.2.1 顺序查找 3.2.2 二分查找","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#对线性关系结构的查找"},{"categories":["961"],"content":" 3.2 对线性关系结构的查找 3.2.1 顺序查找 3.2.2 二分查找","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#顺序查找"},{"categories":["961"],"content":" 3.2 对线性关系结构的查找 3.2.1 顺序查找 3.2.2 二分查找","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二分查找"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#hash查找法"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#常见的hash函数"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#直接定址法"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#随机数法"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#hash冲突的概念"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#解决hash冲突的办法"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#开散列方法"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#拉链法"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#闭散列方法"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#开址定址法"},{"categories":["961"],"content":" 3.3 Hash查找法 3.3.1 常见的Hash函数 3.3.1.1 直接定址法 3.3.1.2 随机数法 3.3.2 Hash冲突的概念 3.3.3 解决Hash冲突的办法 3.3.3.1 开散列方法 3.3.3.2 拉链法 3.3.3.3 闭散列方法 3.3.3.4 开址定址法 3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二次聚集现象"},{"categories":["961"],"content":" 3.4 BST查找法 3.4.1 BST树的定义 3.4.2 BST树的性质 3.4.3 BST树的ADT 3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst查找法"},{"categories":["961"],"content":" 3.4 BST查找法 3.4.1 BST树的定义 3.4.2 BST树的性质 3.4.3 BST树的ADT 3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst树的定义"},{"categories":["961"],"content":" 3.4 BST查找法 3.4.1 BST树的定义 3.4.2 BST树的性质 3.4.3 BST树的ADT 3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst树的性质"},{"categories":["961"],"content":" 3.4 BST查找法 3.4.1 BST树的定义 3.4.2 BST树的性质 3.4.3 BST树的ADT 3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst树的adt"},{"categories":["961"],"content":" 3.4 BST查找法 3.4.1 BST树的定义 3.4.2 BST树的性质 3.4.3 BST树的ADT 3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst树的实现"},{"categories":["961"],"content":" 3.5 AVL查找法 3.5.1 AVL树的定义 3.5.2 AVL树的性质 3.5.3 AVL树的ADT 3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl查找法"},{"categories":["961"],"content":" 3.5 AVL查找法 3.5.1 AVL树的定义 3.5.2 AVL树的性质 3.5.3 AVL树的ADT 3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl树的定义"},{"categories":["961"],"content":" 3.5 AVL查找法 3.5.1 AVL树的定义 3.5.2 AVL树的性质 3.5.3 AVL树的ADT 3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl树的性质"},{"categories":["961"],"content":" 3.5 AVL查找法 3.5.1 AVL树的定义 3.5.2 AVL树的性质 3.5.3 AVL树的ADT 3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl树的adt"},{"categories":["961"],"content":" 3.5 AVL查找法 3.5.1 AVL树的定义 3.5.2 AVL树的性质 3.5.3 AVL树的ADT 3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl树的实现"},{"categories":["961"],"content":" 3.5 AVL查找法 3.5.1 AVL树的定义 3.5.2 AVL树的性质 3.5.3 AVL树的ADT 3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#平衡因子的概念"},{"categories":["961"],"content":" 3.6 优先队列查找法 3.6.1 堆的定义 3.6.2 堆的生成 3.6.3 堆的调整算法 3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#优先队列查找法"},{"categories":["961"],"content":" 3.6 优先队列查找法 3.6.1 堆的定义 3.6.2 堆的生成 3.6.3 堆的调整算法 3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#堆的定义"},{"categories":["961"],"content":" 3.6 优先队列查找法 3.6.1 堆的定义 3.6.2 堆的生成 3.6.3 堆的调整算法 3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#堆的生成"},{"categories":["961"],"content":" 3.6 优先队列查找法 3.6.1 堆的定义 3.6.2 堆的生成 3.6.3 堆的调整算法 3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#堆的调整算法"},{"categories":["961"],"content":" 3.6 优先队列查找法 3.6.1 堆的定义 3.6.2 堆的生成 3.6.3 堆的调整算法 3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#范围查找"},{"categories":["961"],"content":" 4 四、排序","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:0","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#四排序"},{"categories":["961"],"content":" 4.1 排序基本概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:1","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#排序基本概念"},{"categories":["961"],"content":" 4.2 排序算法 4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#排序算法"},{"categories":["961"],"content":" 4.2 排序算法 4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#插入排序"},{"categories":["961"],"content":" 4.2 排序算法 4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#希尔排序"},{"categories":["961"],"content":" 4.2 排序算法 4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#选择排序"},{"categories":["961"],"content":" 4.2 排序算法 4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#快速排序"},{"categories":["961"],"content":" 4.2 排序算法 4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#合并排序"},{"categories":["961"],"content":" 4.2 排序算法 4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#基数排序"},{"categories":["961"],"content":" 5 五、图","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:0","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#五图"},{"categories":["961"],"content":" 5.1 图的基本概念一个图是由有限非空顶点集和边集组成． 每一条边都是一副点对．如果边有方向，那么就是有向边，表示为\u003cv, w\u003e．如果边没有方向，那么就是无向边，表示为(v, w)． 如果点对是有序的，那么图就是有向的．如果点对是无序的，那么图就是无向的． 无向图中，顶点v的度是指和顶点v相关联的边的数目． 有向图中，以顶点v为弧头的弧的数目称为顶点v的入度，以顶点v为弧尾的弧的数目称为顶点v的出度． 路径是有顶点序列组成，路径的长为该路径上的边数． 序列中顶点不重复出现的路径称为简单路径． 若一条路径中第一个顶点和最后一个顶点相同，则这条路径是一条回路． 如果图含有一条从一个顶点到它自身的边(v, w)，那么路径ｖｗ有时也称作为环(loop)．我们一般讨论的都是无环图！ 如果在一个无向图中从每一个顶点到每个其他顶点都存在一条路径，则称该无向图是连通的．具有这样性质的有向图称为是强连通的． 无向图中的极大连通子图为其连通分量．有向图中的极大强连通子图称为有向图的强连通分量． 每条边都可以附带一个数，这种与边相关的数称为权，权可以表示从一个顶点到另一个顶点的距离或者花费的代价。边上带权的图称为带权图． 完全图是其每一对顶点间都存在一条边的图． ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:1","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#图的基本概念"},{"categories":["961"],"content":" 5.2 图的存储结构 5.2.1 邻接矩阵表示图的一种简单的方法是使用一个二维数组，称为邻接矩阵表示法． 5.2.2 邻接表表示图的另一种方法是使用数组与链表相结合的存储方式，成为邻接表表示法． ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#图的存储结构"},{"categories":["961"],"content":" 5.2 图的存储结构 5.2.1 邻接矩阵表示图的一种简单的方法是使用一个二维数组，称为邻接矩阵表示法． 5.2.2 邻接表表示图的另一种方法是使用数组与链表相结合的存储方式，成为邻接表表示法． ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#邻接矩阵"},{"categories":["961"],"content":" 5.2 图的存储结构 5.2.1 邻接矩阵表示图的一种简单的方法是使用一个二维数组，称为邻接矩阵表示法． 5.2.2 邻接表表示图的另一种方法是使用数组与链表相结合的存储方式，成为邻接表表示法． ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:2","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#邻接表"},{"categories":["961"],"content":" 5.3 图的遍历从图中某一顶点出发访问图中其余顶点，且每个顶点只访问一次，这一过程成为图的遍历． 图的遍历分为广度优先遍历和深度优先遍历． 5.3.1 广度优先遍历广度优先搜索算法（BFS）类似于树的层次遍历 基本思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 5.3.2 深度优先遍历图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。 基本思路：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#图的遍历"},{"categories":["961"],"content":" 5.3 图的遍历从图中某一顶点出发访问图中其余顶点，且每个顶点只访问一次，这一过程成为图的遍历． 图的遍历分为广度优先遍历和深度优先遍历． 5.3.1 广度优先遍历广度优先搜索算法（BFS）类似于树的层次遍历 基本思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 5.3.2 深度优先遍历图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。 基本思路：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#广度优先遍历"},{"categories":["961"],"content":" 5.3 图的遍历从图中某一顶点出发访问图中其余顶点，且每个顶点只访问一次，这一过程成为图的遍历． 图的遍历分为广度优先遍历和深度优先遍历． 5.3.1 广度优先遍历广度优先搜索算法（BFS）类似于树的层次遍历 基本思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 5.3.2 深度优先遍历图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。 基本思路：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:3","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#深度优先遍历"},{"categories":["961"],"content":" 5.4 最小生成树基本概念一个无向图的最小生成树就是由该图的那些连接无向图的所有顶点的边构成的树，且其总价值最低． 5.4.1 Prim算法 5.4.2 Kruskal算法","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#最小生成树基本概念"},{"categories":["961"],"content":" 5.4 最小生成树基本概念一个无向图的最小生成树就是由该图的那些连接无向图的所有顶点的边构成的树，且其总价值最低． 5.4.1 Prim算法 5.4.2 Kruskal算法","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#prim算法"},{"categories":["961"],"content":" 5.4 最小生成树基本概念一个无向图的最小生成树就是由该图的那些连接无向图的所有顶点的边构成的树，且其总价值最低． 5.4.1 Prim算法 5.4.2 Kruskal算法","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:4","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#kruskal算法"},{"categories":["961"],"content":" 5.5 最短路径问题 5.5.1 广度优先遍历算法 5.5.2 Dijkstra算法 5.5.3 Floyd算法 public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { dist[i][j] = mMatrix[i][j]; // \"顶点i\"到\"顶点j\"的路径长度为\"i到j的权值\"。 path[i][j] = j; // \"顶点i\"到\"顶点j\"的最短路径是经过顶点j。 } } // 计算最短路径 for (int k = 0; k \u003c mVexs.length; k++) { for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j] int tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]); if (dist[i][j] \u003e tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } } ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#最短路径问题"},{"categories":["961"],"content":" 5.5 最短路径问题 5.5.1 广度优先遍历算法 5.5.2 Dijkstra算法 5.5.3 Floyd算法 public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { dist[i][j] = mMatrix[i][j]; // \"顶点i\"到\"顶点j\"的路径长度为\"i到j的权值\"。 path[i][j] = j; // \"顶点i\"到\"顶点j\"的最短路径是经过顶点j。 } } // 计算最短路径 for (int k = 0; k \u003c mVexs.length; k++) { for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j] int tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]); if (dist[i][j] \u003e tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } } ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#广度优先遍历算法"},{"categories":["961"],"content":" 5.5 最短路径问题 5.5.1 广度优先遍历算法 5.5.2 Dijkstra算法 5.5.3 Floyd算法 public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { dist[i][j] = mMatrix[i][j]; // \"顶点i\"到\"顶点j\"的路径长度为\"i到j的权值\"。 path[i][j] = j; // \"顶点i\"到\"顶点j\"的最短路径是经过顶点j。 } } // 计算最短路径 for (int k = 0; k \u003c mVexs.length; k++) { for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j] int tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]); if (dist[i][j] \u003e tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } } ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#dijkstra算法"},{"categories":["961"],"content":" 5.5 最短路径问题 5.5.1 广度优先遍历算法 5.5.2 Dijkstra算法 5.5.3 Floyd算法 public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { dist[i][j] = mMatrix[i][j]; // \"顶点i\"到\"顶点j\"的路径长度为\"i到j的权值\"。 path[i][j] = j; // \"顶点i\"到\"顶点j\"的最短路径是经过顶点j。 } } // 计算最短路径 for (int k = 0; k \u003c mVexs.length; k++) { for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j] int tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]); if (dist[i][j] \u003e tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } } ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:5","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#floyd算法"},{"categories":["961"],"content":" 5.6 拓扑排序","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:6","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#拓扑排序"},{"categories":["961"],"content":" 5.7 历年真题总结 5.7.1 二叉树叶子节点统计个数递归解法： 如果二叉树为空，返回0 如果二叉树是叶子节点，返回1 如果二叉树不是叶子节点，二叉树的叶子节点数 = 左子树叶子节点数 + 右子树叶子节点数 public static int getNodeNumLeafRec(TreeNode root) { if (root == null) { return 0; } if (root.left == null \u0026\u0026 root.right == null) { return 1; } return getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right); } 非递归解法：基于层次遍历进行求解，利用Queue进行。 public static int getNodeNumLeaf(TreeNode root){ if (root == null) { return 0; } int leaf = 0; // 叶子节点个数 Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); queue.add(root); while (!queue.isEmpty()) { TreeNode temp = queue.poll(); if (temp.left == null \u0026\u0026 temp.right == null) { // 叶子节点 leaf++; } if (temp.left != null) { queue.add(temp.left); } if (temp.right != null) { queue.add(temp.right); } } return leaf; 5.7.2 TopK问题: 选择最大的K个数用PriorityQueue默认是自然顺序排序，要选择最大的k个数，构造小顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素大，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 找出前k个最大数，采用小顶堆实现 public static int[] findKMax(int[] nums, int k) { PriorityQueue\u003cInteger\u003e pq = new PriorityQueue\u003c\u003e(k); // 队列默认自然顺序排列，小顶堆，不必重写compare for (int num : nums) { if (pq.size() \u003c k) { pq.offer(num); } else if (pq.peek() \u003c num) { // 如果堆顶元素 \u003c 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i \u003c k \u0026\u0026 !pq.isEmpty(); i++) { result[i] = pq.poll(); } return result; } public static void main(String[] args) { int[] arr = new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9}; System.out.println(Arrays.toString(findKMax(arr,5))); } } // 输出：[5, 6, 7, 8, 9] 要选择最小的K个数使用大顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素小，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 要找前k个最小数，则构建大顶堆，要重写compare方法 public static int[] findKMin(int[] nums, int k) { PriorityQueue\u003cInteger\u003e pq = new PriorityQueue\u003c\u003e(k, new Comparator\u003cInteger\u003e() { @Override public int compare(Integer o1, Integer o2) { return o2-o1; } }); for (int num : nums) { if (pq.size() \u003c k) { pq.offer(num); } else if (pq.peek() \u003e num) {//如果堆顶元素 \u003e 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i \u003c k\u0026\u0026!pq.isEmpty(); i++) { result[i] = pq.poll(); } return result; } public static void main(String[] args) { int[] arr = new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9}; System.out.println(Arrays.toString(findKMin( arr,5))); } } // 输出：[5, 4, 3, 2, 1] ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:7","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#历年真题总结"},{"categories":["961"],"content":" 5.7 历年真题总结 5.7.1 二叉树叶子节点统计个数递归解法： 如果二叉树为空，返回0 如果二叉树是叶子节点，返回1 如果二叉树不是叶子节点，二叉树的叶子节点数 = 左子树叶子节点数 + 右子树叶子节点数 public static int getNodeNumLeafRec(TreeNode root) { if (root == null) { return 0; } if (root.left == null \u0026\u0026 root.right == null) { return 1; } return getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right); } 非递归解法：基于层次遍历进行求解，利用Queue进行。 public static int getNodeNumLeaf(TreeNode root){ if (root == null) { return 0; } int leaf = 0; // 叶子节点个数 Queue queue = new LinkedList\u003c\u003e(); queue.add(root); while (!queue.isEmpty()) { TreeNode temp = queue.poll(); if (temp.left == null \u0026\u0026 temp.right == null) { // 叶子节点 leaf++; } if (temp.left != null) { queue.add(temp.left); } if (temp.right != null) { queue.add(temp.right); } } return leaf; 5.7.2 TopK问题: 选择最大的K个数用PriorityQueue默认是自然顺序排序，要选择最大的k个数，构造小顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素大，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 找出前k个最大数，采用小顶堆实现 public static int[] findKMax(int[] nums, int k) { PriorityQueue pq = new PriorityQueue\u003c\u003e(k); // 队列默认自然顺序排列，小顶堆，不必重写compare for (int num : nums) { if (pq.size() \u003c k) { pq.offer(num); } else if (pq.peek() \u003c num) { // 如果堆顶元素 \u003c 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i \u003c k \u0026\u0026 !pq.isEmpty(); i++) { result[i] = pq.poll(); } return result; } public static void main(String[] args) { int[] arr = new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9}; System.out.println(Arrays.toString(findKMax(arr,5))); } } // 输出：[5, 6, 7, 8, 9] 要选择最小的K个数使用大顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素小，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 要找前k个最小数，则构建大顶堆，要重写compare方法 public static int[] findKMin(int[] nums, int k) { PriorityQueue pq = new PriorityQueue\u003c\u003e(k, new Comparator() { @Override public int compare(Integer o1, Integer o2) { return o2-o1; } }); for (int num : nums) { if (pq.size() \u003c k) { pq.offer(num); } else if (pq.peek() \u003e num) {//如果堆顶元素 \u003e 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i \u003c k\u0026\u0026!pq.isEmpty(); i++) { result[i] = pq.poll(); } return result; } public static void main(String[] args) { int[] arr = new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9}; System.out.println(Arrays.toString(findKMin( arr,5))); } } // 输出：[5, 4, 3, 2, 1] ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:7","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二叉树叶子节点统计个数"},{"categories":["961"],"content":" 5.7 历年真题总结 5.7.1 二叉树叶子节点统计个数递归解法： 如果二叉树为空，返回0 如果二叉树是叶子节点，返回1 如果二叉树不是叶子节点，二叉树的叶子节点数 = 左子树叶子节点数 + 右子树叶子节点数 public static int getNodeNumLeafRec(TreeNode root) { if (root == null) { return 0; } if (root.left == null \u0026\u0026 root.right == null) { return 1; } return getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right); } 非递归解法：基于层次遍历进行求解，利用Queue进行。 public static int getNodeNumLeaf(TreeNode root){ if (root == null) { return 0; } int leaf = 0; // 叶子节点个数 Queue queue = new LinkedList\u003c\u003e(); queue.add(root); while (!queue.isEmpty()) { TreeNode temp = queue.poll(); if (temp.left == null \u0026\u0026 temp.right == null) { // 叶子节点 leaf++; } if (temp.left != null) { queue.add(temp.left); } if (temp.right != null) { queue.add(temp.right); } } return leaf; 5.7.2 TopK问题: 选择最大的K个数用PriorityQueue默认是自然顺序排序，要选择最大的k个数，构造小顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素大，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 找出前k个最大数，采用小顶堆实现 public static int[] findKMax(int[] nums, int k) { PriorityQueue pq = new PriorityQueue\u003c\u003e(k); // 队列默认自然顺序排列，小顶堆，不必重写compare for (int num : nums) { if (pq.size() \u003c k) { pq.offer(num); } else if (pq.peek() \u003c num) { // 如果堆顶元素 \u003c 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i \u003c k \u0026\u0026 !pq.isEmpty(); i++) { result[i] = pq.poll(); } return result; } public static void main(String[] args) { int[] arr = new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9}; System.out.println(Arrays.toString(findKMax(arr,5))); } } // 输出：[5, 6, 7, 8, 9] 要选择最小的K个数使用大顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素小，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 要找前k个最小数，则构建大顶堆，要重写compare方法 public static int[] findKMin(int[] nums, int k) { PriorityQueue pq = new PriorityQueue\u003c\u003e(k, new Comparator() { @Override public int compare(Integer o1, Integer o2) { return o2-o1; } }); for (int num : nums) { if (pq.size() \u003c k) { pq.offer(num); } else if (pq.peek() \u003e num) {//如果堆顶元素 \u003e 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i \u003c k\u0026\u0026!pq.isEmpty(); i++) { result[i] = pq.poll(); } return result; } public static void main(String[] args) { int[] arr = new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9}; System.out.println(Arrays.toString(findKMin( arr,5))); } } // 输出：[5, 4, 3, 2, 1] ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:7","series":[],"tags":["961","dsa"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#topk问题-选择最大的k个数"},{"categories":["Blog"],"content":"DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/"},{"categories":["Blog"],"content":"DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:0:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#"},{"categories":["Blog"],"content":" 1 style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:1:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#style"},{"categories":["Blog"],"content":" 2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上, 会有一行提示): Upstage ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:2:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#link"},{"categories":["Blog"],"content":" 3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.webp\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.webp\" src_l=\"/images/lighthouse-large.webp\" \u003e}} 呈现的输出效果如下: Lighthouse (image) ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:3:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#image"},{"categories":["Blog"],"content":" 4 admonitionadmonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:4:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#admonition"},{"categories":["Blog"],"content":" 5 mermaidmermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#mermaid"},{"categories":["Blog"],"content":" 5.1 流程图一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}}graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#flowchart"},{"categories":["Blog"],"content":" 5.2 时序图一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}}sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#sequence-diagram"},{"categories":["Blog"],"content":" 5.3 甘特图一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}}gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:3","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#gantt"},{"categories":["Blog"],"content":" 5.4 类图一个 类图 mermaid 示例: {{\u003c mermaid \u003e}}classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:4","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#class-diagram"},{"categories":["Blog"],"content":" 5.5 状态图一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}}stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:5","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#state-diagram"},{"categories":["Blog"],"content":" 5.6 Git 图一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}}gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:6","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#git-graph"},{"categories":["Blog"],"content":" 5.7 饼图一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}}pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:7","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#pie"},{"categories":["Blog"],"content":" 6 echartsECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}} title: text: 折线统计图 top: 2% left: center tooltip: trigger: axis legend: data: - 邮件营销 - 联盟广告 - 视频广告 - 直接访问 - 搜索引擎 top: 10% grid: left: 5% right: 5% bottom: 5% top: 20% containLabel: true toolbox: feature: saveAsImage: title: 保存为图片 xAxis: type: category boundaryGap: false data: - 周一 - 周二 - 周三 - 周四 - 周五 - 周六 - 周日 yAxis: type: value series: - name: 邮件营销 type: line stack: 总量 data: - 120 - 132 - 101 - 134 - 90 - 230 - 210 - name: 联盟广告 type: line stack: 总量 data: - 220 - 182 - 191 - 234 - 290 - 330 - 310 - name: 视频广告 type: line stack: 总量 data: - 150 - 232 - 201 - 154 - 190 - 330 - 410 - name: 直接访问 type: line stack: 总量 data: - 320 - 332 - 301 - 334 - 390 - 330 - 320 - name: 搜索引擎 type: line stack: 总量 data: - 820 - 932 - 901 - 934 - 1290 - 1330 - 1320 {{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:6:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#echarts"},{"categories":["Blog"],"content":" 7 mapbox Mapbox GL JS 是一个 JavaScript 库, 它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:7:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#mapbox"},{"categories":["Blog"],"content":" 8 musicmusic shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#music"},{"categories":["Blog"],"content":" 8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.webp\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#custom-music-url"},{"categories":["Blog"],"content":" 8.2 音乐平台 URL 的自动识别music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#automatic-identification"},{"categories":["Blog"],"content":" 8.3 自定义音乐平台, 类型和 IDmusic shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:3","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#custom-server"},{"categories":["Blog"],"content":" 8.4 其它参数music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:4","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#other-parameters"},{"categories":["Blog"],"content":" 9 aplayer and audio 如果你需要针对音乐播放器的更多自定义选项（如自定义歌单，迷你模式，自定义音乐类型以及更多…），你可以使用 aplayer shortcode 配合 audio shortcode 以发挥 APlayer.js 的全部功能。 aplayer shortcode 用于创建一个 APlayer 播放器实例，audio shortcode 则用于设置音乐文件的相关信息。请查看 APlayer.js 的文档 来了解所有的可配置项。 一个 aplayer 和 audio 的示例： {{\u003c aplayer fixed=false mini=false autoplay=false theme=\"#b7daff\" loop=\"all\" order=\"list\" preload=\"auto\" volume=0.7 mutex=true lrcType=1 listFolded=false listMaxHeight=\"\" storageName=\"aplayer-setting\" \u003e}} {{\u003c audio name=\"Wavelength\" artist=\"oldmanyoung\" url=\"/music/Wavelength.mp3\" cover=\"/images/Wavelength.webp\" /\u003e}} {{\u003c audio name=\"Wavelength\" artist=\"oldmanyoung\" url=\"/music/Wavelength.mp3\" cover=\"/images/Wavelength.webp\" \u003e}} [00:00.00]APlayer audio1 [00:04.01]is [00:08.02]amazing {{\u003c /audio \u003e}} {{\u003c /aplayer \u003e}} 呈现的输出效果如下： 需要注意的是，这两个 shortcodes 并不能单独使用，并且必须使用命名参数来设置它们的属性。 如果你将 LRC 放置于 audio shortcode 之中，它会通过 JS 字符串方式传递给 APlayer，所以你需要将 lrcType 设置为 1。如果你通过配置 lrc 参数的方式来设置 LRC 文件的链接，那么它将会被通过 LRC 文件方式传递给 APlayer，则 lrcType 需要被设置为 3。 ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:9:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#aplayer-and-audio"},{"categories":["Blog"],"content":" 10 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:10:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#bilibili"},{"categories":["Blog"],"content":" 11 typeittypeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#typeit"},{"categories":["Blog"],"content":" 11.1 简单内容允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#simple-content"},{"categories":["Blog"],"content":" 11.1 简单内容允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#id-13 class="},{"categories":["Blog"],"content":" 11.2 代码内容代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#code-content"},{"categories":["Blog"],"content":" 11.3 分组内容默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:3","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#code-content"},{"categories":["Blog"],"content":" 12 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Just DoIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:12:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#script"},{"categories":["Blog"],"content":" 13 friend friend shortcode 用来在你的页面上插入友链. friend shortcode 有以下命名参数: name [必需] (第一个位置参数) 友站的名称. url [必需] (第二个位置参数) 友站的链接. avatar [必需] (第三个位置参数) 友站的头像. bio [必需] (第四个位置参数) 友站的简介. 一个 friend 示例: {{\u003c friend \"PCloud\" \"https://github.com/HEIGE-PCloud/\" \"https://avatars.githubusercontent.com/u/52968553?v=4\" \"This is PCloud~💤\" \u003e}} 或者 {{\u003c friend name=\"PCloud\" url=\"https://github.com/HEIGE-PCloud/\" avatar=\"https://avatars.githubusercontent.com/u/52968553?v=4\" bio=\"This is PCloud~💤\" \u003e}} 呈现的输出效果如下: PCloud This is PCloud~💤 ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:13:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#friend"},{"categories":["Blog"],"content":" 14 showcase showcase 用于在页面上插入一个个人项目的展示柜. showcase shortcode 有以下命名参数: title [required] (第一个位置参数) 项目名称. summary [required] (第二个位置参数) 项目简介. image [required] (第三个位置参数) 预览图的链接. link [required] (第四个位置参数) 项目主页的链接. column [optional] (fifth positional parameter) 这个参数定义一行显示几个 showcase. 默认的值是 2, 默认一行显示两个 showcase. 你可以将它改为 1, 2 或 3. 需要注意的是, 当用户使用小屏幕访问网站时, 每行显示的 showcase 数量将会被自动调整以保证最好的体验. 一个 showcase 示例: {{\u003c showcase title=\"Theme Documentation - Basics\" summary=\"Discover what the Hugo - DoIt theme is all about and the core-concepts behind it.\" image=\"/theme-documentation-basics/featured-image.webp\" link=\"/theme-documentation-basics\" \u003e}} Or {{\u003c showcase \"Theme Documentation - Basics\" \"Discover what the Hugo - DoIt theme is all about and the core-concepts behind it.\" \"/theme-documentation-basics/featured-image.webp\" \"/theme-documentation-basics\" \u003e}} 呈现的输出效果如下: 主题文档 - 基本概念 探索 Hugo - DoIt 主题的全部内容和背后的核心概念. 阅读全文 ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:14:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#showcase"},{"categories":["Blog"],"content":" 15 math math 用于插入数学公式. 它可以阻止 Goldmark 将数学表达式中的特殊字符解析为 HTML 从而避免很多问题. 在 math 中, 你不再需要转义特殊字符. 一个 math 示例: {{\u003c math \u003e}}$\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}${{\u003c /math \u003e}} Or {{\u003c math \u003e}} $$\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}$$ {{\u003c /math \u003e}} 呈现的输出效果如下: $\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}$ $$\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}$$","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:15:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#math"},{"categories":["Blog"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/"},{"categories":["Blog"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:0:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#"},{"categories":["Blog"],"content":" 1 figurefigure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.webp\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.webp\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:1:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#figure"},{"categories":["Blog"],"content":" 2 gistgist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:2:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#gist"},{"categories":["Blog"],"content":" 3 highlighthighlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:3:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#highlight"},{"categories":["Blog"],"content":" 4 paramparam 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:4:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#param"},{"categories":["Blog"],"content":" 5 ref 和 relrefref 和 relref 的文档 ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:5:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#ref-and-relref"},{"categories":["Blog"],"content":" 6 tweettweet 的文档 一个 tweet 示例: {{\u003c tweet 877500564405444608 \u003e}} ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:6:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#tweet"},{"categories":["Blog"],"content":" 7 vimeovimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:7:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#vimeo"},{"categories":["Blog"],"content":" 8 youtubeyoutube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:8:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#youtube"},{"categories":["Blog"],"content":"了解如何在 DoIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-04","objectID":"/blog/002_loveit_content/","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/"},{"categories":["Blog"],"content":"了解如何在 DoIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:0:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#"},{"categories":["Blog"],"content":" 1 内容组织以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:1:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#contents-organization"},{"categories":["Blog"],"content":" 2 作者配置我们鼓励你在 mysite/data/authors 下创建你的作者个人资料 author_name.toml. 在你的资料中, 你可以添加个人链接, 邮箱, 以及支持 i18n 的姓名. 以下是 Alice.toml 的示例: link = \"https://alice.example.com\" email = \"alice@example.com\" name = \"Alice\" [zh-cn] name = \"爱丽丝\" 在创建作者个人资料后, 您可以在文章的前置参数中指定您的姓名. 之后, 该文章将自动著上你的名字, 并可以根据作者进行分类. --- authors: [Alice] --- 您也可以为一篇文章注明多个作者. --- authors: [Alice, Bob, Catherine] --- ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:2:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#author-setup"},{"categories":["Blog"],"content":" 3 前置参数Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: --- title: \"我的第一篇文章\" subtitle: \"\" date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true authors: [] description: \"\" license: \"\" images: [] tags: [] categories: [] series: [] series_weight: 1 seriesNavigation: true featuredImage: \"\" featuredImagePreview: \"\" hiddenFromHomePage: false hiddenFromSearch: false twemoji: false lightgallery: true ruby: true fraction: true fontawesome: true linkToMarkdown: true linkToSource: false linkToEdit: false linkToReport: false rssFullText: false license: '' toc: enable: true auto: true code: copy: true # ... table: sort: true # ... math: enable: true # ... mapbox: accessToken: \"\" # ... share: enable: true # ... comment: enable: true # ... library: css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: images: [] # ... outdatedArticleReminder: enable: false # ... sponsor: enable: false # ... --- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. authors: 文章作者. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. series: 文章所属的系列. series_weight: 自定义文章在系列中的位置. seriesNavigation: 是否使用系列导航. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. linkToSource: 如果设为 false, 则关闭页脚 view source 的链接. 你可以将其设置为一个指向文章原始文件的链接. 使用魔法变量 {path} 来获取文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.en.md. linkToEdit: 如果设为 false, 则关闭页脚 编辑此页 的链接. 你可以将其设置为一个用于编辑这个页面的链接. 使用魔法变量 {path} 来获取这篇文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.zh-cn.md. linkToReport: 如果设为 false, 则关闭页脚 报告问题 的链接. 你可以将其设置为一个用于报告此页面中错误的链接. 使用魔法变量 {path} 来获取文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.en.md, 使用 {title} 来获取文章的标题, 这篇文章的 {title} 为 Theme Documentation - Content, 使用 {url} 来获取文章的链接, 这篇文章的 {url} 为 https://hugodoit.pages.dev/theme-documentation-content/. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. pageStyle: 调整页面样式, 可选择\"normal\"或\"wide\". license: 许可协议信息 (支持 HTML 格式). toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. table: 和 网站配置 中的 params.page.table 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. outdatedArticleReminder: 和 网站配置 中的 params.page.outdatedArticleReminder 部分相同. sponsor: 和 网站配置 中的 params.sponsor 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:3:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#front-matter"},{"categories":["Blog"],"content":" 4 内容摘要DoIt 主题使用内容摘要在主页中显示大致文章信息. Hugo 支持生成文章的摘要. 文章摘要预览 ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#内容摘要"},{"categories":["Blog"],"content":" 4.1 自动摘要拆分默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能, 请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#自动摘要拆分"},{"categories":["Blog"],"content":" 4.2 手动摘要拆分另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#手动摘要拆分"},{"categories":["Blog"],"content":" 4.3 前置参数摘要你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:3","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#前置参数摘要"},{"categories":["Blog"],"content":" 4.4 使用文章描述作为摘要你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 DoIt 主题会将你的文章描述作为摘要. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:4","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#使用文章描述作为摘要"},{"categories":["Blog"],"content":" 4.5 摘要选择的优先级顺序由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:5","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#摘要选择的优先级顺序"},{"categories":["Blog"],"content":" 5 Markdown 基本语法这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:5:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#markdown-基本语法"},{"categories":["Blog"],"content":" 6 Markdown 扩展语法DoIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#extended-markdown-syntax"},{"categories":["Blog"],"content":" 6.1 Emoji 支持这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#emoji-支持"},{"categories":["Blog"],"content":" 6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#数学公式"},{"categories":["Blog"],"content":" 6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#公式块"},{"categories":["Blog"],"content":" 6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#行内公式"},{"categories":["Blog"],"content":" 6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#copy-tex"},{"categories":["Blog"],"content":" 6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#mhchem"},{"categories":["Blog"],"content":" 6.3 字符注音或者注释DoIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:3","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#ruby"},{"categories":["Blog"],"content":" 6.4 分数 DoIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:4","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#fraction"},{"categories":["Blog"],"content":" 6.5 Font AwesomeDoIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:5","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#fontawesome"},{"categories":["Blog"],"content":" 6.6 转义字符在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧 这个方法可以间接解决一个还未解决的 Hugo 的 issue. 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:6","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#escape-character"},{"categories":["Blog"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念.","date":"2020-03-03","objectID":"/blog/001_loveit_basics/","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/"},{"categories":["Blog"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:0:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#"},{"categories":["Blog"],"content":" 1 准备由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.83.0). 为什么不支持早期版本的 Hugo? 由于 WebP 图像处理 在 Hugo 0.83.0版本 中被引入, 本主题只支持高于 0.83.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:1:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#准备"},{"categories":["Blog"],"content":" 2 安装以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#安装"},{"categories":["Blog"],"content":" 2.1 创建你的项目Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#创建你的项目"},{"categories":["Blog"],"content":" 2.2 安装主题DoIt 主题的仓库是: https://github.com/HEIGE-PCloud/DoIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#安装主题"},{"categories":["Blog"],"content":" 2.3 基础配置以下是 DoIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"DoIt\" [params] # DoIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:3","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#basic-configuration"},{"categories":["Blog"],"content":" 2.4 创建你的第一篇文章以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:4","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#创建你的第一篇文章"},{"categories":["Blog"],"content":" 2.5 在本地启动网站使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:5","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#在本地启动网站"},{"categories":["Blog"],"content":" 2.6 构建网站当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:6","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#构建网站"},{"categories":["Blog"],"content":" 3 配置","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:3:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#配置"},{"categories":["Blog"],"content":" 3.1 网站配置除了 Hugo 全局配置 和 菜单配置 之外, DoIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # DoIt 主题版本 version = \"0.2.X\" # 网站名称 title = \"我的全新 Hugo 网站\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"black\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径, 仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 开启 PWA 支持 enablePWA = false # 版权信息 license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"DoIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\", \"fuse\") type = \"fuse\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.search.fuse] # https://fusejs.io/api/options.html isCaseSensitive = false minMatchCharLength = 2 findAllMatches = false location = 0 threshold = 0.3 distance = 100 ignoreLocation = false useExtendedSearch = false ignoreFieldNorm = false # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 主题切换模式 # 主题切换模式 (\"switch\", \"select\") themeChangeMode = \"select\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 托管服务信息 (支持 HTML 格式) # \u003ca title=\"Github Pages\" href=\"https://docs.github.com/en/pages/\" target=\"_blank\" rel=\"noopener noreffer\"\u003eGitHub Pages\u003c/a\u003e hostedOn = '' # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息, 仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 最近更新文章设置 [params.section.recentlyUpdated] enable = false rss = false days = 30 maxCount = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱, 用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL # 将你的头像文件放置于 static 或者 assets 目录下 # 文件路径是相对于 static 或者 assets 目录的 avatarURL = \"/images/avatar.webp\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:3:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#site-configuration"},{"categories":["Blog"],"content":" 3.2 网站图标, 浏览器配置, 网站清单强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:3:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#网站图标-浏览器配置-网站清单"},{"categories":["Blog"],"content":" 3.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, DoIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/DoIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:3:3","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#自定义样式"},{"categories":["Blog"],"content":" 4 多语言和 i18nDoIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换 ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:4:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#多语言和-i18n"},{"categories":["Blog"],"content":" 4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:4:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#language-compatibility"},{"categories":["Blog"],"content":" 4.2 基本配置学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为两个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:4:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#基本配置"},{"categories":["Blog"],"content":" 4.3 修改默认的翻译字符串翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件, 并从 themes/DoIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:4:3","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#修改默认的翻译字符串"},{"categories":["Blog"],"content":" 5 搜索 基于 Lunr.js 或 algolia, DoIt 主题支持搜索功能. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:5:0","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#搜索"},{"categories":["Blog"],"content":" 5.1 输出配置为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:5:1","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#输出配置"},{"categories":["Blog"],"content":" 5.2 搜索配置基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\", \"fuse\") type = \"fuse\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.search.fuse] # https://fusejs.io/api/options.html isCaseSensitive = false minMatchCharLength = 2 findAllMatches = false location = 0 threshold = 0.3 distance = 100 ignoreLocation = false useExtendedSearch = false ignoreFieldNorm = false 怎样选择搜索引擎? 以下是两种搜索引擎的对比: fuse: 简单, 无需同步 index.json, 没有 contentLength 的限制, 性能高 lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:5:2","series":["loveit-series"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#搜索配置"},{"categories":["programming"],"content":" 1 Java 概述","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#java-概述"},{"categories":["programming"],"content":" 1.1 Java 语言概述Java 是 SUN (Stanford University Network, 斯坦福大学网络公司) 于 1995 年推出的一门高级语言。Java 是一种面向 Internet 的编程语言，也是一种完全面向对象，安全可靠，与平台无关的编程语言。 Java5.0 之后的三大技术框架 J2EE (Java 2 Platform Enterprise Edition) 企业版 在 Jdk5.0 版本后称为 JAVAEE，是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如 Servlet Jsp 等，主要针对于 Web 应用程序开发。 J2SE (Java 2 Platform Standard Edition) 标准版 在 Jdk5.0 版本后称为 JAVASE，这是在 Java 基础阶段主要学习的内容，也是 Java 的基础，以后不管从事 Android 开发或者是物联网 + 云计算的开发等，是建立在 JSE 基础上的，因此该技术是 Java 的最核心技术。 J2ME (Java 2 Platform Micro Edition) 小型版 在 Jdk5.0 版本以后称为 JAVAME，该技术多应用于一些电子产品的嵌入式开发，以前在手机开发上应用的也比较多，但是随着智能手机的发展，现在手机应用程序 (比如 Android 程序) 的开发已经不再使用该技术。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:1","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#java-语言概述"},{"categories":["programming"],"content":" 1.2 JRE 和 JDK 的区别JRE (Java Runtime Environment)，Java 运行环境。包括 Java 虚拟机 (JVM Java Virtual Machine) 和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。 JDK (Java Development Kit Java)，开发工具包。JDK 是提供给 Java 开发人员使用的，其中 包含了 Java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:2","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#jre-和-jdk-的区别"},{"categories":["programming"],"content":" 1.3 JVMJVM (Java Virtual Machine)，是运行所有 Java 程序的抽象计算机，是 Java 语言的运行环境，是 Java 最具吸引力的特性之一。JVM 读取并处理编译过的与平台无关的字节码 (class) 文件。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:3","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#jvm"},{"categories":["programming"],"content":" 2 基础知识","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#基础知识"},{"categories":["programming"],"content":" 2.1 代码注释 单行注释 // 单行注释 多行注释 /* 多 行 注 释 */ 文档注释 /** * 文档注释 */ ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:1","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#代码注释"},{"categories":["programming"],"content":" 2.2 标识符标识符命名规则： 由字母、数字、下划线、$ 组成，不能以数字开头 区分大小写 不能使用关键字和保留字 不能使用 Java API 的类名 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:2","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#标识符"},{"categories":["programming"],"content":" 2.3 变量和常量变量：占据着内存中的某一个存储区域，该区域有名称 (变量名) 和类型 (数据类型)，数据在同一类型范围内不断变化。 定义变量的格式： 数据类型 变量名 = 初始化值 作用范围：定义开始到定义它的代码块结束 警告 注意同一作用域内，不允许定义多个同名局部变量！ ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:3","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#变量和常量"},{"categories":["programming"],"content":" 2.4 成员变量和局部变量 局部变量 定义在方法内的变量 没有默认初始值，使用前必须初始化 作用域是从定义开始到定义它的代码块结束 成员变量 定义在方法内的变量 作用域是在整个类中 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:4","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#成员变量和局部变量"},{"categories":["programming"],"content":" 2.5 基本数据类型Java 语言有 8 种基本数据类型，按用途分为以下 4 种类别： 类别 数据类型 整数型 byte、short、int、long 小数型 float、double 字符型 char 布尔型 boolean ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:5","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#基本数据类型"},{"categories":["programming"],"content":" 2.6 基本数据类型转换 2.6.1 向上转型容量小的类型可自动转换为容量大的数据类型！ 2.6.2 向下转型容量大的类型不会转换为容量小的数据类型！ 技巧 小转大，自动！自动类型转换 (也叫隐式类型转换) 大转小，强转！强制类型转换 (也叫显式类型转换) ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:6","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#基本数据类型转换"},{"categories":["programming"],"content":" 2.6 基本数据类型转换 2.6.1 向上转型容量小的类型可自动转换为容量大的数据类型！ 2.6.2 向下转型容量大的类型不会转换为容量小的数据类型！ 技巧 小转大，自动！自动类型转换 (也叫隐式类型转换) 大转小，强转！强制类型转换 (也叫显式类型转换) ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:6","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#向上转型"},{"categories":["programming"],"content":" 2.6 基本数据类型转换 2.6.1 向上转型容量小的类型可自动转换为容量大的数据类型！ 2.6.2 向下转型容量大的类型不会转换为容量小的数据类型！ 技巧 小转大，自动！自动类型转换 (也叫隐式类型转换) 大转小，强转！强制类型转换 (也叫显式类型转换) ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:6","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#向下转型"},{"categories":["programming"],"content":" 2.7 运算符 类别 运算符 算术运算符 +、-、*、/、% 复制运算符 =、+=、-=、*=、/=、%= 关系运算符 \u003e、\u003e=、\u003c、\u003c=、!= 条件运算符 \u0026\u0026、||、!、\u0026、|、^ 位运算符 \u0026、|、^、~、\u003e\u003e、\u003c\u003c、\u003e\u003e\u003e、\u003c\u003c\u003c 注意 “\u0026”和“\u0026\u0026”的区别：单与时，左边无论真假，右边都进行运算。双与时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 “|”和“||”的区别：同理，双或时，左边为真，右边不参与运算。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:7","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#运算符"},{"categories":["programming"],"content":" 2.8 表达式和三目运算符表达式是由数字、运算符和括号等组合能够计算数值的序列，按从高到低优先级依次计算。 三目运算符的格式： x ? y : z; 其中 x 为 boolean 类型表达式，若 x 为 true，则三目运算符的结果为 y 的值，否则为 z 的值。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:8","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#表达式和三目运算符"},{"categories":["programming"],"content":" 2.9 程序流程控制 顺序结构 程序从上至下依次执行，直到程序的最后。 分支结构 if-else 语句 switch-case 语句 注意 switch 语句只能使用 byte、char、short、int 四种基本类型以及它们的包装类和枚举! 循环结构 while: 不知道循环次数 do-while: 不知道循环次数但是至少执行一次 for: 知道循环次数 for (1; 2; 3) { 4; } 执行顺序：1 -\u003e 2 -\u003e 4 -\u003e 3 -\u003e 2 -\u003e 4 -\u003e 3 无限循环格式 while (true) { // do something } // or for (;;) { // do something } 控制循环结构 break: 终止本层循环 continue: 跳过本次循环 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:9","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#程序流程控制"},{"categories":["programming"],"content":" 3 方法与数组","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#方法与数组"},{"categories":["programming"],"content":" 3.1 方法的定义方法是一组为了实现特定功能的代码块的集合。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:1","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#方法的定义"},{"categories":["programming"],"content":" 3.2 方法的格式 [修饰符] 返回值类型 方法名([参数类型 形式参数1, 参数类型 形式参数2, ...]) { 执行语句; [return 返回值;] } ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:2","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#方法的格式"},{"categories":["programming"],"content":" 3.3 方法里的属性访问控制符是限定方法的可见范围。按可见范围从大到小依次是：public、protected、无、private，其中默认为无访问控制符。 属性 含义 形式参数 方法调用时接收输入的数据 实际参数 方法调用时实际传入的数据 返回值 方法执行完后返回的数据 返回值类型 返回值的数据类型 方法签名 方法名和方法的参数列表 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:3","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#方法里的属性"},{"categories":["programming"],"content":" 3.4 重载在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型或者参数顺序不同即可。 函数重载与返回值类型无关，只与参数列表有关。 // eg. public void func(int a); public int func(); public void func(int a, String s); ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:4","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#重载"},{"categories":["programming"],"content":" 3.5 可变参数从 java5 开始出现了可变参数，这是对 java 方法及数组的拓展! 可变参数定义格式： 返回值类型 方法名(参数类型 ... 形式参数) { // do something } 注意 可变参数只能出现在参数列表的最后！ 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:5","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#可变参数"},{"categories":["programming"],"content":" 3.6 数组简介数组 (Array) 是 Java 语言中内置的一种基本数据存储结构，通俗的理解，就是一组数的集合。 数组的元素编号从 0 开始，依次递增，方便访问。 必须先声明数组，再给数组分配内存。 数组对应内存中的一段连续空间。 数组元素是同一类数据类型。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:6","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#数组简介"},{"categories":["programming"],"content":" 3.7 一维数组 声明 type varName[]; // or type[] varName[]; // 推荐 初始化 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。 数组名 = new 数组类型[]{元素1，元素2，...}; // or 数组名 = {元素1，元素2，...}; // 简化 动态初始化：初始化时指定数组长度，由系统为数组元素分配初始值。 数组名 = new 数组类型[数组长度]; 注意 静态初始化和动态初始化不能同时使用！ 数组的使用 public class Demo { public static void main(String[] args) { int[] age = {1, 2, 3, 4, 5}; for (int i = 0; i \u003c age.length - 1; ++i) { System.out.println(\"age[\" + i + \"] = \" + age[i]); } } } ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:7","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#一维数组"},{"categories":["programming"],"content":" 3.8 二维数组二维数组其实是一个大的一维数组，它的每一个元素都是一个一维数组，可以看作是一张表格。 int[][] arr = {{1, 2}, {3, 4}}; // 静态初始化 int[][] arr = new int[2][2]; // 动态初始化 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:8","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#二维数组"},{"categories":["programming"],"content":" 3.9 Arrays 类 注意 使用数组工具类可以节省时间，提高效率，注意常查阅 api！ static int binarySearch(type[] a, type key); // 二分搜索法 static int binarySearch(type[] a, int fromIndex, int toIndex, type key); // 二分搜索法 static boolean[] copyOf(type[] original, int newLength); // 复制指定的数组 static byte[] copyOfRange(type[] original, int from, int to); // 将数组的指定范围复制到一个新数组 static boolean equals(type[] a, type[] a2); // 判断数组元素相等 static void fill(type[] a, type val); // 数组所有元素都赋为 val static void fill(type[] a, int fromIndex, int toIndex, type val); // 数组元素都赋为 val static void sort(type[] a); // 按升序排序 static void sort(type[] a, int fromIndex, int toIndex); // 按升序排序 static String toString(type[] a); // 返回字符串表示形式 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:9","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#arrays-类"},{"categories":["programming"],"content":" 3.10 for-each for (type varName : arrName) { // do something } ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:10","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#for-each"},{"categories":["programming"],"content":" 4 面向对象","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#面向对象"},{"categories":["programming"],"content":" 4.1 什么叫面向对象面向对象 (Object-Oriented，简称 OO) 就是一种常见的程序结构设计方法。面向对象思想的基础是将相关的数据和方法放在一起，形成一种新的复合数据类型。 面向对象的三个特征： 封装 继承 多态 面向过程强调的是具体的功能实现，面向对象强调的是具备功能的对象。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:1","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#什么叫面向对象"},{"categories":["programming"],"content":" 4.2 类类 (class) 是Java 语言的最小编程单位，也是设计和实现Java 程序的基础。 类是一组事物共有特征和功能的描述。类是抽象的，对象是具体的。 类的定义格式： [修饰符] class 类名 { 构造方法; 字段; 方法; } ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:2","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#类"},{"categories":["programming"],"content":" 4.3 构造方法 构造方法是用来构造类的实例，每一个类都有默认的无参构造方法。 字段是类或对象所包含的数据，对类状态的一种描述。 方法是类或对象的特征或行为。 作用：给类中的字段初始化，可以用来创建对象。 注意 构造方法与类名相同，没有返回值。多个构造方法以重载的形式存在。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:3","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#构造方法"},{"categories":["programming"],"content":" 4.4 staticstatic 的特点： 随着类的加载而加载 优先于对象存在 被所有对象所共享 可以直接被类名调用 注意 静态方法只能访问静态成员，但是非静态方法可以访问静态成员。 静态方法中不可以使用 this、super 关键字 利用类名调用静态 main 方法会陷入死循环，导致内存溢出，jvm 自动停止！ static 修饰的字段和方法表示属于类共用，而不属于单个实例。既可以通过类调用，也可以通过实例调用。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:4","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#static"},{"categories":["programming"],"content":" 4.5 匿名对象匿名对象是指一个没有名字的对象，只能调用一次。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:5","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#匿名对象"},{"categories":["programming"],"content":" 4.6 thisthis 表示当前对象。 在类的构造器中相互调用，this 只能写在构造方法的第一行！ TODO ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:6","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#this"},{"categories":["programming"],"content":" 5 异常处理 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:5:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#异常处理"},{"categories":["programming"],"content":" 6 常用类 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:6:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#常用类"},{"categories":["programming"],"content":" 7 线程技术 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:7:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#线程技术"},{"categories":["programming"],"content":" 8 集合框架 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#集合框架"},{"categories":["programming"],"content":" 9 IO 操作 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:9:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#io-操作"},{"categories":["programming"],"content":" 10 网络编程 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:10:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#网络编程"},{"categories":["programming"],"content":" 11 反射机制","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:11:0","series":[],"tags":["programming","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#反射机制"},{"categories":["programming"],"content":" 1 简单介绍 Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML 文档。 – 维基百科 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:0","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#简单介绍"},{"categories":["programming"],"content":" 2 基本语法","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:0","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#基本语法"},{"categories":["programming"],"content":" 2.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:1","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#标题"},{"categories":["programming"],"content":" 2.2 段落使用空行进行段落分割 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:2","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#段落"},{"categories":["programming"],"content":" 2.3 字体设置 *斜体* _斜体_ **粗体** __粗体__ ***粗斜体*** ___粗斜体___ ~~删除线~~ ==高亮== \u003cu\u003e下划线\u003c/u\u003e ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:3","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#字体设置"},{"categories":["programming"],"content":" 2.4 上标下标 上^标^ 下~标~ ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:4","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#上标下标"},{"categories":["programming"],"content":" 2.5 注释 \u003c!--注释--\u003e ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:5","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#注释"},{"categories":["programming"],"content":" 2.6 脚注 [^1] [^1]: Markdown ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:6","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#脚注"},{"categories":["programming"],"content":" 2.7 链接 地址链接 [描述](路径) \u003c链接路径\u003e 图片链接 ![描述](路径) ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:7","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#链接"},{"categories":["programming"],"content":" 2.8 分割线 **** ---- ____ ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:8","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#分割线"},{"categories":["programming"],"content":" 2.9 代码块 ```language code ``` ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:9","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#代码块"},{"categories":["programming"],"content":" 2.10 行内代码 `code` ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:10","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#行内代码"},{"categories":["programming"],"content":" 2.11 引用 \u003e 引用的文字 \u003e\u003e 嵌套的引用 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:11","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#引用"},{"categories":["programming"],"content":" 2.12 列表 无序列表 - list1 + list2 * list3 有序列表 1. list1 2. list2 3. list3 混合列表 - 1. list1 + 2. list2 * 3. list3 嵌套列表 1. list1 - list11 - list12 任务列表 - [ ] 未完成 - [x] 已完成 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:12","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#列表"},{"categories":["programming"],"content":" 2.13 表格 | head | head | | ---- | ---- | | cell | cell | | cell | cell | :- 设置内容和标题栏居左对齐 :-: 设置内容和标题栏居中对齐 -: 设置内容和标题栏居右对齐 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:13","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#表格"},{"categories":["programming"],"content":" 3 博客因为 Markdown 使用十分简单，因此决定用 Markdown 整理笔记。将 Markdown 基本语法整理出来，仅作参考！ ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:0","series":[],"tags":["programming","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#博客"}]