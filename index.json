[{"categories":["Blog"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念.","date":"2020-03-03","objectID":"/blog/001_loveit_basics/","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/"},{"categories":["Blog"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:0:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#"},{"categories":["Blog"],"content":"1 准备由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.83.0). 为什么不支持早期版本的 Hugo? 由于 WebP 图像处理 在 Hugo 0.83.0版本 中被引入, 本主题只支持高于 0.83.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:1:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#准备"},{"categories":["Blog"],"content":"2 安装以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#安装"},{"categories":["Blog"],"content":"2.1 创建你的项目Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#创建你的项目"},{"categories":["Blog"],"content":"2.2 安装主题DoIt 主题的仓库是: https://github.com/HEIGE-PCloud/DoIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#安装主题"},{"categories":["Blog"],"content":"2.3 基础配置以下是 DoIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"DoIt\" [params] # DoIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:3","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#basic-configuration"},{"categories":["Blog"],"content":"2.4 创建你的第一篇文章以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:4","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#创建你的第一篇文章"},{"categories":["Blog"],"content":"2.5 在本地启动网站使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览\" 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:5","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#在本地启动网站"},{"categories":["Blog"],"content":"2.6 构建网站当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:2:6","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#构建网站"},{"categories":["Blog"],"content":"3 配置","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:3:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#配置"},{"categories":["Blog"],"content":"3.1 网站配置除了 Hugo 全局配置 和 菜单配置 之外, DoIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # DoIt 主题版本 version = \"0.2.X\" # 网站名称 title = \"我的全新 Hugo 网站\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"black\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径, 仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 开启 PWA 支持 enablePWA = false # 版权信息 license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"DoIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\", \"fuse\") type = \"fuse\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.search.fuse] # https://fusejs.io/api/options.html isCaseSensitive = false minMatchCharLength = 2 findAllMatches = false location = 0 threshold = 0.3 distance = 100 ignoreLocation = false useExtendedSearch = false ignoreFieldNorm = false # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 主题切换模式 # 主题切换模式 (\"switch\", \"select\") themeChangeMode = \"select\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 托管服务信息 (支持 HTML 格式) # \u003ca title=\"Github Pages\" href=\"https://docs.github.com/en/pages/\" target=\"_blank\" rel=\"noopener noreffer\"\u003eGitHub Pages\u003c/a\u003e hostedOn = '' # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息, 仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 最近更新文章设置 [params.section.recentlyUpdated] enable = false rss = false days = 30 maxCount = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱, 用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL # 将你的头像文件放置于 static 或者 assets 目录下 # 文件路径是相对于 static 或者 assets 目录的 avatarURL = \"/images/avatar.webp\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" M","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:3:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#site-configuration"},{"categories":["Blog"],"content":"3.2 网站图标, 浏览器配置, 网站清单强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:3:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#网站图标-浏览器配置-网站清单"},{"categories":["Blog"],"content":"3.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, DoIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/DoIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:3:3","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#自定义样式"},{"categories":["Blog"],"content":"4 多语言和 i18nDoIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换\" 语言切换 ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:4:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#多语言和-i18n"},{"categories":["Blog"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:4:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#language-compatibility"},{"categories":["Blog"],"content":"4.2 基本配置学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为两个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:4:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#基本配置"},{"categories":["Blog"],"content":"4.3 修改默认的翻译字符串翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件, 并从 themes/DoIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:4:3","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#修改默认的翻译字符串"},{"categories":["Blog"],"content":"5 搜索 基于 Lunr.js 或 algolia, DoIt 主题支持搜索功能. ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:5:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#搜索"},{"categories":["Blog"],"content":"5.1 输出配置为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:5:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#输出配置"},{"categories":["Blog"],"content":"5.2 搜索配置基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\", \"fuse\") type = \"fuse\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.search.fuse] # https://fusejs.io/api/options.html isCaseSensitive = false minMatchCharLength = 2 findAllMatches = false location = 0 threshold = 0.3 distance = 100 ignoreLocation = false useExtendedSearch = false ignoreFieldNorm = false 怎样选择搜索引擎? 以下是两种搜索引擎的对比: fuse: 简单, 无需同步 index.json, 没有 contentLength 的限制, 性能高 lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-03","objectID":"/blog/001_loveit_basics/:5:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 基本概念","uri":"/blog/001_loveit_basics/#搜索配置"},{"categories":["Blog"],"content":"了解如何在 DoIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-04","objectID":"/blog/002_loveit_content/","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/"},{"categories":["Blog"],"content":"了解如何在 DoIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:0:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#"},{"categories":["Blog"],"content":"1 内容组织以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:1:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#contents-organization"},{"categories":["Blog"],"content":"2 作者配置我们鼓励你在 mysite/data/authors 下创建你的作者个人资料 author_name.toml. 在你的资料中, 你可以添加个人链接, 邮箱, 以及支持 i18n 的姓名. 以下是 Alice.toml 的示例: link = \"https://alice.example.com\" email = \"alice@example.com\" name = \"Alice\" [zh-cn] name = \"爱丽丝\" 在创建作者个人资料后, 您可以在文章的前置参数中指定您的姓名. 之后, 该文章将自动著上你的名字, 并可以根据作者进行分类. ---authors:[Alice]--- 您也可以为一篇文章注明多个作者. ---authors:[Alice, Bob, Catherine]--- ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:2:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#author-setup"},{"categories":["Blog"],"content":"3 前置参数Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthors:[]description:\"\"license:\"\"images:[]tags:[]categories:[]series:[]series_weight:1seriesNavigation:truefeaturedImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truelinkToSource:falselinkToEdit:falselinkToReport:falserssFullText:falselicense:''toc:enable:trueauto:truecode:copy:true# ...table:sort:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...outdatedArticleReminder:enable:false# ...sponsor:enable:false# ...--- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. authors: 文章作者. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. series: 文章所属的系列. series_weight: 自定义文章在系列中的位置. seriesNavigation: 是否使用系列导航. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. linkToSource: 如果设为 false, 则关闭页脚 view source 的链接. 你可以将其设置为一个指向文章原始文件的链接. 使用魔法变量 {path} 来获取文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.en.md. linkToEdit: 如果设为 false, 则关闭页脚 编辑此页 的链接. 你可以将其设置为一个用于编辑这个页面的链接. 使用魔法变量 {path} 来获取这篇文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.zh-cn.md. linkToReport: 如果设为 false, 则关闭页脚 报告问题 的链接. 你可以将其设置为一个用于报告此页面中错误的链接. 使用魔法变量 {path} 来获取文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.en.md, 使用 {title} 来获取文章的标题, 这篇文章的 {title} 为 Theme Documentation - Content, 使用 {url} 来获取文章的链接, 这篇文章的 {url} 为 https://hugodoit.pages.dev/theme-documentation-content/. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. pageStyle: 调整页面样式, 可选择\"normal\"或\"wide\". license: 许可协议信息 (支持 HTML 格式). toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. table: 和 网站配置 中的 params.page.table 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. outdatedArticleReminder: 和 网站配置 中的 params.page.outdatedArticleReminder 部分相同. sponsor: 和 网站配置 中的 params.sponsor 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:3:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#front-matter"},{"categories":["Blog"],"content":"4 内容摘要DoIt 主题使用内容摘要在主页中显示大致文章信息. Hugo 支持生成文章的摘要. 文章摘要预览\" 文章摘要预览 ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#内容摘要"},{"categories":["Blog"],"content":"4.1 自动摘要拆分默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能, 请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#自动摘要拆分"},{"categories":["Blog"],"content":"4.2 手动摘要拆分另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#手动摘要拆分"},{"categories":["Blog"],"content":"4.3 前置参数摘要你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:3","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#前置参数摘要"},{"categories":["Blog"],"content":"4.4 使用文章描述作为摘要你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 DoIt 主题会将你的文章描述作为摘要. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:4","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#使用文章描述作为摘要"},{"categories":["Blog"],"content":"4.5 摘要选择的优先级顺序由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:4:5","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#摘要选择的优先级顺序"},{"categories":["Blog"],"content":"5 Markdown 基本语法这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:5:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#markdown-基本语法"},{"categories":["Blog"],"content":"6 Markdown 扩展语法DoIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#extended-markdown-syntax"},{"categories":["Blog"],"content":"6.1 Emoji 支持这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#emoji-支持"},{"categories":["Blog"],"content":"6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#数学公式"},{"categories":["Blog"],"content":"6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C - 2 CO} $$ $$ \\ce{Hg^2+ -[I-] HgI2 -[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C - 2 CO} $$ $$ \\ce{Hg^2+ -[I-] HgI2 -[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#公式块"},{"categories":["Blog"],"content":"6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C - 2 CO} $$ $$ \\ce{Hg^2+ -[I-] HgI2 -[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C - 2 CO} $$ $$ \\ce{Hg^2+ -[I-] HgI2 -[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#行内公式"},{"categories":["Blog"],"content":"6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C - 2 CO} $$ $$ \\ce{Hg^2+ -[I-] HgI2 -[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C - 2 CO} $$ $$ \\ce{Hg^2+ -[I-] HgI2 -[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#copy-tex"},{"categories":["Blog"],"content":"6.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 6.2.1 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 6.2.2 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. 6.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 6.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C - 2 CO} $$ $$ \\ce{Hg^2+ -[I-] HgI2 -[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C - 2 CO} $$ $$ \\ce{Hg^2+ -[I-] HgI2 -[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#mhchem"},{"categories":["Blog"],"content":"6.3 字符注音或者注释DoIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:3","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#ruby"},{"categories":["Blog"],"content":"6.4 分数 DoIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:4","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#fraction"},{"categories":["Blog"],"content":"6.5 Font AwesomeDoIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:5","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#fontawesome"},{"categories":["Blog"],"content":"6.6 转义字符在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧 这个方法可以间接解决一个还未解决的 Hugo 的 issue. 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-04","objectID":"/blog/002_loveit_content/:6:6","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内容","uri":"/blog/002_loveit_content/#escape-character"},{"categories":["Blog"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/"},{"categories":["Blog"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:0:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#"},{"categories":["Blog"],"content":"1 figurefigure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.webp\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.webp\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:1:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#figure"},{"categories":["Blog"],"content":"2 gistgist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:2:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#gist"},{"categories":["Blog"],"content":"3 highlighthighlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:3:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#highlight"},{"categories":["Blog"],"content":"4 paramparam 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:4:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#param"},{"categories":["Blog"],"content":"5 ref 和 relrefref 和 relref 的文档 ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:5:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#ref-and-relref"},{"categories":["Blog"],"content":"6 tweettweet 的文档 一个 tweet 示例: {{\u003c tweet 877500564405444608 \u003e}} ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:6:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#tweet"},{"categories":["Blog"],"content":"7 vimeovimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:7:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#vimeo"},{"categories":["Blog"],"content":"8 youtubeyoutube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-05","objectID":"/blog/003_loveit_builtin_shortcodes/:8:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 内置 Shortcodes","uri":"/blog/003_loveit_builtin_shortcodes/#youtube"},{"categories":["Blog"],"content":"DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/"},{"categories":["Blog"],"content":"DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:0:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#"},{"categories":["Blog"],"content":"1 style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:1:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#style"},{"categories":["Blog"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上, 会有一行提示): Upstage ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:2:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#link"},{"categories":["Blog"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.webp\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.webp\" src_l=\"/images/lighthouse-large.webp\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\" Lighthouse (image) ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:3:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#image"},{"categories":["Blog"],"content":"4 admonitionadmonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:4:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#admonition"},{"categories":["Blog"],"content":"5 mermaidmermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#mermaid"},{"categories":["Blog"],"content":"5.1 流程图一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}}graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#flowchart"},{"categories":["Blog"],"content":"5.2 时序图一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}}sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#sequence-diagram"},{"categories":["Blog"],"content":"5.3 甘特图一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}}gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:3","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#gantt"},{"categories":["Blog"],"content":"5.4 类图一个 类图 mermaid 示例: {{\u003c mermaid \u003e}}classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:4","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#class-diagram"},{"categories":["Blog"],"content":"5.5 状态图一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}}stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:5","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#state-diagram"},{"categories":["Blog"],"content":"5.6 Git 图一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}}gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:6","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#git-graph"},{"categories":["Blog"],"content":"5.7 饼图一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}}pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:5:7","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#pie"},{"categories":["Blog"],"content":"6 echartsECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折线统计图top:2%left:centertooltip:trigger:axislegend:data:- 邮件营销- 联盟广告- 视频广告- 直接访问- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存为图片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:邮件营销type:linestack:总量data:- 120- 132- 101- 134- 90- 230- 210- name:联盟广告type:linestack:总量data:- 220- 182- 191- 234- 290- 330- 310- name:视频广告type:linestack:总量data:- 150- 232- 201- 154- 190- 330- 410- name:直接访问type:linestack:总量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:总量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:6:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#echarts"},{"categories":["Blog"],"content":"7 mapbox Mapbox GL JS 是一个 JavaScript 库, 它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:7:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#mapbox"},{"categories":["Blog"],"content":"8 musicmusic shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#music"},{"categories":["Blog"],"content":"8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.webp\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#custom-music-url"},{"categories":["Blog"],"content":"8.2 音乐平台 URL 的自动识别music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#automatic-identification"},{"categories":["Blog"],"content":"8.3 自定义音乐平台, 类型和 IDmusic shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:3","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#custom-server"},{"categories":["Blog"],"content":"8.4 其它参数music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:8:4","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#other-parameters"},{"categories":["Blog"],"content":"9 aplayer and audio 如果你需要针对音乐播放器的更多自定义选项（如自定义歌单，迷你模式，自定义音乐类型以及更多…），你可以使用 aplayer shortcode 配合 audio shortcode 以发挥 APlayer.js 的全部功能。 aplayer shortcode 用于创建一个 APlayer 播放器实例，audio shortcode 则用于设置音乐文件的相关信息。请查看 APlayer.js 的文档 来了解所有的可配置项。 一个 aplayer 和 audio 的示例： {{\u003c aplayer fixed=false mini=false autoplay=false theme=\"#b7daff\" loop=\"all\" order=\"list\" preload=\"auto\" volume=0.7 mutex=true lrcType=1 listFolded=false listMaxHeight=\"\" storageName=\"aplayer-setting\" \u003e}} {{\u003c audio name=\"Wavelength\" artist=\"oldmanyoung\" url=\"/music/Wavelength.mp3\" cover=\"/images/Wavelength.webp\" /\u003e}} {{\u003c audio name=\"Wavelength\" artist=\"oldmanyoung\" url=\"/music/Wavelength.mp3\" cover=\"/images/Wavelength.webp\" \u003e}} [00:00.00]APlayer audio1 [00:04.01]is [00:08.02]amazing {{\u003c /audio \u003e}} {{\u003c /aplayer \u003e}} 呈现的输出效果如下： 需要注意的是，这两个 shortcodes 并不能单独使用，并且必须使用命名参数来设置它们的属性。 如果你将 LRC 放置于 audio shortcode 之中，它会通过 JS 字符串方式传递给 APlayer，所以你需要将 lrcType 设置为 1。如果你通过配置 lrc 参数的方式来设置 LRC 文件的链接，那么它将会被通过 LRC 文件方式传递给 APlayer，则 lrcType 需要被设置为 3。 ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:9:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#aplayer-and-audio"},{"categories":["Blog"],"content":"10 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:10:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#bilibili"},{"categories":["Blog"],"content":"11 typeittypeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#typeit"},{"categories":["Blog"],"content":"11.1 简单内容允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#simple-content"},{"categories":["Blog"],"content":"11.1 简单内容允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:1","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#id-13 class="},{"categories":["Blog"],"content":"11.2 代码内容代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:2","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#code-content"},{"categories":["Blog"],"content":"11.3 分组内容默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:11:3","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#code-content"},{"categories":["Blog"],"content":"12 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Just DoIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:12:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#script"},{"categories":["Blog"],"content":"13 friend friend shortcode 用来在你的页面上插入友链. friend shortcode 有以下命名参数: name [必需] (第一个位置参数) 友站的名称. url [必需] (第二个位置参数) 友站的链接. avatar [必需] (第三个位置参数) 友站的头像. bio [必需] (第四个位置参数) 友站的简介. 一个 friend 示例: {{\u003c friend \"PCloud\" \"https://github.com/HEIGE-PCloud/\" \"https://avatars.githubusercontent.com/u/52968553?v=4\" \"This is PCloud~💤\" \u003e}} 或者 {{\u003c friend name=\"PCloud\" url=\"https://github.com/HEIGE-PCloud/\" avatar=\"https://avatars.githubusercontent.com/u/52968553?v=4\" bio=\"This is PCloud~💤\" \u003e}} 呈现的输出效果如下: PCloud This is PCloud~💤 ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:13:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#friend"},{"categories":["Blog"],"content":"14 showcase showcase 用于在页面上插入一个个人项目的展示柜. showcase shortcode 有以下命名参数: title [required] (第一个位置参数) 项目名称. summary [required] (第二个位置参数) 项目简介. image [required] (第三个位置参数) 预览图的链接. link [required] (第四个位置参数) 项目主页的链接. column [optional] (fifth positional parameter) 这个参数定义一行显示几个 showcase. 默认的值是 2, 默认一行显示两个 showcase. 你可以将它改为 1, 2 或 3. 需要注意的是, 当用户使用小屏幕访问网站时, 每行显示的 showcase 数量将会被自动调整以保证最好的体验. 一个 showcase 示例: {{\u003c showcase title=\"Theme Documentation - Basics\" summary=\"Discover what the Hugo - DoIt theme is all about and the core-concepts behind it.\" image=\"/theme-documentation-basics/featured-image.webp\" link=\"/theme-documentation-basics\" \u003e}} Or {{\u003c showcase \"Theme Documentation - Basics\" \"Discover what the Hugo - DoIt theme is all about and the core-concepts behind it.\" \"/theme-documentation-basics/featured-image.webp\" \"/theme-documentation-basics\" \u003e}} 呈现的输出效果如下: 主题文档 - 基本概念 探索 Hugo - DoIt 主题的全部内容和背后的核心概念. 阅读全文 ","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:14:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#showcase"},{"categories":["Blog"],"content":"15 math math 用于插入数学公式. 它可以阻止 Goldmark 将数学表达式中的特殊字符解析为 HTML 从而避免很多问题. 在 math 中, 你不再需要转义特殊字符. 一个 math 示例: {{\u003c math \u003e}}$\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}${{\u003c /math \u003e}} Or {{\u003c math \u003e}} $$\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}$$ {{\u003c /math \u003e}} 呈现的输出效果如下: $\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}$ $$\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}$$","date":"2020-03-06","objectID":"/blog/004_loveit_extended_shortcodes/:15:0","series":["- LoveIt"],"tags":["Blog","Hugo","LoveIt"],"title":"LoveIt 主题文档 - 扩展 Shortcodes","uri":"/blog/004_loveit_extended_shortcodes/#math"},{"categories":["国妇婴"],"content":"1 产褥期什么是产褥期？ 胎儿出生后，胎盘自母体排出，产妇进入产后恢复阶段，医学上把分娩后6周内这段时间称为产褥期。 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:1:0","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#产褥期"},{"categories":["国妇婴"],"content":"1.1 产后注意事项分娩后首次排尿要今早 产后 4 - 6 小时排尿，防止产后出血 分娩后为何还会有腹痛？ 产后由于子宫收缩而引起的腹痛，出现在产后 1 - 2 日，持续 2 - 3 日 分娩后何时下床？ 顺产后尽早下床，剖腹产导尿管拔出后（留置导尿 24 小时）下床 产后恶露何时干净？ 产后阴道排出血性分泌物，3 - 4 天量多，一周后量少，产后 2 月内干净。 产后为何会有低热？ 疲劳热、吸收热、泌乳热 产后出汗是虚吗？ 产后出汗多是正常的生理代谢现象，产后 1 - 3 天明显，产后 1 周左右好转。 产后注意伤口清洁 剖腹产伤口敷料保留一周，会阴侧切伤口注意清洁。 提倡母乳喂养 乳房充血期不宜喝过多浓汤，不宜频繁使用吸奶器，应尽早频繁喂哺宝宝。新生儿一小时左右喂一次 与宝宝同步休息，预防产后抑郁 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:1:1","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#产后注意事项"},{"categories":["国妇婴"],"content":"1.2 产后生活指导 刷牙：临睡前必须要刷牙，注意漱口水不能代替刷牙 洗头洗澡：顺产后 3 - 4 天可洗，剖腹产二周后可洗 胸罩：产后佩戴胸罩可以保护乳头 通风开窗：每天通风两次，每次 15 分钟 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:1:2","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#产后生活指导"},{"categories":["国妇婴"],"content":"1.3 产后运动 深呼吸运动 仰卧，深吸气，收腹，然后呼气 提肛运动 仰卧，两臂直放于身旁，进行提肛运动，每次持续 5 秒。 膝关节运动 仰卧，两臂直放于身旁，两膝关节轮流屈伸（剖宫产）或双腿并拢屈伸膝关节（阴道分娩）。 抬腿运动 仰卧，两臂直放于身旁，双腿轮流上举和并举，与身体呈直角。 骨盆运动 仰卧，配合呼吸骨盆后倾，臀部上抬，每次持续 3 秒。 腹肌运动 仰卧屈膝，配合呼吸双手触膝 8 ～ 10 次，然后左手触右膝、右手触左膝 8 ～ 10 次（剖宫产两周后进行）。 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:1:3","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#产后运动"},{"categories":["国妇婴"],"content":"1.4 产后避孕的重要性 6 周内禁止性生活 产后 40% ～ 57% 的妇女会在分娩 6 周后恢复性生活 产后如果未哺乳，可在产后 4 周左右出现排卵。大多数的排卵恢复发生在第 1 次月经前。 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:1:4","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#产后避孕的重要性"},{"categories":["国妇婴"],"content":"1.5 产后避孕的方法 宫内节育器 非哺乳产妇，产后 48h 内可立即以及产后 4 周以上均可放置 1UC。 哺乳产妇，产后 48h 内或产后 4 周后放置。 如有产褥期感染，则严禁放置。 屏障避孕法 包括避孕套、阴道隔膜和子宫颈帽等，产后可立即使用，但由于受到使用者依从性，特别是配偶能否坚持和正确使用因素的影响，属于低效避孕方法，不建议作为首选推荐。 安全期避孕 体外射精 紧急避孕药 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:1:5","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#产后避孕的方法"},{"categories":["国妇婴"],"content":"2 母乳喂养","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:0","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#母乳喂养"},{"categories":["国妇婴"],"content":"2.1 母乳喂养好处 对孩子的好处 适合婴儿生长发育 容易消化和吸收 最理想食物 增强抵抗力 有助牙床发育 有助大脑发育 预防儿童肥胖症 对母亲的好处 预防乳腺癌 有助于子宫收缩减少出血 预防骨质疏松症 促进产后体重恢复 有助避孕 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:1","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#母乳喂养好处"},{"categories":["国妇婴"],"content":"2.2 乳汁的转变 初乳 产后数天分泌 高蛋白质、高维生素，容易消化吸收 含有大量抗体 成人人乳 产后 2 星期开始分泌 前乳 - 较稀，高蛋白、高乳糖及高矿物质 后乳 - 含高脂肪及高热量 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:2","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#乳汁的转变"},{"categories":["国妇婴"],"content":"2.3 母乳喂养方法 尽早开奶 产后尽早给孩子吸吮乳房 尽快学习吸吮乳头的动作 能刺激乳汁的分泌 尽勤喂奶 无需时间表 按需喂哺 不要等到孩子饿哭才喂 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:3","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#母乳喂养方法"},{"categories":["国妇婴"],"content":"2.4 宝宝胃口大小 出生时间 胃容量 类似 出生第 1 天 5 - 7 ml 弹珠 出生第 2 天 10 - 13ml - 出生第 3 天 22 - 27ml 乒乓球 出生第 4 天 36 - 46ml - 出生第 5 天 43 - 57ml 鸡蛋 按需哺乳，睡眠大于 3 小时需要唤醒喂哺！ ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:4","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#宝宝胃口大小"},{"categories":["国妇婴"],"content":"2.5 识别宝宝饥饿 张着嘴，寻找乳房 发出吸吮动作或响声：咂嘴唇、伸舌头 吃手 烦躁、哭闹 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:5","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#识别宝宝饥饿"},{"categories":["国妇婴"],"content":"2.6 母乳喂养成功要素 早接触、早吸吮 产后 72 小时内是母乳喂养成功的关键时期 早吸吮是保持乳腺不断泌乳的关键 人工奶头或杯子喂养会产生乳头错觉 人工奶头或杯子影响新生儿牙床发育 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:6","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#母乳喂养成功要素"},{"categories":["国妇婴"],"content":"2.7 喂奶前的准备 换尿片 洗手 舒适位置 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:7","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#喂奶前的准备"},{"categories":["国妇婴"],"content":"2.8 喂哺姿势 摇篮式 环抱式 侧卧式 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:8","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#喂哺姿势"},{"categories":["国妇婴"],"content":"2.9 宝宝吸吮的正确口型 头和身体成一条线 胸贴胸，腹贴腹，下额贴乳房 将乳晕送至婴儿口中，勿堵住婴儿鼻子 婴儿上下唇均向外 初生婴儿需要托住头部、颈部、背和臀部 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:9","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#宝宝吸吮的正确口型"},{"categories":["国妇婴"],"content":"2.10 母乳保存方法 保存温度 保存时限 室温 2 小时 冰箱 4 度 24 小时 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:10","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#母乳保存方法"},{"categories":["国妇婴"],"content":"2.11 上班如何坚持母乳喂养 上班前及回家后马上直接哺乳，增加亲喂及挤奶的次数。 上班时携带保温桶，里面存放消过毒的储奶袋，每 3 小时挤奶一次，下班后挤出的奶带回家，放在冰箱里。乳汁吸出后，经过 4 度冷藏，必须在 12 小时内喂完。若存储时间久，需采用冷冻方式。 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:11","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#上班如何坚持母乳喂养"},{"categories":["国妇婴"],"content":"2.12 特殊情况的母乳喂养 产后大出血 可协助母亲喂养 重度子痫前期 不可过度疲劳，以免加重病情 肝炎 甲型肝炎暂停母乳喂养 乙型肝炎在新生儿接种乙肝疫苗之后可以母乳喂养 丙肝肝炎不影响母乳喂养 HIV 避免母乳喂养 结核 患有活动性结核的母亲不应该哺乳 妊娠糖尿病 不影响母乳喂养，注意控制血糖 甲状腺疾病 精神疾病 产褥期抑郁症 如需药物治疗应暂停母乳喂养 ","date":"2022-03-27","objectID":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/:2:12","series":["- 国妇婴"],"tags":["国妇婴","怀孕","产褥期","母乳喂养"],"title":"产褥期保健和母乳喂养","uri":"/blog/003_%E4%BA%A7%E8%A4%A5%E6%9C%9F%E4%BF%9D%E5%81%A5%E5%92%8C%E6%AF%8D%E4%B9%B3%E5%96%82%E5%85%BB/#特殊情况的母乳喂养"},{"categories":["国妇婴"],"content":"1 数胎动 正常胎动：1 小时大于 3 次，2 小时胎动大于 10 次。 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:1:0","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#数胎动"},{"categories":["国妇婴"],"content":"1.1 数胎动方法 每天数 1 次，1 次 1 小时，晚上 6 - 10 点为宜。 大于 37 周后加强检测，增加检测次数 孕 30 周开始记录胎动 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:1:1","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#数胎动方法"},{"categories":["国妇婴"],"content":"1.2 注意事项出现以下情况，应及时就诊： 2 小时胎动小于 10 次 1 小时胎动小于 3 次 和平时胎动次数比较减少 50% 以上 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:1:2","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#注意事项"},{"categories":["国妇婴"],"content":"1.3 听胎心 每天监听 1 - 2 次，每次 2 - 3 分钟 正常胎心： 100 - 160 次/分钟 规律、强弱一致 使用家用胎心仪 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:1:3","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#听胎心"},{"categories":["国妇婴"],"content":"2 孕晚期可能并发症","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:2:0","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#孕晚期可能并发症"},{"categories":["国妇婴"],"content":"2.1 妊娠期高血压疾病表现为：高血压、蛋白尿或水肿，严重者出现头昏、胸闷、抽筋、昏迷等一系列症状。 预防： 孕晚期注意休息，有足够的睡眠 避免精神紧张、低盐饮食 定期检查，重视血压、体重、血尿常规 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:2:1","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#妊娠期高血压疾病"},{"categories":["国妇婴"],"content":"2.2 早产早产是指妊娠 28 周至不满 37 足周间分娩。约占分娩总数的 5% - 15%? 常见原因： 下生殖器及泌尿道感染 胎膜早破、羊水过多、多胎妊娠、前置胎盘、胎盘早剥等 妊娠合并症与并发症 表现为：主要是子宫收缩，最初为不规则宫缩，并伴有少量阴道分泌物、胎膜早破。 预防： 定期检查，重视可能因素 避免精神压力过大 避免过度疲劳（32 周后不宜外出旅游） 重视 37 周前的阴道流血，及时就诊 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:2:2","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#早产"},{"categories":["国妇婴"],"content":"2.3 深静脉血栓静脉血栓栓塞症（VTE）是指静脉血液斑块形成，最常见于下肢的深静脉内，被称为深静脉血栓（DVT）。 预防： 分娩后当天，产妇早下床活动和避免脱水；并尽可能采用被动运动、按摩、弹力袜、机械泵等物理方法促进外周血液循环 药物方法包括小剂量低分子肝素皮下注射的方法，生物利用度高，抗血栓作用强，抗凝血作用弱，不宜产生血小板减少和骨质疏松，可减少出血风险，安全可靠 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:2:3","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#深静脉血栓"},{"categories":["国妇婴"],"content":"3 入院准备工作 妈妈用品 外套、出院衣物、哺乳室文胸、产妇卫生垫、一次性床垫、两条毛巾和两个脸盆（上下分开）、梳子、肥皂（含 2% 洗必泰）、防滑拖鞋、牙刷、牙膏、漱口水、卫生纸、餐巾纸、湿巾纸、带吸管的杯子、可加热的饭盒、剃刀、产褥期护理垫。 备注：肥皂只有剖腹产需要，具有消毒功能。便盆只有剖腹产需要。 宝宝用品 纸尿布、新生儿湿巾纸、口水巾若干条、出院的宝宝衣服、袜子、帽子和包被、硅胶软勺、吸奶器。 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:3:0","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#入院准备工作"},{"categories":["国妇婴"],"content":"4 出生医学证明办理攻略办理流程： 在国妇婴掌上医院微信公众号上进行预约，需要绑定新生儿母亲就诊卡。 自行准备好相关证件复印件并填写完整出生证首次签发表格。 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:4:0","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#出生医学证明办理攻略"},{"categories":["国妇婴"],"content":"5 住院产后住院天数 正常情况下，顺产 2 - 3 天，剖腹产 3 - 4 天 产科床位费用 普通产科病房（6 - 10 楼） 6 人间，58 元/天，可报销医保 特需病房（6 - 10 楼） 2 人间，800 元/天 1 人间，2000 元/天 贵宾楼（15 楼） 1 人间 三种入院征兆： 有规律的宫缩 见红 破水 ","date":"2022-03-27","objectID":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/:5:0","series":["- 国妇婴"],"tags":["国妇婴","怀孕","孕晚期"],"title":"孕晚期保健","uri":"/blog/002_%E5%AD%95%E6%99%9A%E6%9C%9F%E4%BF%9D%E5%81%A5/#住院"},{"categories":["Android"],"content":"1 设备没有权限执行 adb devices 命令输出 List of devices attached 3ed62e70 no permissions ","date":"2022-03-24","objectID":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/:1:0","series":[],"tags":["Android","adb"],"title":"adb 设备无法识别","uri":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/#设备没有权限"},{"categories":["Android"],"content":"2 查看 USB 设备执行 lsusb 命令输出 Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 094: ID 17ef:6050 Lenovo Bus 001 Device 124: ID 05c6:901d Qualcomm, Inc. -\u003e 新增 usb 设备 Bus 001 Device 002: ID 060b:7a03 Solid Year Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub ","date":"2022-03-24","objectID":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/:2:0","series":[],"tags":["Android","adb"],"title":"adb 设备无法识别","uri":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/#查看-usb-设备"},{"categories":["Android"],"content":"3 配置 USB 设备权限修改 /etc/udev/rules.d/android.rules 文件内容 SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"05c6\", ATTRS{idProduct}==\"901d\", MODE=\"0666\" ","date":"2022-03-24","objectID":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/:3:0","series":[],"tags":["Android","adb"],"title":"adb 设备无法识别","uri":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/#配置-usb-设备权限"},{"categories":["Android"],"content":"4 使配置生效执行 sudo service udev restart 命令 ","date":"2022-03-24","objectID":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/:4:0","series":[],"tags":["Android","adb"],"title":"adb 设备无法识别","uri":"/blog/001_adb%E8%AE%BE%E5%A4%87%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB/#使配置生效"},{"categories":["Android"],"content":"1 adb 命令安装 查看当前设备已安装包名 adb shell pm list packages 安装 APK adb install -r app-debug.apk 卸载 APK adb uninstall com.test.demo ","date":"2022-03-24","objectID":"/blog/002_android%E5%AE%89%E8%A3%85apk/:1:0","series":[],"tags":["Android","adb","apk"],"title":"Android 安装 APK","uri":"/blog/002_android%E5%AE%89%E8%A3%85apk/#adb-命令安装"},{"categories":["Android"],"content":"2 pm 命令安装先用 adb 命令将安装包推到机器中 查看当前设备已安装包名 pm list packages 安装 APK pm install -r app-debug.apk 卸载 APK pm uninstall com.test.demo ","date":"2022-03-24","objectID":"/blog/002_android%E5%AE%89%E8%A3%85apk/:2:0","series":[],"tags":["Android","adb","apk"],"title":"Android 安装 APK","uri":"/blog/002_android%E5%AE%89%E8%A3%85apk/#pm-命令安装"},{"categories":["Android"],"content":"1 Android 打包 aar 运行编译命令 ./gradlew build ","date":"2022-03-24","objectID":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/:1:0","series":[],"tags":["Android","aar","Gradle"],"title":"Android 打包 aar 并集成","uri":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/#android-打包-aar"},{"categories":["Android"],"content":"2 Gradle 本地集成 aar 将生成的 aar 放到 app/libs 目录下 修改 app/build.gradle 文件 android { ... repositories { flatDir { dirs 'libs' } } } dependencies { ... implementation(name:'aar_name', ext:'aar') } 重新编译 app ","date":"2022-03-24","objectID":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/:2:0","series":[],"tags":["Android","aar","Gradle"],"title":"Android 打包 aar 并集成","uri":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/#gradle-本地集成-aar"},{"categories":["Android"],"content":"3 Gradle 迁移 Maven 构建 修改 app/build.gradle 文件 android { ... repositories { maven { url 'https://nexus2.com/repository/maven/' } } } dependencies { ... implementation 'com.demo:demolib:1.0.0-20220211.010237-47@aar' } 重新编译 app ","date":"2022-03-24","objectID":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/:3:0","series":[],"tags":["Android","aar","Gradle"],"title":"Android 打包 aar 并集成","uri":"/blog/003_android%E6%89%93%E5%8C%85aar%E5%B9%B6%E9%9B%86%E6%88%90/#gradle-迁移-maven-构建"},{"categories":["开发配置"],"content":"1 Ubuntu 安装 git 命令 apt-get install git ","date":"2022-03-24","objectID":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":[],"tags":["开发配置","git"],"title":"git 使用和配置","uri":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ubuntu-安装-git-命令"},{"categories":["开发配置"],"content":"2 git 配置文件git 配置文件有三个： /etc/gitconfig 是系统级配置文件，使用 git config --system 命令进行修改。 ~/.gitconfig 或 ~/.config/git/config 是用户级配置文件，使用 git config --global 命令进行修改。 local_dir/.git/config 是仓库级配置文件，使用 git config --local 命令进行修改。 ","date":"2022-03-24","objectID":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":[],"tags":["开发配置","git"],"title":"git 使用和配置","uri":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#git-配置文件"},{"categories":["开发配置"],"content":"2.1 设置用户信息 $ git config --global user.name \"username\" $ git config --global user.email username@example.com ","date":"2022-03-24","objectID":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:1","series":[],"tags":["开发配置","git"],"title":"git 使用和配置","uri":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#设置用户信息"},{"categories":["开发配置"],"content":"2.2 设置 git 默认编辑器 git config --global core.editor emacs ","date":"2022-03-24","objectID":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:2","series":[],"tags":["开发配置","git"],"title":"git 使用和配置","uri":"/blog/001_git%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#设置-git-默认编辑器"},{"categories":["开发配置"],"content":"1 简单介绍 Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS、Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:1:0","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#简单介绍"},{"categories":["开发配置"],"content":"2 基本语法 Workspace：工作区 Index/Stage：暂存区 Repository：本地仓库 Remote：远程仓库 ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:0","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#基本语法"},{"categories":["开发配置"],"content":"2.1 新建仓库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:1","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#新建仓库"},{"categories":["开发配置"],"content":"2.2 配置Git 有三种级别类型的配置文件，名字为 .gitconfig。 系统级：/etc/gitconfig，使用 --system 选项进行读写 用户级：~/.gitconfig，使用 --global 选项进行读写 仓库级：仓库目录/.git/config，使用 --local 选项进行读写 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:2","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#配置"},{"categories":["开发配置"],"content":"2.3 增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:3","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#增加删除文件"},{"categories":["开发配置"],"content":"2.4 代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:4","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#代码提交"},{"categories":["开发配置"],"content":"2.5 分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:5","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#分支"},{"categories":["开发配置"],"content":"2.6 标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:6","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#标签"},{"categories":["开发配置"],"content":"2.7 查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:7","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#查看信息"},{"categories":["开发配置"],"content":"2.8 远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:8","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#远程同步"},{"categories":["开发配置"],"content":"2.9 撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:9","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#撤销"},{"categories":["开发配置"],"content":"2.10 其他 # 生成一个可供发布的压缩包 $ git archive ","date":"2022-03-24","objectID":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/:2:10","series":[],"tags":["开发配置","git"],"title":"git 命令详解","uri":"/blog/003_git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#其他"},{"categories":["Android"],"content":"1 显示的错误信息 javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 导致这个错误的原因是没有有效的证书，因此导入相应的证书就可以正常访问了。 证书可以通过网站 -\u003e Certificate -\u003e Details -\u003e Export 获取。 ","date":"2022-03-24","objectID":"/blog/004_jdk%E5%AF%BC%E5%85%A5ca%E8%AF%81%E4%B9%A6/:1:0","series":[],"tags":["Android","jdk","CA"],"title":"JDK 导入 CA 证书","uri":"/blog/004_jdk%E5%AF%BC%E5%85%A5ca%E8%AF%81%E4%B9%A6/#显示的错误信息"},{"categories":["Android"],"content":"2 证书管理 导入证书 keytool -import -keystore ~/Opt/jdk1.8.0_181/jre/lib/security/cacerts -alias ca -storepass changeit -keypass changeit -file ~/Downloads/ca.crt 删除证书 keytool -delete -keystore ~/Opt/jdk1.8.0_181/jre/lib/security/cacerts -alias ca -storepass changeit 查看证书 keytool -list -keystore ~/Opt/jdk1.8.0_181/jre/lib/security/cacerts -alias ca ","date":"2022-03-24","objectID":"/blog/004_jdk%E5%AF%BC%E5%85%A5ca%E8%AF%81%E4%B9%A6/:2:0","series":[],"tags":["Android","jdk","CA"],"title":"JDK 导入 CA 证书","uri":"/blog/004_jdk%E5%AF%BC%E5%85%A5ca%E8%AF%81%E4%B9%A6/#证书管理"},{"categories":["开发配置"],"content":"1 Ubuntu 安装 ssh 命令 apt-get install openssh-server ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:1:0","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ubuntu-安装-ssh-命令"},{"categories":["开发配置"],"content":"2 ssh 使用和配置","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:0","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-使用和配置"},{"categories":["开发配置"],"content":"2.1 ssh 配置 生成 ssh 密钥和公钥 ssh-keygen -t rsa 其中在 ~/.ssh 文件夹下，id_rsa 是私钥，id_rsa.pub 是公钥。 将公钥放在服务器上 测试 ssh 连接 ssh -p port user@hostname 连接成功会出现 Welcome to Gerrit Code Review 字样！ ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:1","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-配置"},{"categories":["开发配置"],"content":"2.2 ssh 和 sshd/etc/ssh/ssh_config 和 /etc/ssh/sshd_config 都是 ssh 的配置文件，区别在于 ssh_config 是客户端的配置文件，sshd_config 是服务端的配置文件。 /etc/ssh/sshd_config 部分文件内容 Port 22 # 默认端口号为 22 PermitRootLogin no # 禁止 root 用户登录 X11Forwarding yes # 允许 X11 图形化 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:2","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-和-sshd"},{"categories":["开发配置"],"content":"2.3 ssh 服务端控制命令 service sshd start # 启动 sshd service sshd stop # 停止 sshd service sshd restart # 重启 sshd ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:3","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-服务端控制命令"},{"categories":["开发配置"],"content":"2.4 ssh config 配置文件修改 ~/.ssh/config 文件设置别名 Host Alias HostName ip[192.168.XXX.XXX] Port 22 User zhengqijun IdentityFile ~/.ssh/id_rsa 直接输入 ssh Alias 命令就可以直接连接了！十分方便！ ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:4","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-config-配置文件"},{"categories":["开发配置"],"content":"2.5 ssh 免密登录将 ssh 生成的公钥拷贝到目标机的 ~/.ssh/authorized_keys 中，就可以实现免密登录了。ssh 连接连密码都省了，偷懒小能手！ ssh-copy-id user@hostname ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:2:5","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-免密登录"},{"categories":["开发配置"],"content":"3 传输文件","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:3:0","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#传输文件"},{"categories":["开发配置"],"content":"3.1 scp 传输文件scp 是基于 ssh 登陆进行安全的远程文件拷贝命令，所以可以通过网络传输文件。 scp local_file remote_username@remote_ip:remote_folder # 传输本地文件到目标机 scp -r local_folder remote_username@remote_ip:remote_folder # 传输本地目录到目标机 scp remote_username@remote_ip:remote_folder local_file # 传输本地文件到目标机 scp -r remote_username@remote_ip:remote_folder local_folder # 传输本地目录到目标机 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:3:1","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#scp-传输文件"},{"categories":["开发配置"],"content":"4 跳板机","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:4:0","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#跳板机"},{"categories":["开发配置"],"content":"4.1 ssh 通过跳板机直连原本访问不到的机器~/.ssh/config 中配置如下： Host gateway HostName 192.168.168.52 User gateway Host chej HostName 192.168.211.100 Port 22 User root ProxyJump gateway 通过命令直接登录，无需先到跳板机 gateway 。 ssh chej ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:4:1","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-通过跳板机直连原本访问不到的机器"},{"categories":["开发配置"],"content":"5 ssh 图形化连接","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:0","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#ssh-图形化连接"},{"categories":["开发配置"],"content":"5.1 X11 是什么Linux 本身是没有图形化界面的，所谓的图形化界面系统只不过中 Linux 下的应用程序。这一点和 Windows 不一样。Windows 从 Windows 95 开始，图形界面就直接在系统内核中实现了，是操作系统不可或缺的一部分。Linux 的图形化界面，底层都是基于 X 协议。 X11 是 X 协议的某个版本,，应用程序通过 X 协议告诉服务器端需要显示什么图形，然后服务器端通过 X server 来显示。 但是在远程连接时，服务器是本地的机器，客户端是远程服务器上的程序。因为我们是想要在本地显示远程服务器上的应用结果。 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:1","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#x11-是什么"},{"categories":["开发配置"],"content":"5.2 Mac 下的 X11通过安装 XQuartz，Mac 就可以做一个 X11 server，这样在 Mac 上就能显示远程服务器的应用程序。当 XQuartz 在运行时，会显示图标。 通过 xclock 命令测试，如果一切顺利，应该在 Mac 上会弹出界面。 xclock ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:2","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#mac-下的-x11"},{"categories":["开发配置"],"content":"5.3 VSCode 下的 Remote X11能够做到远程执行命令显示图形界面并调试，还是很诱人的。 这个插件就可以在 vscode 终端中使用 X11 forwarding 了。 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:3","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#vscode-下的-remote-x11"},{"categories":["开发配置"],"content":"5.4 Windows 下的 X11Windows 下有一个终端 MobaXterm，自带 X server。 ","date":"2022-03-24","objectID":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/:5:4","series":[],"tags":["开发配置","ssh"],"title":"ssh 使用和配置","uri":"/blog/002_ssh%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/#windows-下的-x11"},{"categories":["Ubuntu"],"content":"1 创建新用户账户 sudo useradd -s /bin/bash -m -G sudo test -s /bin/bash: 将 /bin/bash 设置为新账户的登录 shell -m: 创建用户的主目录 -G sudo: 确保用户可以使用 sudo ","date":"2022-03-24","objectID":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/:1:0","series":[],"tags":["Ubuntu"],"title":"Ubuntu 创建新用户账户","uri":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/#创建新用户账户"},{"categories":["Ubuntu"],"content":"2 设置新用户账户密码 sudo passwd test ","date":"2022-03-24","objectID":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/:2:0","series":[],"tags":["Ubuntu"],"title":"Ubuntu 创建新用户账户","uri":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/#设置新用户账户密码"},{"categories":["Ubuntu"],"content":"3 删除用户账户 userdel -r test -r: 删除用户主目录 ","date":"2022-03-24","objectID":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/:3:0","series":[],"tags":["Ubuntu"],"title":"Ubuntu 创建新用户账户","uri":"/blog/002_ubuntu%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/#删除用户账户"},{"categories":["编程语言"],"content":"1 Docker 容器使用","date":"2022-03-09","objectID":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:1:0","series":[],"tags":["编程语言","Docker"],"title":"Docker 基本使用","uri":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#docker-容器使用"},{"categories":["编程语言"],"content":"2 Docker 镜像使用 镜像列表 获取镜像列表命令如下所示： docker images ","date":"2022-03-09","objectID":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:2:0","series":[],"tags":["编程语言","Docker"],"title":"Docker 基本使用","uri":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#docker-镜像使用"},{"categories":["编程语言"],"content":"3 Docker 容器连接","date":"2022-03-09","objectID":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:3:0","series":[],"tags":["编程语言","Docker"],"title":"Docker 基本使用","uri":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#docker-容器连接"},{"categories":["编程语言"],"content":"4 Docker 仓库管理 登录和退出 从某些私有仓库拉取 Docker 镜像，可能需要进行登录。 登录命令如下： docker login url 登陆成功后，密码会被加密保存在 ~/.docker/config.json 文件中。 退出命令如下： docker logout 拉取镜像 docker pull image_name:tag 如果没有指定 tag，默认为 latest。 推送镜像 docker push username/image_name:tag ","date":"2022-03-09","objectID":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:4:0","series":[],"tags":["编程语言","Docker"],"title":"Docker 基本使用","uri":"/blog/001_docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#docker-仓库管理"},{"categories":["Ubuntu"],"content":"\u003c200d\u003e ","date":"2022-03-09","objectID":"/blog/001_zero_width_joiners/:0:0","series":[],"tags":["Ubuntu"],"title":"zero-width-joiners","uri":"/blog/001_zero_width_joiners/#"},{"categories":["开发配置"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2021-03-24","objectID":"/blog/004_emoji/:0:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#"},{"categories":["开发配置"],"content":"1 表情与情感","date":"2021-03-24","objectID":"/blog/004_emoji/:1:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#表情与情感"},{"categories":["开发配置"],"content":"1.1 笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:1","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#笑脸表情"},{"categories":["开发配置"],"content":"1.2 爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:2","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#爱意表情"},{"categories":["开发配置"],"content":"1.3 吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:3","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#吐舌头表情"},{"categories":["开发配置"],"content":"1.4 带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:4","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#带手的表情"},{"categories":["开发配置"],"content":"1.5 中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:5","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#中性表情"},{"categories":["开发配置"],"content":"1.6 困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:6","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#困倦的表情"},{"categories":["开发配置"],"content":"1.7 不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:7","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#不适的表情"},{"categories":["开发配置"],"content":"1.8 戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:8","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#戴帽子的表情"},{"categories":["开发配置"],"content":"1.9 戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:9","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#戴眼镜的表情"},{"categories":["开发配置"],"content":"1.10 担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:10","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#担心的表情"},{"categories":["开发配置"],"content":"1.11 否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:11","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#否定的表情"},{"categories":["开发配置"],"content":"1.12 特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:12","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#特殊打扮的表情"},{"categories":["开发配置"],"content":"1.13 猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:13","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#猫脸表情"},{"categories":["开发配置"],"content":"1.14 猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:14","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#猴脸表情"},{"categories":["开发配置"],"content":"1.15 情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2021-03-24","objectID":"/blog/004_emoji/:1:15","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#情感"},{"categories":["开发配置"],"content":"2 人与身体","date":"2021-03-24","objectID":"/blog/004_emoji/:2:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人与身体"},{"categories":["开发配置"],"content":"2.1 张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:1","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#张开手掌的手势"},{"categories":["开发配置"],"content":"2.2 部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:2","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#部分手指的手势"},{"categories":["开发配置"],"content":"2.3 一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:3","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#一根手指的手势"},{"categories":["开发配置"],"content":"2.4 握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:4","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#握紧的手势"},{"categories":["开发配置"],"content":"2.5 两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:5","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#两只手"},{"categories":["开发配置"],"content":"2.6 握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:6","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#握住东西的手势"},{"categories":["开发配置"],"content":"2.7 身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:7","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#身体部位"},{"categories":["开发配置"],"content":"2.8 人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:8","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人"},{"categories":["开发配置"],"content":"2.9 身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:9","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#身体动作"},{"categories":["开发配置"],"content":"2.10 人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:10","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人物角色"},{"categories":["开发配置"],"content":"2.11 幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:11","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#幻想的人物"},{"categories":["开发配置"],"content":"2.12 人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:12","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人物活动"},{"categories":["开发配置"],"content":"2.13 体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:13","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#体育"},{"categories":["开发配置"],"content":"2.14 休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:14","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#休息"},{"categories":["开发配置"],"content":"2.15 家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:15","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#家庭"},{"categories":["开发配置"],"content":"2.16 人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2021-03-24","objectID":"/blog/004_emoji/:2:16","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#人物符号"},{"categories":["开发配置"],"content":"3 动物与自然","date":"2021-03-24","objectID":"/blog/004_emoji/:3:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#动物与自然"},{"categories":["开发配置"],"content":"3.1 哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:1","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#哺乳动物"},{"categories":["开发配置"],"content":"3.2 鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:2","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#鸟类"},{"categories":["开发配置"],"content":"3.3 两栖动物 icon code icon code 🐸 frog ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:3","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#两栖动物"},{"categories":["开发配置"],"content":"3.4 爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:4","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#爬虫类"},{"categories":["开发配置"],"content":"3.5 海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:5","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#海洋动物"},{"categories":["开发配置"],"content":"3.6 虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:6","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#虫类"},{"categories":["开发配置"],"content":"3.7 花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:7","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#花类植物"},{"categories":["开发配置"],"content":"3.8 其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2021-03-24","objectID":"/blog/004_emoji/:3:8","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#其它植物"},{"categories":["开发配置"],"content":"4 食物与饮料","date":"2021-03-24","objectID":"/blog/004_emoji/:4:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#食物与饮料"},{"categories":["开发配置"],"content":"4.1 水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:1","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#水果"},{"categories":["开发配置"],"content":"4.2 蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:2","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#蔬菜"},{"categories":["开发配置"],"content":"4.3 快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:3","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#快餐"},{"categories":["开发配置"],"content":"4.4 亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:4","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#亚洲食物"},{"categories":["开发配置"],"content":"4.5 海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:5","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#海鲜"},{"categories":["开发配置"],"content":"4.6 甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:6","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#甜点"},{"categories":["开发配置"],"content":"4.7 饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:7","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#饮料"},{"categories":["开发配置"],"content":"4.8 餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2021-03-24","objectID":"/blog/004_emoji/:4:8","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#餐具"},{"categories":["开发配置"],"content":"5 旅游与地理","date":"2021-03-24","objectID":"/blog/004_emoji/:5:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#旅游与地理"},{"categories":["开发配置"],"content":"5.1 地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:1","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#地图"},{"categories":["开发配置"],"content":"5.2 地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:2","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#地理现象"},{"categories":["开发配置"],"content":"5.3 建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:3","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#建筑物"},{"categories":["开发配置"],"content":"5.4 宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:4","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#宗教建筑"},{"categories":["开发配置"],"content":"5.5 其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:5","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#其它地点"},{"categories":["开发配置"],"content":"5.6 陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:6","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#陆路运输"},{"categories":["开发配置"],"content":"5.7 水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:7","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#水路运输"},{"categories":["开发配置"],"content":"5.8 空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:8","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#空中运输"},{"categories":["开发配置"],"content":"5.9 旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:9","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#旅馆"},{"categories":["开发配置"],"content":"5.10 时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:10","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#时间"},{"categories":["开发配置"],"content":"5.11 天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2021-03-24","objectID":"/blog/004_emoji/:5:11","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#天空与天气"},{"categories":["开发配置"],"content":"6 活动","date":"2021-03-24","objectID":"/blog/004_emoji/:6:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#活动"},{"categories":["开发配置"],"content":"6.1 事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:1","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#事件"},{"categories":["开发配置"],"content":"6.2 奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:2","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#奖杯与奖牌"},{"categories":["开发配置"],"content":"6.3 体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:3","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#体育运动"},{"categories":["开发配置"],"content":"6.4 游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:4","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#游戏"},{"categories":["开发配置"],"content":"6.5 艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2021-03-24","objectID":"/blog/004_emoji/:6:5","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#艺术与工艺"},{"categories":["开发配置"],"content":"7 物品","date":"2021-03-24","objectID":"/blog/004_emoji/:7:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#物品"},{"categories":["开发配置"],"content":"7.1 服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:1","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#服装"},{"categories":["开发配置"],"content":"7.2 声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:2","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#声音"},{"categories":["开发配置"],"content":"7.3 音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:3","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#音乐"},{"categories":["开发配置"],"content":"7.4 乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:4","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#乐器"},{"categories":["开发配置"],"content":"7.5 电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:5","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#电话"},{"categories":["开发配置"],"content":"7.6 电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:6","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#电脑"},{"categories":["开发配置"],"content":"7.7 灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:7","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#灯光与影像"},{"categories":["开发配置"],"content":"7.8 书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:8","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#书与纸张"},{"categories":["开发配置"],"content":"7.9 钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:9","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#钱"},{"categories":["开发配置"],"content":"7.10 邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:10","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#邮件"},{"categories":["开发配置"],"content":"7.11 书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:11","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#书写"},{"categories":["开发配置"],"content":"7.12 办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:12","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#办公"},{"categories":["开发配置"],"content":"7.13 锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:13","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#锁"},{"categories":["开发配置"],"content":"7.14 工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:14","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#工具"},{"categories":["开发配置"],"content":"7.15 科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:15","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#科学"},{"categories":["开发配置"],"content":"7.16 医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:16","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#医疗"},{"categories":["开发配置"],"content":"7.17 生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:17","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#生活用品"},{"categories":["开发配置"],"content":"7.18 其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2021-03-24","objectID":"/blog/004_emoji/:7:18","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#其它物品"},{"categories":["开发配置"],"content":"8 符号","date":"2021-03-24","objectID":"/blog/004_emoji/:8:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#符号"},{"categories":["开发配置"],"content":"8.1 交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:1","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#交通标识"},{"categories":["开发配置"],"content":"8.2 警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:2","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#警告"},{"categories":["开发配置"],"content":"8.3 箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:3","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#箭头"},{"categories":["开发配置"],"content":"8.4 宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:4","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#宗教"},{"categories":["开发配置"],"content":"8.5 生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:5","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#生肖"},{"categories":["开发配置"],"content":"8.6 影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:6","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#影像符号"},{"categories":["开发配置"],"content":"8.7 数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:7","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#数学"},{"categories":["开发配置"],"content":"8.8 标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:8","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#标点符号"},{"categories":["开发配置"],"content":"8.9 货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:9","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#货币"},{"categories":["开发配置"],"content":"8.10 按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:10","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#按键符号"},{"categories":["开发配置"],"content":"8.11 字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:11","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#字母符号"},{"categories":["开发配置"],"content":"8.12 几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:12","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#几何符号"},{"categories":["开发配置"],"content":"8.13 其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2021-03-24","objectID":"/blog/004_emoji/:8:13","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#其它符合"},{"categories":["开发配置"],"content":"9 旗帜","date":"2021-03-24","objectID":"/blog/004_emoji/:9:0","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#旗帜"},{"categories":["开发配置"],"content":"9.1 常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2021-03-24","objectID":"/blog/004_emoji/:9:1","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#常用旗帜"},{"categories":["开发配置"],"content":"9.2 国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2021-03-24","objectID":"/blog/004_emoji/:9:2","series":[],"tags":["开发配置","emoji"],"title":"emoji 🌺","uri":"/blog/004_emoji/#国家和地区旗帜"},{"categories":["961"],"content":"1 一、软件过程","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:0","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#一软件过程"},{"categories":["961"],"content":"1.1 软件过程的概念软件过程是指工作产品构建时所执行的一系列活动、动作和任务的集合． 软件过程是指软件整个生命周期，从需求获取、需求分析、设计、实现、测试、发布和维护一个过程模型． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:1","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件过程的概念"},{"categories":["961"],"content":"1.2 经典软件过程模型的特点1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#经典软件过程模型的特点"},{"categories":["961"],"content":"1.2 经典软件过程模型的特点1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#瀑布模型"},{"categories":["961"],"content":"1.2 经典软件过程模型的特点1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#增量模型"},{"categories":["961"],"content":"1.2 经典软件过程模型的特点1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#演化模型"},{"categories":["961"],"content":"1.2 经典软件过程模型的特点1.2.1 瀑布模型瀑布模型提供了一个统一的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持． 特征 接受上一阶段的结果作为本阶段的输入 利用这一输入实施本阶段应完成的活动 对本阶段的工作进行评审 将本阶段的结果作为输出，传递给下一阶段 缺点 实际的项目很少遵守瀑布模型提出的顺序 缺乏灵活性，难以适应需求???确或需求经常变化的软件开发 开发早期存在的问题往往要到交付使用时才发现，维护代价大 1.2.2 增量模型增量模型将软件的开发过程分成若干个日程时间交错的线性序列，每个线性序列产生软件的一个可发布的“增量”版本，后一版本是对前一版本的修改和补充，重复增量发布的过程，直至产生最终的完善产品． 1.2.3 演化模型软件往往难以一次开发完成，我们可以在获取了一组基本的需求后，通过快速分析，构造出该软件的一个初始版本，称为原型（prototype），然后根据用户在试用原型的过程中提出的反馈意见和建议对原型进行改进，获得原型的新版本，重复这一过程，最终可得到令用户满意的软件产品． 1.2.4 统一过程模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#统一过程模型"},{"categories":["961"],"content":"1.3 过程评估与CMM/CMMI的基本概念CMM（Capability Maturity Model）即能力成熟度模型，用于评价软件机构的软件过程能力成熟度的模型． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#过程评估与cmmcmmi的基本概念"},{"categories":["961"],"content":"1.4 敏捷宣言与敏捷过程的特点敏捷宣言 个体和交互胜过过程和工具 可工作软件胜过宽泛的文档 客户合作胜过合同谈判 响应变化胜过遵循计划 右边的各项很有价值，但左边的价值更大 敏捷过程 敏捷开发的过程有着更强的适应性而不是预设性 敏捷开发的过程中，更加的注重人的因素 在敏捷开发的过程中，整个项目是测试驱动的而不是文档驱动的 ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:4","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#敏捷宣言与敏捷过程的特点"},{"categories":["961"],"content":"2 二、软件需求","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:0","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#二软件需求"},{"categories":["961"],"content":"2.1 软件需求的概念需求分析是研究用户要求，以得到目标系统的需求定义的过程． 需求分析的基本任务是软件开发人员和用户一起完全弄清用户对系统的确切要求． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:1","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件需求的概念"},{"categories":["961"],"content":"2.2 需求工程的基本过程软件需求工程细分为：需求获取、需求分析与协商、系统建模、需求规约、需求验证和需求管理六个阶段． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:2","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#需求工程的基本过程"},{"categories":["961"],"content":"2.3 分层数据流模型","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#分层数据流模型"},{"categories":["961"],"content":"2.4 用例和场景建模及其UML表达2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图2.4.3 泳道图2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#用例和场景建模及其uml表达"},{"categories":["961"],"content":"2.4 用例和场景建模及其UML表达2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图2.4.3 泳道图2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#用例图"},{"categories":["961"],"content":"2.4 用例和场景建模及其UML表达2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图2.4.3 泳道图2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#活动图"},{"categories":["961"],"content":"2.4 用例和场景建模及其UML表达2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图2.4.3 泳道图2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#泳道图"},{"categories":["961"],"content":"2.4 用例和场景建模及其UML表达2.4.1 用例图用例图展示了各类外部执行者与系统所提供的用例之间的连接。 用例图由参与者（Actor）、用例（Use Case）、系统边界、关系组成．其中关系包括关联、扩展、包含、泛化等． 创建用例模型的步骤包括： 定义系统 确定参与者 确定用例 描述用例 定义用例间的关系 确认模型 用例图中的矩形框代表系统，系统的用例画在矩形框内，代表系统之外的参与者画在矩形框外． 2.4.2 活动图2.4.3 泳道图2.4.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:4","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#顺序图"},{"categories":["961"],"content":"2.5 数据模型建模及其UML表达2.5.1 类图类图展示系统中类的静态结构，即类与类之间的相互联系． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:5","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#数据模型建模及其uml表达"},{"categories":["961"],"content":"2.5 数据模型建模及其UML表达2.5.1 类图类图展示系统中类的静态结构，即类与类之间的相互联系． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:5","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#类图"},{"categories":["961"],"content":"2.6 行为模型建模及其UML表达2.6.1 状态图状态图通常是对类描述的补充，它说明该类的对象所有可能的状态以及哪些事件将导致状态的变化． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:6","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#行为模型建模及其uml表达"},{"categories":["961"],"content":"2.6 行为模型建模及其UML表达2.6.1 状态图状态图通常是对类描述的补充，它说明该类的对象所有可能的状态以及哪些事件将导致状态的变化． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:6","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#状态图"},{"categories":["961"],"content":"3 三、软件设计与构造","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:0","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#三软件设计与构造"},{"categories":["961"],"content":"3.1 软件体系结构及体系结构风格的概念程序或计算机系统的软件体系结构是指系统的一个或者多个结构，它包括软件构件、构件的外部可见属性以及它们之间的相互关系． 体系结构风格就是施加在整个系统上的一种变换，目的是为系统的所有构件建立一个结构． 体系结构风格的简单分类 以数据为中心的体系结构 数据流体系结构 调用和返回体系结构 面向对象体系结构 层次体系结构 ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:1","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件体系结构及体系结构风格的概念"},{"categories":["961"],"content":"3.2 设计模式的概念设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结．使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:2","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#设计模式的概念"},{"categories":["961"],"content":"3.3 模块化设计的基本思想及概念3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#模块化设计的基本思想及概念"},{"categories":["961"],"content":"3.3 模块化设计的基本思想及概念3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#抽象"},{"categories":["961"],"content":"3.3 模块化设计的基本思想及概念3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#分解"},{"categories":["961"],"content":"3.3 模块化设计的基本思想及概念3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#模块化"},{"categories":["961"],"content":"3.3 模块化设计的基本思想及概念3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#封装"},{"categories":["961"],"content":"3.3 模块化设计的基本思想及概念3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#信息隐藏"},{"categories":["961"],"content":"3.3 模块化设计的基本思想及概念3.3.1 抽象抽象是一种思考和解决问题的形式，它集中注意事物某个一般性级别上的问题，避开不必要的底层细节．抽象可以分成若干级别，级别越高，细节就越少． 抽象是忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面． 3.3.2 分解分解是将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止． 3.3.3 模块化模块化是把软件按照规定原则，划分为一个个较小的，相互独立的但又相互关联的部件，实际上是系统分解和抽象的过程． 合理的软件结构应该是分块的结构，即软件应该分解成可单独命名的且可访问的部件，这些部件称为模块．这种将软件分成具有一定结构的模块的过程成为模块化． 3.3.4 封装封装是一种信息隐蔽技术，用户只能看见对象封装界面上的信息，对象的内部实现对用户是隐蔽的。封装的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。 3.3.5 信息隐藏信息隐藏是指模块中所包含的信息对不需要这些信息的其他模块是不可访问的．这样，每一个将来可能的改变都会局部于一个特定的模块，改变该模块的内部过程或数据的设计不会影响到其他模块． 3.3.6 功能独立功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果．开发功能专一的且避免与其他模块过多交互的的模块可以实现功能独立． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#功能独立"},{"categories":["961"],"content":"3.4 软件重构的概念软件重构是指在不改变软件的功能和外部可见性的情况下，为了改善软件的结构，提高软件的清晰性、可扩展性和可重用性而对其进行的改造． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:4","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件重构的概念"},{"categories":["961"],"content":"3.5 软件体系结构的UML建模3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件体系结构的uml建模"},{"categories":["961"],"content":"3.5 软件体系结构的UML建模3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#包图"},{"categories":["961"],"content":"3.5 软件体系结构的UML建模3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#类图-1"},{"categories":["961"],"content":"3.5 软件体系结构的UML建模3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#构件图"},{"categories":["961"],"content":"3.5 软件体系结构的UML建模3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#顺序图-1"},{"categories":["961"],"content":"3.5 软件体系结构的UML建模3.5.1 包图包图是由包和包之间的关系组成的结构图，在某一视点给定的精度上对系统的完整描述． 3.5.2 类图类图展示系统中类的静态结构，即类与类之间的相互联系． 3.5.3 构件图构件图展示以代码构建为单位的代码的物理结构． 3.5.4 顺序图顺序图主要用来显示对象之间发送消息的顺序，以及对象之间的交互． 3.5.5 部署图部署图展示系统中硬件和软件的物理结构． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:5","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#部署图"},{"categories":["961"],"content":"3.6 接口的概念接口提供关于通信和协作的重要信息，然而接口表示的随意性会使构件图趋于复杂化． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:6","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#接口的概念"},{"categories":["961"],"content":"3.7 面向对象设计原则3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#面向对象设计原则"},{"categories":["961"],"content":"3.7 面向对象设计原则3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#单一职责原则"},{"categories":["961"],"content":"3.7 面向对象设计原则3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#开闭原则"},{"categories":["961"],"content":"3.7 面向对象设计原则3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#liskov替换原则"},{"categories":["961"],"content":"3.7 面向对象设计原则3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#依赖转置原则"},{"categories":["961"],"content":"3.7 面向对象设计原则3.7.1 单一职责原则类的职责要单一，不能将太多的职责放在一个类中． 3.7.2 开闭原则软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能． 3.7.3 Liskov替换原则在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象． 3.7.4 依赖转置原则要针对抽象层编程，而不要针对具体类编程． 3.7.5 接口隔离原则使用多个专门的接口来取代一个统一的接口． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:7","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#接口隔离原则"},{"categories":["961"],"content":"3.8 内聚与耦合的概念内聚是模块相对功能性的度量，即一个模块内部各个元素彼此结合的紧密程度的度量． 耦合是模块间相对独立性的度量，即模块间相互连接的紧密程度的度量． 模块独立性比较强的模块应是高内聚低耦合的模块． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:8","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#内聚与耦合的概念"},{"categories":["961"],"content":"3.9 常见的内聚和耦合类型内聚类型 偶然内聚 逻辑内聚 时间内聚 过程内聚 通信内聚 顺序内聚 功能内聚 耦合类型 数据耦合 控制耦合 特征耦合 公共环境耦合 内容耦合 ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:9","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#常见的内聚和耦合类型"},{"categories":["961"],"content":"4 四、软件测试","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:0","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#四软件测试"},{"categories":["961"],"content":"4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#软件测试及测试用例的概念"},{"categories":["961"],"content":"4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#单元测试"},{"categories":["961"],"content":"4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#集成测试"},{"categories":["961"],"content":"4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#确认测试"},{"categories":["961"],"content":"4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#系统测试"},{"categories":["961"],"content":"4.1 软件测试及测试用例的概念软件测试是一种能够系统的加以计划和说明的过程，可以进行测试用例设计，定义测试策略，根据预期的结果评估测试结果．其目的是为了发现软件设计和实现过程中因疏忽所造成的错误． 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果，以便测试是否满足某个特定需求． 4.1.1 单元测试单元测试也称模块测试，一般在编码阶段进行，主要测试模块功能和内部逻辑 测试方法：白盒 发现错误：编码、详细设计 4.1.2 集成测试集成测试是根据程序结构图将模块集成为程序进行测试，主要测试模块间的接口和通信 测试方法：黑盒 发现错误：概要设计 4.1.3 确认测试确认测试是根据需求规格说明，检查软件的功能及其它特征是否与用户的需求一致 测试方法：黑盒 发现错误：需求分析 4.1.4 系统测试系统测试是将软件、硬件、数据库等集成为计算机系统，检查系统的功能、性能等是否符合计算机系统的要求 测试方法：黑盒 发现错误：系统工程 4.1.5 回归测试回归测试是对某些已经进行过的测试的子集的重新执行，以保证软件的改变不会传播不可预料的副作用或附加的错误． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#回归测试"},{"categories":["961"],"content":"4.2 调试的概念调试不是测试，但总是发生在测试之后．当测试用例发现错误时，调试是使错误消除的过程． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:2","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#调试的概念"},{"categories":["961"],"content":"4.3 调试与测试的关系测试主要是发现错误，调试则是确定错误的原因和准确位置，并加以纠正． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:3","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#调试与测试的关系"},{"categories":["961"],"content":"4.4 测试覆盖度的概念","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:4","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#测试覆盖度的概念"},{"categories":["961"],"content":"4.5 白盒测试、黑盒测试的概念白盒测试是把测试对象看作一个透明的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，检查程序中的所有逻辑路径是否都按预定的要求正确的工作． 黑盒测试是把测试对象看作一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明． ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:5","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#白盒测试黑盒测试的概念"},{"categories":["961"],"content":"4.6 代码圈复杂度的计算方法圈复杂度是一种软件度量，它为程序的逻辑复杂度提供了一个量化的测度．在基本路径测试方法的环境下，圈复杂度的值定义了程序基本集合中的独立路径数，并提供了保证所有语句至少执行一次所需要测试数量的上限． 圈复杂度以图论为基础，计算方法如下 流图中域的数量与圈复杂度相对应(划分成几个区域) 流图G中，圈复杂度V(G) = E - N + 2，其中E为边数，N为结点数 流图G中，圈复杂度V(G) = P + 1，其中P为判定节点数(IF/CASE语句) ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:6","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#代码圈复杂度的计算方法"},{"categories":["961"],"content":"4.7 白盒测试中的基本路径测试方法","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:7","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#白盒测试中的基本路径测试方法"},{"categories":["961"],"content":"4.8 黑盒测试中的等价类划分方法 ","date":"2020-06-22","objectID":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:8","series":[],"tags":["961","软件工程"],"title":"软件工程","uri":"/blog/003_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#黑盒测试中的等价类划分方法"},{"categories":["961"],"content":"1 一、处理器体系结构","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:0","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#一处理器体系结构"},{"categories":["961"],"content":"1.1 CPU中的时序电路1.1.1 组合电路和时序电路是什么，它们有什么区别 组合电路：将逻辑门组合成一张网，所构成的计算块 时序电路：逻辑门电路和反馈逻辑回路或器件（寄存器）组成 核心区别是：时序电路的输出不仅取决于当时的输入值，而且还与电路过去的状态有关；任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:1","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#cpu中的时序电路"},{"categories":["961"],"content":"1.1 CPU中的时序电路1.1.1 组合电路和时序电路是什么，它们有什么区别 组合电路：将逻辑门组合成一张网，所构成的计算块 时序电路：逻辑门电路和反馈逻辑回路或器件（寄存器）组成 核心区别是：时序电路的输出不仅取决于当时的输入值，而且还与电路过去的状态有关；任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:1","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#组合电路和时序电路是什么它们有什么区别"},{"categories":["961"],"content":"1.2 单周期处理器的设计单周期处理器：在一个时钟周期内完成单条指令：取指、译码、执行、访存、写回、更新PC 1、取指：从内存中读取指令，加载至处理器 2、译码：对取指令操作中得到的指令进行分析并译码，确定这条指令需要完成的操作，从而产生相的操作控制信号 3、执行：进行相应的逻辑或算术运算 4、访存：内存访问（非必要） 5、写回：将指令结果写回至寄存器（非必要） 6、更新PC：更新程序计数器（将程序计数器指向接下来要执行的指令的地址） ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:2","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#单周期处理器的设计"},{"categories":["961"],"content":"1.3 流水线处理器的基本原理1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线处理器的基本原理"},{"categories":["961"],"content":"1.3 流水线处理器的基本原理1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线处理器的概念及基本原理"},{"categories":["961"],"content":"1.3 流水线处理器的基本原理1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线处理器的局限性"},{"categories":["961"],"content":"1.3 流水线处理器的基本原理1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线冒险冒险的种类及对应解决方法"},{"categories":["961"],"content":"1.3 流水线处理器的基本原理1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#影响流水线效率的因素"},{"categories":["961"],"content":"1.3 流水线处理器的基本原理1.3.1 流水线处理器的概念及基本原理可以结合单周期处理器的不足进行回答，因为流水线就是单周期处理器的改进。 ！！！！一定要点出并行！！！！！ 概念：流水线处理器将待执行的指令拆分成若干个阶段，每个阶段后添加寄存器，使每个阶段 可以在允许其独立使用的硬件电路上与其他阶段并行，以此提高系统的吞吐量。 流水线是如何提高程序性能的？（或者说是流水线的特点） 拆分指令，并且在每个阶段对应的硬件电路后添加寄存器 以流水线的形式执行指令，充分利用硬件，减少了硬件的闲置时间（对比单周期处理器） 1.3.2 流水线处理器的局限性 不一致的划分：每个阶段的延迟不一致，导致系统吞吐量取决于最慢的阶段。 流水线过深，收益反而下降：在组合逻辑被分成较小的块时，由寄存器更新引起的延迟成为了一个限制因素，降低了收益。 1.3.3 流水线冒险、冒险的种类及对应解决方法流水线冒险：邻近指令之间出现了某种关联后，下一条指令无法正确执行。 冒险的种类及解决方法： 结构冒险：争用硬件（一个指令需要的硬件部件还在为之前的指令工作，而无法为这条指令提供服务） 插入气泡（流水线气泡） 设置相互独立的指令存储和数据存储 数据冒险：存在数据依赖，数据还未产生 插入气泡（流水线气泡或者空指令：气泡前的指令继续执行，气泡后的指令被阻塞。直到冒险条件不再满足） 数据转发（将结果值直接从一个流水线阶段传到较早阶段，需要在硬件结构中增加一些额外的数据连接和控制逻辑） 加载互锁（就是暂停加上数据转发，因为在转发将值转发到已经过去的时间中，所以要插入暂停周期） 乱序执行（这个CSAPP中没有，但是应用广泛，可以了解。就是分析指令间的依赖，将无依赖关系的指令提前执行，代替暂停周期，避免时钟浪费） 控制冒险：存在分支和跳转时可能发生，不确定下一条执行什么指令 插入气泡 分支预测策略：从不选择策略（60%），反向选择策略（40%），正向选择反向不选择（65%） 条件跳转语句中，可以将每个条件的结果都进行计算，计算的开销小于流水线清空带来的代建 1.3.4 影响流水线效率的因素局限性和流水线冒险，根据上面的解释这两点 1.3.5 流水线插入气泡技术插入气泡技术可以解决所有的流水线冒险，但是每一个气泡都会浪费一个时钟周期，代价非常高。因此尽量少用插入气泡解决流水线冒险，选用其他效率高的方法。参考上面提到的。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线插入气泡技术"},{"categories":["961"],"content":"1.4 Data Hazard的处理","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:4","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#data-hazard的处理"},{"categories":["961"],"content":"1.5 流水线设计中的其他问题1.5.1 流水线若干问题及注意点 流水线并不能减少(而且一般是增加)单条指令的执行时间，但却能提高系统吞吐率。 适当增加流水线的深度(段数)可以提高流水线的性能。（参考流水线的局限性-不一致的划分） 流水线的深度(级数)受限于流水线的延迟和流水线的额外开销 如果流水线中的指令相互独立 ，则可以充分发挥流水线的性能。但在实际中 ，指令间可能会是相互依赖，这会降低流水线的性能。 1.5.2 解决流水线的局限性-不一致的划分，超标量技术（选看）Intel处理器中的超线程技术的本质就是超标量技术。 在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。其实质是以时间换取空间。 处理器的执行阶段往往是处理器中最耗时的阶段，也就是说执行阶段往往是处理器的瓶颈。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:5","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线设计中的其他问题"},{"categories":["961"],"content":"1.5 流水线设计中的其他问题1.5.1 流水线若干问题及注意点 流水线并不能减少(而且一般是增加)单条指令的执行时间，但却能提高系统吞吐率。 适当增加流水线的深度(段数)可以提高流水线的性能。（参考流水线的局限性-不一致的划分） 流水线的深度(级数)受限于流水线的延迟和流水线的额外开销 如果流水线中的指令相互独立 ，则可以充分发挥流水线的性能。但在实际中 ，指令间可能会是相互依赖，这会降低流水线的性能。 1.5.2 解决流水线的局限性-不一致的划分，超标量技术（选看）Intel处理器中的超线程技术的本质就是超标量技术。 在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。其实质是以时间换取空间。 处理器的执行阶段往往是处理器中最耗时的阶段，也就是说执行阶段往往是处理器的瓶颈。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:5","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#流水线若干问题及注意点"},{"categories":["961"],"content":"1.5 流水线设计中的其他问题1.5.1 流水线若干问题及注意点 流水线并不能减少(而且一般是增加)单条指令的执行时间，但却能提高系统吞吐率。 适当增加流水线的深度(段数)可以提高流水线的性能。（参考流水线的局限性-不一致的划分） 流水线的深度(级数)受限于流水线的延迟和流水线的额外开销 如果流水线中的指令相互独立 ，则可以充分发挥流水线的性能。但在实际中 ，指令间可能会是相互依赖，这会降低流水线的性能。 1.5.2 解决流水线的局限性-不一致的划分，超标量技术（选看）Intel处理器中的超线程技术的本质就是超标量技术。 在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。其实质是以时间换取空间。 处理器的执行阶段往往是处理器中最耗时的阶段，也就是说执行阶段往往是处理器的瓶颈。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:5","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#解决流水线的局限性-不一致的划分超标量技术选看"},{"categories":["961"],"content":"2 二、优化程序性能","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:0","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#二优化程序性能"},{"categories":["961"],"content":"2.1 优化程序性能","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:1","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#优化程序性能"},{"categories":["961"],"content":"2.2 优化编译器的能力和局限性以及表示程序性能 1、高级设计：选择合适的算法和数据结构。 2、基本编码原则：避免限制优化的因素，使编译器产生高效的代码 1)、消除连续的函数调用（消除低效率循环、减少过程调用）：在可能时，将计算移到循环外。 2)、消除不必要的内存引用：引入临时变量来保存中间结果，只有在最后的值计算出来时，才将结果存放到数组或全局变量中。 3、低级优化：结构化代码以利用硬件功能。 1)、展开循环，降低开销 2)、提高指令级并行：通过多个累积变量和重新结合技术 3)、用功能性的风格重写条件操作，使得编译采用数据传送。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:2","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#优化编译器的能力和局限性以及表示程序性能"},{"categories":["961"],"content":"2.3 特定体系结构或应用特性的性能优化","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#特定体系结构或应用特性的性能优化"},{"categories":["961"],"content":"2.4 限制因素 1、寄存器溢出：并行度超过了可用寄存器的数量，就会发生溢出。将某些临时值放到内存中，通常是在运行时堆栈上分配空间。 2、分支预测和预测错误的惩罚：分支预测逻辑不能正确预测分支是否要跳转，这时条件分支可能会招致很大的预测错误处罚 不要过分关心可预测分支 书写适合用条件传送实现的代码 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:4","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#限制因素"},{"categories":["961"],"content":"2.5 确认和消除性能瓶颈程序剖析运行版本的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间．再根据Amdahl定律进行优化。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:5","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#确认和消除性能瓶颈"},{"categories":["961"],"content":"2.6 Amdahl定律Amdahl定律的主要思想是当我们加快系统的一个部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少． 公式：S = 1 / ((1 - a) + a / k) 其中a为某部分需要时间的百分比，k为性能提升倍数． 主要观点是要想大幅度提高整个系统的速度，我们必须提高整个系统很大一部分的速度． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:6","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#amdahl定律"},{"categories":["961"],"content":"3 三、存储器结构及虚拟存储器","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:0","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#三存储器结构及虚拟存储器"},{"categories":["961"],"content":"3.1 局部性局部性通常有两种形式：时间局部性(temporal locality)和空间局部性(spatial locality)． 在一个具有良好时间局部性的程序中，被引用过一次的存储器位置很可能在不远的将来再被多次引用． 在一个具有良好空间局部性的程序中，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:1","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#局部性"},{"categories":["961"],"content":"3.2 存储器层级结构3.2.1 存储器的层级结构从高层往低层走，存储设备逐渐从小而快变得更大、更慢、更便宜，每层都会缓存来自较低一层的数据对象。被缓存的数据对象一般是处理器近期可能会需要的信息，这样可以有效提高读/写效率。 寄存器 L1高速缓存 L2高速缓存 L3高速缓存 主存 本地二级存储（本地磁盘） 远程二级存储（分布式文件系统，WEB服务器） 主要思想：上一层的存储器作为低一层的存储器的高速缓存。利用高速缓存的局部性原理：程序具有访问局部区域里的数据和代码的趋势。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:2","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#存储器层级结构"},{"categories":["961"],"content":"3.2 存储器层级结构3.2.1 存储器的层级结构从高层往低层走，存储设备逐渐从小而快变得更大、更慢、更便宜，每层都会缓存来自较低一层的数据对象。被缓存的数据对象一般是处理器近期可能会需要的信息，这样可以有效提高读/写效率。 寄存器 L1高速缓存 L2高速缓存 L3高速缓存 主存 本地二级存储（本地磁盘） 远程二级存储（分布式文件系统，WEB服务器） 主要思想：上一层的存储器作为低一层的存储器的高速缓存。利用高速缓存的局部性原理：程序具有访问局部区域里的数据和代码的趋势。 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:2","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#存储器的层级结构"},{"categories":["961"],"content":"3.3 计算机高速缓存器原理","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#计算机高速缓存器原理"},{"categories":["961"],"content":"3.4 高速缓存对性能的影响","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:4","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#高速缓存对性能的影响"},{"categories":["961"],"content":"3.5 地址空间地址空间是一个非负整数地址的有序集合． 如果地址空间中的整数是连续的，那么就是一个线性地址空间． 在一个带虚拟存储器的系统中，CPU从一个有2^n个地址的地址空间中生产虚拟地址，这个地址空间称为虚拟地址空间． 物理地址空间与系统中的物理存储器相对应． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:5","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#地址空间"},{"categories":["961"],"content":"3.6 虚拟存储器虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的、私有地址空间． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:6","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#虚拟存储器"},{"categories":["961"],"content":"3.7 虚拟内存的管理、翻译和映射","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:7","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#虚拟内存的管理翻译和映射"},{"categories":["961"],"content":"3.8 TLBTLB(Translation Lookaside Buffer)叫做翻译后备缓冲器． TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由PTE组成的块． ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:8","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#tlb"},{"categories":["961"],"content":"3.9 动态存储器分配","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:9","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#动态存储器分配"},{"categories":["961"],"content":"3.10 垃圾收集 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:10","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#垃圾收集"},{"categories":["961"],"content":"4 四、链接、进程及并发编程","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:0","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#四链接进程及并发编程"},{"categories":["961"],"content":"4.1 静态链接","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:1","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#静态链接"},{"categories":["961"],"content":"4.2 目标文件","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:2","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#目标文件"},{"categories":["961"],"content":"4.3 符号和符号表","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#符号和符号表"},{"categories":["961"],"content":"4.4 重定位和加载","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:4","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#重定位和加载"},{"categories":["961"],"content":"4.5 动态链接库","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:5","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#动态链接库"},{"categories":["961"],"content":"4.6 异常","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:6","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#异常"},{"categories":["961"],"content":"4.7 进程","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:7","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#进程"},{"categories":["961"],"content":"4.8 进程控制和信号","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:8","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#进程控制和信号"},{"categories":["961"],"content":"4.9 进程间的通信","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:9","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#进程间的通信"},{"categories":["961"],"content":"4.10 进程间信号量的控制、信号量","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:10","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#进程间信号量的控制信号量"},{"categories":["961"],"content":"4.11 各种并发编程模式","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:11","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#各种并发编程模式"},{"categories":["961"],"content":"4.12 共享变量","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:12","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#共享变量"},{"categories":["961"],"content":"4.13 线程同步","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:13","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#线程同步"},{"categories":["961"],"content":"4.14 其他并行问题 ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:14","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#其他并行问题"},{"categories":["961"],"content":"5 五、系统级I/O和网络编程","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:0","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#五系统级io和网络编程"},{"categories":["961"],"content":"5.1 I/O相关概念","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:1","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#io相关概念"},{"categories":["961"],"content":"5.2 文件及文件操作","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:2","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#文件及文件操作"},{"categories":["961"],"content":"5.3 共享文件","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:3","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#共享文件"},{"categories":["961"],"content":"5.4 网络编程","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:4","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#网络编程"},{"categories":["961"],"content":"5.5 客户端-服务器模型","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:5","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#客户端-服务器模型"},{"categories":["961"],"content":"5.6 套接字接口","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:6","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#套接字接口"},{"categories":["961"],"content":"5.7 HTTP请求","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:7","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#http请求"},{"categories":["961"],"content":"5.8 Web服务器","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:8","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#web服务器"},{"categories":["961"],"content":"6 RISC和CISC（20年考到了但是考纲中没有） ","date":"2020-06-16","objectID":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:6:0","series":[],"tags":["961","计算机系统基础"],"title":"计算机系统基础","uri":"/blog/002_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/#risc和cisc20年考到了但是考纲中没有"},{"categories":["961"],"content":"1 一、栈（Stack）、队列（Queue）和向量（Vector）","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:0","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#一栈stack队列queue和向量vector"},{"categories":["961"],"content":"1.1 链表1.1.1 单链表1.1.2 双向链表1.1.3 环形链表1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#链表"},{"categories":["961"],"content":"1.1 链表1.1.1 单链表1.1.2 双向链表1.1.3 环形链表1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#单链表"},{"categories":["961"],"content":"1.1 链表1.1.1 单链表1.1.2 双向链表1.1.3 环形链表1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#双向链表"},{"categories":["961"],"content":"1.1 链表1.1.1 单链表1.1.2 双向链表1.1.3 环形链表1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#环形链表"},{"categories":["961"],"content":"1.1 链表1.1.1 单链表1.1.2 双向链表1.1.3 环形链表1.1.4 带哨兵节点的链表","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:1","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#带哨兵节点的链表"},{"categories":["961"],"content":"1.2 栈1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\"#include \u003cstdlib.h\u003e // for malloc#include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-\u003eTopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-\u003eTopOfStack == S-\u003eCapacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements \u003c MinStackSize) { Error(\"Stack size is too small\"); } S = (SqStack)malloc(sizeof(struct StackRecord)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eArray = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-\u003eArray == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eCapacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-\u003eArray); free(S); } } void MakeEmpty(SqStack S) { S-\u003eTopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-\u003eArray[++S-\u003eTopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-\u003eTopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-\u003eArray[S-\u003eTopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\"#include \u003cstdlib.h\u003e // for malloc#include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-\u003eNext == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-\u003eNext = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-\u003eElement = X; TmpCell-\u003eNext = S-\u003eNext; S-\u003eNext = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-\u003eNext-\u003eElement; } else { Error(\"Empt","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈"},{"categories":["961"],"content":"1.2 栈1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-TopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-TopOfStack == S-Capacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements Array = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-Array == NULL) { FatalError(\"Out of space!!!\"); } S-Capacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-Array); free(S); } } void MakeEmpty(SqStack S) { S-TopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-Array[++S-TopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-TopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-Next == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-Next = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-Element = X; TmpCell-Next = S-Next; S-Next = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-Next-Element; } else { Error(\"Empt","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的基本概念"},{"categories":["961"],"content":"1.2 栈1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-TopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-TopOfStack == S-Capacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements Array = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-Array == NULL) { FatalError(\"Out of space!!!\"); } S-Capacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-Array); free(S); } } void MakeEmpty(SqStack S) { S-TopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-Array[++S-TopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-TopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-Next == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-Next = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-Element = X; TmpCell-Next = S-Next; S-Next = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-Next-Element; } else { Error(\"Empt","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的性质"},{"categories":["961"],"content":"1.2 栈1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-TopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-TopOfStack == S-Capacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements Array = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-Array == NULL) { FatalError(\"Out of space!!!\"); } S-Capacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-Array); free(S); } } void MakeEmpty(SqStack S) { S-TopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-Array[++S-TopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-TopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-Next == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-Next = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-Element = X; TmpCell-Next = S-Next; S-Next = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-Next-Element; } else { Error(\"Empt","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的adt"},{"categories":["961"],"content":"1.2 栈1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-TopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-TopOfStack == S-Capacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements Array = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-Array == NULL) { FatalError(\"Out of space!!!\"); } S-Capacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-Array); free(S); } } void MakeEmpty(SqStack S) { S-TopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-Array[++S-TopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-TopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-Next == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-Next = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-Element = X; TmpCell-Next = S-Next; S-Next = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-Next-Element; } else { Error(\"Empt","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的实现"},{"categories":["961"],"content":"1.2 栈1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-TopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-TopOfStack == S-Capacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements Array = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-Array == NULL) { FatalError(\"Out of space!!!\"); } S-Capacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-Array); free(S); } } void MakeEmpty(SqStack S) { S-TopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-Array[++S-TopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-TopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-Next == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-Next = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-Element = X; TmpCell-Next = S-Next; S-Next = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-Next-Element; } else { Error(\"Empt","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的数组实现"},{"categories":["961"],"content":"1.2 栈1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-TopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-TopOfStack == S-Capacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements Array = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-Array == NULL) { FatalError(\"Out of space!!!\"); } S-Capacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-Array); free(S); } } void MakeEmpty(SqStack S) { S-TopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-Array[++S-TopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-TopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-Next == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-Next = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-Element = X; TmpCell-Next = S-Next; S-Next = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-Next-Element; } else { Error(\"Empt","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的链表实现"},{"categories":["961"],"content":"1.2 栈1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-TopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-TopOfStack == S-Capacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements Array = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-Array == NULL) { FatalError(\"Out of space!!!\"); } S-Capacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-Array); free(S); } } void MakeEmpty(SqStack S) { S-TopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-Array[++S-TopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-TopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-Next == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-Next = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-Element = X; TmpCell-Next = S-Next; S-Next = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-Next-Element; } else { Error(\"Empt","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈的应用"},{"categories":["961"],"content":"1.2 栈1.2.1 栈的基本概念栈(stack)是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)．栈也叫做LIFO(后进先出)表． 1.2.2 栈的性质1.2.3 栈的ADT int IsEmpty(Stack S); Stack CreateStack(void); void DisposeStack(Stack S); void MakeEmpty(Stack S); void Push(ElementType X, Stack S); ElementType Top(Stack S); void Pop(Stack S); 1.2.4 栈的实现由于栈是一个表，因此任何实现表的方式都能实现栈．一般有两种实现方法，一种使用链式结构，另一种使用数组． 1.2.4.1 栈的数组实现使用数组来实现栈，通过在表顶端???来实现Push，通过删除表顶端元素实现Pop．Top操作只是考察表顶端元素并返回它的值． 数组实现的特点 需要提前声明数组大小 连续的内存空间 在表头插入和删除操作效率低 支持随机访问元素 SqStack.h #ifndef SQSTACK_H_ #define SQSTACK_H_ // Type Definition struct StackRecord; typedef int ElementType; typedef struct StackRecord *SqStack; // Function Lists int IsEmpty(SqStack S); int IsFull(SqStack S); SqStack CreateStack(int MaxElements); void DisposeStack(SqStack S); void MakeEmpty(SqStack S); void Push(ElementType X, SqStack S); ElementType Top(SqStack S); void Pop(SqStack S); ElementType TopAndPop(SqStack S); #endif /* SQSTACK_H_ */ SqStack.c #include \"SqStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a dynamically allocated array */ #define EmptyTOS (-1) #define MinStackSize (5) struct StackRecord { int Capacity; int TopOfStack; ElementType *Array; }; int IsEmpty(SqStack S) { return S-TopOfStack == EmptyTOS; } int IsFull(SqStack S) { return S-TopOfStack == S-Capacity - 1; } SqStack CreateStack(int MaxElements) { SqStack S; if (MaxElements Array = (ElementType *)malloc(sizeof(ElementType) * MaxElements); if (S-Array == NULL) { FatalError(\"Out of space!!!\"); } S-Capacity = MaxElements; MakeEmpty(S); return S; } void DisposeStack(SqStack S) { if (S != NULL) { free(S-Array); free(S); } } void MakeEmpty(SqStack S) { S-TopOfStack = EmptyTOS; } void Push(ElementType X, SqStack S) { if (IsFull(S)) { Error(\"Full stack\"); } else { S-Array[++S-TopOfStack] = X; } } ElementType Top(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } void Pop(SqStack S) { if (IsEmpty(S)) { Error(\"Empty stack\"); } else { --S-TopOfStack; } } ElementType TopAndPop(SqStack S) { if (!IsEmpty(S)) { return S-Array[S-TopOfStack--]; } else { Error(\"Empty stack\"); return 0; /* Return value used to avoid warning */ } } 1.2.4.2 栈的链表实现使用单链表来实现栈，通过在表顶端插入来实现Push，通过删除表顶端元素实现Pop．Top操作只是考查表顶端元素并返回它的值． 链表实现的特点 不需要提前声明分配空间 分散的内存空间 在表头插入和删除操作效率高 不支持随机访问元素 LinkedStack.h #ifndef LINKEDSTACK_H_ #define LINKEDSTACK_H_ // Type Definition struct Node; typedef int ElementType; typedef struct Node *PtrToNode; typedef PtrToNode LinkedStack; // Function Lists int IsEmpty(LinkedStack S); LinkedStack CreateStack(void); void DisposeStack(LinkedStack S); void MakeEmpty(LinkedStack S); void Push(ElementType X, LinkedStack S); ElementType Top(LinkedStack S); void Pop(LinkedStack S); ElementType TopAndPop(LinkedStack S); #endif /* LINKEDSTACK_H_ */ LinkedStack.c #include \"LinkedStack.h\"#include // for malloc#include \"FatalError.h\" /* Stack implementation is a linked list with a header */ struct Node { ElementType Element; PtrToNode Next; }; int IsEmpty(LinkedStack S) { return S-Next == NULL; } LinkedStack CreateStack(void) { LinkedStack S; S = (LinkedStack)malloc(sizeof(struct Node)); if (S == NULL) { FatalError(\"Out of space!!!\"); } S-Next = NULL; MakeEmpty(S); return S; } void DisposeStack(LinkedStack S) { MakeEmpty(S); free(S); } void MakeEmpty(LinkedStack S) { if (S == NULL) { Error(\"Must use CreateStack first\"); } else { while (!IsEmpty(S)) { Pop(S); } } } void Push(ElementType X, LinkedStack S) { PtrToNode TmpCell; TmpCell = (PtrToNode)malloc(sizeof(struct Node)); if (TmpCell == NULL) { FatalError(\"Out of space!!!\"); } else { TmpCell-Element = X; TmpCell-Next = S-Next; S-Next = TmpCell; } } ElementType Top(LinkedStack S) { if (!IsEmpty(S)) { return S-Next-Element; } else { Error(\"Empt","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#栈与递归"},{"categories":["961"],"content":"1.3 队列1.3.1 队列的基本概念1.3.2 队列的性质1.3.3 队列的ADT1.3.4 队列的实现1.3.4.1 队列的顺序实现1.3.4.2 队列的链表实现1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列"},{"categories":["961"],"content":"1.3 队列1.3.1 队列的基本概念1.3.2 队列的性质1.3.3 队列的ADT1.3.4 队列的实现1.3.4.1 队列的顺序实现1.3.4.2 队列的链表实现1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的基本概念"},{"categories":["961"],"content":"1.3 队列1.3.1 队列的基本概念1.3.2 队列的性质1.3.3 队列的ADT1.3.4 队列的实现1.3.4.1 队列的顺序实现1.3.4.2 队列的链表实现1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的性质"},{"categories":["961"],"content":"1.3 队列1.3.1 队列的基本概念1.3.2 队列的性质1.3.3 队列的ADT1.3.4 队列的实现1.3.4.1 队列的顺序实现1.3.4.2 队列的链表实现1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的adt"},{"categories":["961"],"content":"1.3 队列1.3.1 队列的基本概念1.3.2 队列的性质1.3.3 队列的ADT1.3.4 队列的实现1.3.4.1 队列的顺序实现1.3.4.2 队列的链表实现1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的实现"},{"categories":["961"],"content":"1.3 队列1.3.1 队列的基本概念1.3.2 队列的性质1.3.3 队列的ADT1.3.4 队列的实现1.3.4.1 队列的顺序实现1.3.4.2 队列的链表实现1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的顺序实现"},{"categories":["961"],"content":"1.3 队列1.3.1 队列的基本概念1.3.2 队列的性质1.3.3 队列的ADT1.3.4 队列的实现1.3.4.1 队列的顺序实现1.3.4.2 队列的链表实现1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的链表实现"},{"categories":["961"],"content":"1.3 队列1.3.1 队列的基本概念1.3.2 队列的性质1.3.3 队列的ADT1.3.4 队列的实现1.3.4.1 队列的顺序实现1.3.4.2 队列的链表实现1.3.5 队列的应用","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#队列的应用"},{"categories":["961"],"content":"1.4 向量1.4.1 向量的基本概念1.4.2 向量的性质1.4.3 向量的ADT1.4.4 向量的实现1.4.4.1 向量的数组实现1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量"},{"categories":["961"],"content":"1.4 向量1.4.1 向量的基本概念1.4.2 向量的性质1.4.3 向量的ADT1.4.4 向量的实现1.4.4.1 向量的数组实现1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的基本概念"},{"categories":["961"],"content":"1.4 向量1.4.1 向量的基本概念1.4.2 向量的性质1.4.3 向量的ADT1.4.4 向量的实现1.4.4.1 向量的数组实现1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的性质"},{"categories":["961"],"content":"1.4 向量1.4.1 向量的基本概念1.4.2 向量的性质1.4.3 向量的ADT1.4.4 向量的实现1.4.4.1 向量的数组实现1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的adt"},{"categories":["961"],"content":"1.4 向量1.4.1 向量的基本概念1.4.2 向量的性质1.4.3 向量的ADT1.4.4 向量的实现1.4.4.1 向量的数组实现1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的实现"},{"categories":["961"],"content":"1.4 向量1.4.1 向量的基本概念1.4.2 向量的性质1.4.3 向量的ADT1.4.4 向量的实现1.4.4.1 向量的数组实现1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的数组实现"},{"categories":["961"],"content":"1.4 向量1.4.1 向量的基本概念1.4.2 向量的性质1.4.3 向量的ADT1.4.4 向量的实现1.4.4.1 向量的数组实现1.4.4.2 向量的链表实现 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#向量的链表实现"},{"categories":["961"],"content":"2 二、树","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:0","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二树"},{"categories":["961"],"content":"2.1 树的基本概念和术语","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:1","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#树的基本概念和术语"},{"categories":["961"],"content":"2.2 树的遍历2.2.1 前序遍历2.2.2 中序遍历2.2.3 后序遍历2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#树的遍历"},{"categories":["961"],"content":"2.2 树的遍历2.2.1 前序遍历2.2.2 中序遍历2.2.3 后序遍历2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#前序遍历"},{"categories":["961"],"content":"2.2 树的遍历2.2.1 前序遍历2.2.2 中序遍历2.2.3 后序遍历2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#中序遍历"},{"categories":["961"],"content":"2.2 树的遍历2.2.1 前序遍历2.2.2 中序遍历2.2.3 后序遍历2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#后序遍历"},{"categories":["961"],"content":"2.2 树的遍历2.2.1 前序遍历2.2.2 中序遍历2.2.3 后序遍历2.2.4 层序遍历","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#层序遍历"},{"categories":["961"],"content":"2.3 二叉树的定义和性质","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二叉树的定义和性质"},{"categories":["961"],"content":"2.4 普通树与二叉树的转换","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#普通树与二叉树的转换"},{"categories":["961"],"content":"2.5 树的存储结构2.5.1 标准形式2.5.2 完全树的数组形式","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#树的存储结构"},{"categories":["961"],"content":"2.5 树的存储结构2.5.1 标准形式2.5.2 完全树的数组形式","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#标准形式"},{"categories":["961"],"content":"2.5 树的存储结构2.5.1 标准形式2.5.2 完全树的数组形式","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#完全树的数组形式"},{"categories":["961"],"content":"2.6 树的应用2.6.1 Huffman树的定义与应用 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:6","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#树的应用"},{"categories":["961"],"content":"2.6 树的应用2.6.1 Huffman树的定义与应用 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:6","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#huffman树的定义与应用"},{"categories":["961"],"content":"3 三、查找(search)","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:0","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#三查找search"},{"categories":["961"],"content":"3.1 查找的基本概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:1","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#查找的基本概念"},{"categories":["961"],"content":"3.2 对线性关系结构的查找3.2.1 顺序查找3.2.2 二分查找","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#对线性关系结构的查找"},{"categories":["961"],"content":"3.2 对线性关系结构的查找3.2.1 顺序查找3.2.2 二分查找","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#顺序查找"},{"categories":["961"],"content":"3.2 对线性关系结构的查找3.2.1 顺序查找3.2.2 二分查找","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二分查找"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#hash查找法"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#常见的hash函数"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#直接定址法"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#随机数法"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#hash冲突的概念"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#解决hash冲突的办法"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#开散列方法"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#拉链法"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#闭散列方法"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#开址定址法"},{"categories":["961"],"content":"3.3 Hash查找法3.3.1 常见的Hash函数3.3.1.1 直接定址法3.3.1.2 随机数法3.3.2 Hash冲突的概念3.3.3 解决Hash冲突的办法3.3.3.1 开散列方法3.3.3.2 拉链法3.3.3.3 闭散列方法3.3.3.4 开址定址法3.3.4 二次聚集现象","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二次聚集现象"},{"categories":["961"],"content":"3.4 BST查找法3.4.1 BST树的定义3.4.2 BST树的性质3.4.3 BST树的ADT3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst查找法"},{"categories":["961"],"content":"3.4 BST查找法3.4.1 BST树的定义3.4.2 BST树的性质3.4.3 BST树的ADT3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst树的定义"},{"categories":["961"],"content":"3.4 BST查找法3.4.1 BST树的定义3.4.2 BST树的性质3.4.3 BST树的ADT3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst树的性质"},{"categories":["961"],"content":"3.4 BST查找法3.4.1 BST树的定义3.4.2 BST树的性质3.4.3 BST树的ADT3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst树的adt"},{"categories":["961"],"content":"3.4 BST查找法3.4.1 BST树的定义3.4.2 BST树的性质3.4.3 BST树的ADT3.4.4 BST树的实现查找算法 插入算法 删除算法 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#bst树的实现"},{"categories":["961"],"content":"3.5 AVL查找法3.5.1 AVL树的定义3.5.2 AVL树的性质3.5.3 AVL树的ADT3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl查找法"},{"categories":["961"],"content":"3.5 AVL查找法3.5.1 AVL树的定义3.5.2 AVL树的性质3.5.3 AVL树的ADT3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl树的定义"},{"categories":["961"],"content":"3.5 AVL查找法3.5.1 AVL树的定义3.5.2 AVL树的性质3.5.3 AVL树的ADT3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl树的性质"},{"categories":["961"],"content":"3.5 AVL查找法3.5.1 AVL树的定义3.5.2 AVL树的性质3.5.3 AVL树的ADT3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl树的adt"},{"categories":["961"],"content":"3.5 AVL查找法3.5.1 AVL树的定义3.5.2 AVL树的性质3.5.3 AVL树的ADT3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#avl树的实现"},{"categories":["961"],"content":"3.5 AVL查找法3.5.1 AVL树的定义3.5.2 AVL树的性质3.5.3 AVL树的ADT3.5.4 AVL树的实现查找算法 插入算法 3.5.5 平衡因子的概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#平衡因子的概念"},{"categories":["961"],"content":"3.6 优先队列查找法3.6.1 堆的定义3.6.2 堆的生成3.6.3 堆的调整算法3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#优先队列查找法"},{"categories":["961"],"content":"3.6 优先队列查找法3.6.1 堆的定义3.6.2 堆的生成3.6.3 堆的调整算法3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#堆的定义"},{"categories":["961"],"content":"3.6 优先队列查找法3.6.1 堆的定义3.6.2 堆的生成3.6.3 堆的调整算法3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#堆的生成"},{"categories":["961"],"content":"3.6 优先队列查找法3.6.1 堆的定义3.6.2 堆的生成3.6.3 堆的调整算法3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#堆的调整算法"},{"categories":["961"],"content":"3.6 优先队列查找法3.6.1 堆的定义3.6.2 堆的生成3.6.3 堆的调整算法3.6.4 范围查找 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:6","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#范围查找"},{"categories":["961"],"content":"4 四、排序","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:0","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#四排序"},{"categories":["961"],"content":"4.1 排序基本概念","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:1","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#排序基本概念"},{"categories":["961"],"content":"4.2 排序算法4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#排序算法"},{"categories":["961"],"content":"4.2 排序算法4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#插入排序"},{"categories":["961"],"content":"4.2 排序算法4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#希尔排序"},{"categories":["961"],"content":"4.2 排序算法4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#选择排序"},{"categories":["961"],"content":"4.2 排序算法4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#快速排序"},{"categories":["961"],"content":"4.2 排序算法4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#合并排序"},{"categories":["961"],"content":"4.2 排序算法4.2.1 插入排序基本思想 算法代码 基本的时间复杂度分析 4.2.2 希尔排序基本思想 算法代码 基本的时间复杂度分析 4.2.3 选择排序基本思想 算法代码 基本的时间复杂度分析 4.2.4 快速排序基本思想 算法代码 基本的时间复杂度分析 4.2.5 合并排序基本思想 算法代码 基本的时间复杂度分析 4.2.6 基数排序基本思想 算法代码 基本的时间复杂度分析 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#基数排序"},{"categories":["961"],"content":"5 五、图","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:0","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#五图"},{"categories":["961"],"content":"5.1 图的基本概念一个图是由有限非空顶点集和边集组成． 每一条边都是一副点对．如果边有方向，那么就是有向边，表示为\u003cv, w\u003e．如果边没有方向，那么就是无向边，表示为(v, w)． 如果点对是有序的，那么图就是有向的．如果点对是无序的，那么图就是无向的． 无向图中，顶点v的度是指和顶点v相关联的边的数目． 有向图中，以顶点v为弧头的弧的数目称为顶点v的入度，以顶点v为弧尾的弧的数目称为顶点v的出度． 路径是有顶点序列组成，路径的长为该路径上的边数． 序列中顶点不重复出现的路径称为简单路径． 若一条路径中第一个顶点和最后一个顶点相同，则这条路径是一条回路． 如果图含有一条从一个顶点到它自身的边(v, w)，那么路径ｖｗ有时也称作为环(loop)．我们一般讨论的都是无环图！ 如果在一个无向图中从每一个顶点到每个其他顶点都存在一条路径，则称该无向图是连通的．具有这样性质的有向图称为是强连通的． 无向图中的极大连通子图为其连通分量．有向图中的极大强连通子图称为有向图的强连通分量． 每条边都可以附带一个数，这种与边相关的数称为权，权可以表示从一个顶点到另一个顶点的距离或者花费的代价。边上带权的图称为带权图． 完全图是其每一对顶点间都存在一条边的图． ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:1","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#图的基本概念"},{"categories":["961"],"content":"5.2 图的存储结构5.2.1 邻接矩阵表示图的一种简单的方法是使用一个二维数组，称为邻接矩阵表示法． 5.2.2 邻接表表示图的另一种方法是使用数组与链表相结合的存储方式，成为邻接表表示法． ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#图的存储结构"},{"categories":["961"],"content":"5.2 图的存储结构5.2.1 邻接矩阵表示图的一种简单的方法是使用一个二维数组，称为邻接矩阵表示法． 5.2.2 邻接表表示图的另一种方法是使用数组与链表相结合的存储方式，成为邻接表表示法． ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#邻接矩阵"},{"categories":["961"],"content":"5.2 图的存储结构5.2.1 邻接矩阵表示图的一种简单的方法是使用一个二维数组，称为邻接矩阵表示法． 5.2.2 邻接表表示图的另一种方法是使用数组与链表相结合的存储方式，成为邻接表表示法． ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:2","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#邻接表"},{"categories":["961"],"content":"5.3 图的遍历从图中某一顶点出发访问图中其余顶点，且每个顶点只访问一次，这一过程成为图的遍历． 图的遍历分为广度优先遍历和深度优先遍历． 5.3.1 广度优先遍历广度优先搜索算法（BFS）类似于树的层次遍历 基本思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 5.3.2 深度优先遍历图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。 基本思路：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#图的遍历"},{"categories":["961"],"content":"5.3 图的遍历从图中某一顶点出发访问图中其余顶点，且每个顶点只访问一次，这一过程成为图的遍历． 图的遍历分为广度优先遍历和深度优先遍历． 5.3.1 广度优先遍历广度优先搜索算法（BFS）类似于树的层次遍历 基本思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 5.3.2 深度优先遍历图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。 基本思路：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#广度优先遍历"},{"categories":["961"],"content":"5.3 图的遍历从图中某一顶点出发访问图中其余顶点，且每个顶点只访问一次，这一过程成为图的遍历． 图的遍历分为广度优先遍历和深度优先遍历． 5.3.1 广度优先遍历广度优先搜索算法（BFS）类似于树的层次遍历 基本思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 5.3.2 深度优先遍历图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。 基本思路：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:3","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#深度优先遍历"},{"categories":["961"],"content":"5.4 最小生成树基本概念一个无向图的最小生成树就是由该图的那些连接无向图的所有顶点的边构成的树，且其总价值最低． 5.4.1 Prim算法5.4.2 Kruskal算法","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#最小生成树基本概念"},{"categories":["961"],"content":"5.4 最小生成树基本概念一个无向图的最小生成树就是由该图的那些连接无向图的所有顶点的边构成的树，且其总价值最低． 5.4.1 Prim算法5.4.2 Kruskal算法","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#prim算法"},{"categories":["961"],"content":"5.4 最小生成树基本概念一个无向图的最小生成树就是由该图的那些连接无向图的所有顶点的边构成的树，且其总价值最低． 5.4.1 Prim算法5.4.2 Kruskal算法","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:4","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#kruskal算法"},{"categories":["961"],"content":"5.5 最短路径问题5.5.1 广度优先遍历算法5.5.2 Dijkstra算法5.5.3 Floyd算法 public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { dist[i][j] = mMatrix[i][j]; // \"顶点i\"到\"顶点j\"的路径长度为\"i到j的权值\"。 path[i][j] = j; // \"顶点i\"到\"顶点j\"的最短路径是经过顶点j。 } } // 计算最短路径 for (int k = 0; k \u003c mVexs.length; k++) { for (int i = 0; i \u003c mVexs.length; i++) { for (int j = 0; j \u003c mVexs.length; j++) { // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j] int tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]); if (dist[i][j] \u003e tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } } ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#最短路径问题"},{"categories":["961"],"content":"5.5 最短路径问题5.5.1 广度优先遍历算法5.5.2 Dijkstra算法5.5.3 Floyd算法 public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } } ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#广度优先遍历算法"},{"categories":["961"],"content":"5.5 最短路径问题5.5.1 广度优先遍历算法5.5.2 Dijkstra算法5.5.3 Floyd算法 public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } } ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#dijkstra算法"},{"categories":["961"],"content":"5.5 最短路径问题5.5.1 广度优先遍历算法5.5.2 Dijkstra算法5.5.3 Floyd算法 public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } } ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:5","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#floyd算法"},{"categories":["961"],"content":"5.6 拓扑排序","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:6","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#拓扑排序"},{"categories":["961"],"content":"5.7 历年真题总结5.7.1 二叉树叶子节点统计个数递归解法： 如果二叉树为空，返回0 如果二叉树是叶子节点，返回1 如果二叉树不是叶子节点，二叉树的叶子节点数 = 左子树叶子节点数 + 右子树叶子节点数 public static int getNodeNumLeafRec(TreeNode root) { if (root == null) { return 0; } if (root.left == null \u0026\u0026 root.right == null) { return 1; } return getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right); } 非递归解法：基于层次遍历进行求解，利用Queue进行。 public static int getNodeNumLeaf(TreeNode root){ if (root == null) { return 0; } int leaf = 0; // 叶子节点个数 Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); queue.add(root); while (!queue.isEmpty()) { TreeNode temp = queue.poll(); if (temp.left == null \u0026\u0026 temp.right == null) { // 叶子节点 leaf++; } if (temp.left != null) { queue.add(temp.left); } if (temp.right != null) { queue.add(temp.right); } } return leaf; 5.7.2 TopK问题: 选择最大的K个数用PriorityQueue默认是自然顺序排序，要选择最大的k个数，构造小顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素大，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 找出前k个最大数，采用小顶堆实现 public static int[] findKMax(int[] nums, int k) { PriorityQueue\u003cInteger\u003e pq = new PriorityQueue\u003c\u003e(k); // 队列默认自然顺序排列，小顶堆，不必重写compare for (int num : nums) { if (pq.size() \u003c k) { pq.offer(num); } else if (pq.peek() \u003c num) { // 如果堆顶元素 \u003c 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i \u003c k \u0026\u0026 !pq.isEmpty(); i++) { result[i] = pq.poll(); } return result; } public static void main(String[] args) { int[] arr = new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9}; System.out.println(Arrays.toString(findKMax(arr,5))); } } // 输出：[5, 6, 7, 8, 9] 要选择最小的K个数使用大顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素小，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 要找前k个最小数，则构建大顶堆，要重写compare方法 public static int[] findKMin(int[] nums, int k) { PriorityQueue\u003cInteger\u003e pq = new PriorityQueue\u003c\u003e(k, new Comparator\u003cInteger\u003e() { @Override public int compare(Integer o1, Integer o2) { return o2-o1; } }); for (int num : nums) { if (pq.size() \u003c k) { pq.offer(num); } else if (pq.peek() \u003e num) {//如果堆顶元素 \u003e 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i \u003c k\u0026\u0026!pq.isEmpty(); i++) { result[i] = pq.poll(); } return result; } public static void main(String[] args) { int[] arr = new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9}; System.out.println(Arrays.toString(findKMin( arr,5))); } } // 输出：[5, 4, 3, 2, 1] ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:7","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#历年真题总结"},{"categories":["961"],"content":"5.7 历年真题总结5.7.1 二叉树叶子节点统计个数递归解法： 如果二叉树为空，返回0 如果二叉树是叶子节点，返回1 如果二叉树不是叶子节点，二叉树的叶子节点数 = 左子树叶子节点数 + 右子树叶子节点数 public static int getNodeNumLeafRec(TreeNode root) { if (root == null) { return 0; } if (root.left == null \u0026\u0026 root.right == null) { return 1; } return getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right); } 非递归解法：基于层次遍历进行求解，利用Queue进行。 public static int getNodeNumLeaf(TreeNode root){ if (root == null) { return 0; } int leaf = 0; // 叶子节点个数 Queue queue = new LinkedList(); queue.add(root); while (!queue.isEmpty()) { TreeNode temp = queue.poll(); if (temp.left == null \u0026\u0026 temp.right == null) { // 叶子节点 leaf++; } if (temp.left != null) { queue.add(temp.left); } if (temp.right != null) { queue.add(temp.right); } } return leaf; 5.7.2 TopK问题: 选择最大的K个数用PriorityQueue默认是自然顺序排序，要选择最大的k个数，构造小顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素大，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 找出前k个最大数，采用小顶堆实现 public static int[] findKMax(int[] nums, int k) { PriorityQueue pq = new PriorityQueue(k); // 队列默认自然顺序排列，小顶堆，不必重写compare for (int num : nums) { if (pq.size() pq = new PriorityQueue(k, new Comparator() { @Override public int compare(Integer o1, Integer o2) { return o2-o1; } }); for (int num : nums) { if (pq.size() num) {//如果堆顶元素 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:7","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#二叉树叶子节点统计个数"},{"categories":["961"],"content":"5.7 历年真题总结5.7.1 二叉树叶子节点统计个数递归解法： 如果二叉树为空，返回0 如果二叉树是叶子节点，返回1 如果二叉树不是叶子节点，二叉树的叶子节点数 = 左子树叶子节点数 + 右子树叶子节点数 public static int getNodeNumLeafRec(TreeNode root) { if (root == null) { return 0; } if (root.left == null \u0026\u0026 root.right == null) { return 1; } return getNodeNumLeafRec(root.left) + getNodeNumLeafRec(root.right); } 非递归解法：基于层次遍历进行求解，利用Queue进行。 public static int getNodeNumLeaf(TreeNode root){ if (root == null) { return 0; } int leaf = 0; // 叶子节点个数 Queue queue = new LinkedList(); queue.add(root); while (!queue.isEmpty()) { TreeNode temp = queue.poll(); if (temp.left == null \u0026\u0026 temp.right == null) { // 叶子节点 leaf++; } if (temp.left != null) { queue.add(temp.left); } if (temp.right != null) { queue.add(temp.right); } } return leaf; 5.7.2 TopK问题: 选择最大的K个数用PriorityQueue默认是自然顺序排序，要选择最大的k个数，构造小顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素大，则删除堆顶元素，并添加这个新数到堆中。 Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下： public class findTopK { // 找出前k个最大数，采用小顶堆实现 public static int[] findKMax(int[] nums, int k) { PriorityQueue pq = new PriorityQueue(k); // 队列默认自然顺序排列，小顶堆，不必重写compare for (int num : nums) { if (pq.size() pq = new PriorityQueue(k, new Comparator() { @Override public int compare(Integer o1, Integer o2) { return o2-o1; } }); for (int num : nums) { if (pq.size() num) {//如果堆顶元素 新数，则删除堆顶，加入新数入堆 pq.poll(); pq.offer(num); } } int[] result = new int[k]; for (int i = 0; i ","date":"2020-06-12","objectID":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:7","series":[],"tags":["961","数据结构与算法分析"],"title":"数据结构与算法分析","uri":"/blog/001_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#topk问题-选择最大的k个数"},{"categories":["编程语言"],"content":"1 Java 概述","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#java-概述"},{"categories":["编程语言"],"content":"1.1 Java 语言概述Java 是 SUN (Stanford University Network, 斯坦福大学网络公司) 于 1995 年推出的一门高级语言。Java 是一种面向 Internet 的编程语言，也是一种完全面向对象，安全可靠，与平台无关的编程语言。 Java5.0 之后的三大技术框架 J2EE (Java 2 Platform Enterprise Edition) 企业版 在 Jdk5.0 版本后称为 JAVAEE，是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如 Servlet Jsp 等，主要针对于 Web 应用程序开发。 J2SE (Java 2 Platform Standard Edition) 标准版 在 Jdk5.0 版本后称为 JAVASE，这是在 Java 基础阶段主要学习的内容，也是 Java 的基础，以后不管从事 Android 开发或者是物联网 + 云计算的开发等，是建立在 JSE 基础上的，因此该技术是 Java 的最核心技术。 J2ME (Java 2 Platform Micro Edition) 小型版 在 Jdk5.0 版本以后称为 JAVAME，该技术多应用于一些电子产品的嵌入式开发，以前在手机开发上应用的也比较多，但是随着智能手机的发展，现在手机应用程序 (比如 Android 程序) 的开发已经不再使用该技术。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:1","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#java-语言概述"},{"categories":["编程语言"],"content":"1.2 JRE 和 JDK 的区别JRE (Java Runtime Environment)，Java 运行环境。包括 Java 虚拟机 (JVM Java Virtual Machine) 和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。 JDK (Java Development Kit Java)，开发工具包。JDK 是提供给 Java 开发人员使用的，其中 包含了 Java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:2","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#jre-和-jdk-的区别"},{"categories":["编程语言"],"content":"1.3 JVMJVM (Java Virtual Machine)，是运行所有 Java 程序的抽象计算机，是 Java 语言的运行环境，是 Java 最具吸引力的特性之一。JVM 读取并处理编译过的与平台无关的字节码 (class) 文件。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:3","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#jvm"},{"categories":["编程语言"],"content":"2 基础知识","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#基础知识"},{"categories":["编程语言"],"content":"2.1 代码注释 单行注释 // 单行注释 多行注释 /* 多 行 注 释 */ 文档注释 /** * 文档注释 */ ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:1","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#代码注释"},{"categories":["编程语言"],"content":"2.2 标识符标识符命名规则： 由字母、数字、下划线、$ 组成，不能以数字开头 区分大小写 不能使用关键字和保留字 不能使用 Java API 的类名 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:2","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#标识符"},{"categories":["编程语言"],"content":"2.3 变量和常量变量：占据着内存中的某一个存储区域，该区域有名称 (变量名) 和类型 (数据类型)，数据在同一类型范围内不断变化。 定义变量的格式： 数据类型 变量名 = 初始化值 作用范围：定义开始到定义它的代码块结束 警告 注意同一作用域内，不允许定义多个同名局部变量！ ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:3","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#变量和常量"},{"categories":["编程语言"],"content":"2.4 成员变量和局部变量 局部变量 定义在方法内的变量 没有默认初始值，使用前必须初始化 作用域是从定义开始到定义它的代码块结束 成员变量 定义在方法内的变量 作用域是在整个类中 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:4","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#成员变量和局部变量"},{"categories":["编程语言"],"content":"2.5 基本数据类型Java 语言有 8 种基本数据类型，按用途分为以下 4 种类别： 类别 数据类型 整数型 byte、short、int、long 小数型 float、double 字符型 char 布尔型 boolean ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:5","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#基本数据类型"},{"categories":["编程语言"],"content":"2.6 基本数据类型转换2.6.1 向上转型容量小的类型可自动转换为容量大的数据类型！ 2.6.2 向下转型容量大的类型不会转换为容量小的数据类型！ 技巧 小转大，自动！自动类型转换 (也叫隐式类型转换) 大转小，强转！强制类型转换 (也叫显式类型转换) ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:6","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#基本数据类型转换"},{"categories":["编程语言"],"content":"2.6 基本数据类型转换2.6.1 向上转型容量小的类型可自动转换为容量大的数据类型！ 2.6.2 向下转型容量大的类型不会转换为容量小的数据类型！ 技巧 小转大，自动！自动类型转换 (也叫隐式类型转换) 大转小，强转！强制类型转换 (也叫显式类型转换) ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:6","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#向上转型"},{"categories":["编程语言"],"content":"2.6 基本数据类型转换2.6.1 向上转型容量小的类型可自动转换为容量大的数据类型！ 2.6.2 向下转型容量大的类型不会转换为容量小的数据类型！ 技巧 小转大，自动！自动类型转换 (也叫隐式类型转换) 大转小，强转！强制类型转换 (也叫显式类型转换) ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:6","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#向下转型"},{"categories":["编程语言"],"content":"2.7 运算符 类别 运算符 算术运算符 +、-、*、/、% 复制运算符 =、+=、-=、*=、/=、%= 关系运算符 \u003e、\u003e=、\u003c、\u003c=、!= 条件运算符 \u0026\u0026、||、!、\u0026、|、^ 位运算符 \u0026、|、^、~、\u003e\u003e、\u003c\u003c、\u003e\u003e\u003e、\u003c\u003c\u003c 注意 “\u0026”和“\u0026\u0026”的区别：单与时，左边无论真假，右边都进行运算。双与时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 “|”和“||”的区别：同理，双或时，左边为真，右边不参与运算。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:7","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#运算符"},{"categories":["编程语言"],"content":"2.8 表达式和三目运算符表达式是由数字、运算符和括号等组合能够计算数值的序列，按从高到低优先级依次计算。 三目运算符的格式： x ? y : z; 其中 x 为 boolean 类型表达式，若 x 为 true，则三目运算符的结果为 y 的值，否则为 z 的值。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:8","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#表达式和三目运算符"},{"categories":["编程语言"],"content":"2.9 程序流程控制 顺序结构 程序从上至下依次执行，直到程序的最后。 分支结构 if-else 语句 switch-case 语句 注意 switch 语句只能使用 byte、char、short、int 四种基本类型以及它们的包装类和枚举! 循环结构 while: 不知道循环次数 do-while: 不知道循环次数但是至少执行一次 for: 知道循环次数 for (1; 2; 3) { 4; } 执行顺序：1 -\u003e 2 -\u003e 4 -\u003e 3 -\u003e 2 -\u003e 4 -\u003e 3 无限循环格式 while (true) { // do something } // or for (;;) { // do something } 控制循环结构 break: 终止本层循环 continue: 跳过本次循环 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:9","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#程序流程控制"},{"categories":["编程语言"],"content":"3 方法与数组","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#方法与数组"},{"categories":["编程语言"],"content":"3.1 方法的定义方法是一组为了实现特定功能的代码块的集合。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:1","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#方法的定义"},{"categories":["编程语言"],"content":"3.2 方法的格式 [修饰符] 返回值类型 方法名([参数类型 形式参数1, 参数类型 形式参数2, ...]) { 执行语句; [return 返回值;] } ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:2","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#方法的格式"},{"categories":["编程语言"],"content":"3.3 方法里的属性访问控制符是限定方法的可见范围。按可见范围从大到小依次是：public、protected、无、private，其中默认为无访问控制符。 属性 含义 形式参数 方法调用时接收输入的数据 实际参数 方法调用时实际传入的数据 返回值 方法执行完后返回的数据 返回值类型 返回值的数据类型 方法签名 方法名和方法的参数列表 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:3","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#方法里的属性"},{"categories":["编程语言"],"content":"3.4 重载在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型或者参数顺序不同即可。 函数重载与返回值类型无关，只与参数列表有关。 // eg. public void func(int a); public int func(); public void func(int a, String s); ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:4","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#重载"},{"categories":["编程语言"],"content":"3.5 可变参数从 java5 开始出现了可变参数，这是对 java 方法及数组的拓展! 可变参数定义格式： 返回值类型 方法名(参数类型 ... 形式参数) { // do something } 注意 可变参数只能出现在参数列表的最后！ 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:5","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#可变参数"},{"categories":["编程语言"],"content":"3.6 数组简介数组 (Array) 是 Java 语言中内置的一种基本数据存储结构，通俗的理解，就是一组数的集合。 数组的元素编号从 0 开始，依次递增，方便访问。 必须先声明数组，再给数组分配内存。 数组对应内存中的一段连续空间。 数组元素是同一类数据类型。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:6","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#数组简介"},{"categories":["编程语言"],"content":"3.7 一维数组 声明 type varName[]; // or type[] varName[]; // 推荐 初始化 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。 数组名 = new 数组类型[]{元素1，元素2，...}; // or 数组名 = {元素1，元素2，...}; // 简化 动态初始化：初始化时指定数组长度，由系统为数组元素分配初始值。 数组名 = new 数组类型[数组长度]; 注意 静态初始化和动态初始化不能同时使用！ 数组的使用 public class Demo { public static void main(String[] args) { int[] age = {1, 2, 3, 4, 5}; for (int i = 0; i \u003c age.length - 1; ++i) { System.out.println(\"age[\" + i + \"] = \" + age[i]); } } } ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:7","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#一维数组"},{"categories":["编程语言"],"content":"3.8 二维数组二维数组其实是一个大的一维数组，它的每一个元素都是一个一维数组，可以看作是一张表格。 int[][] arr = {{1, 2}, {3, 4}}; // 静态初始化 int[][] arr = new int[2][2]; // 动态初始化 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:8","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#二维数组"},{"categories":["编程语言"],"content":"3.9 Arrays 类注意 使用数组工具类可以节省时间，提高效率，注意常查阅 api！ static int binarySearch(type[] a, type key); // 二分搜索法 static int binarySearch(type[] a, int fromIndex, int toIndex, type key); // 二分搜索法 static boolean[] copyOf(type[] original, int newLength); // 复制指定的数组 static byte[] copyOfRange(type[] original, int from, int to); // 将数组的指定范围复制到一个新数组 static boolean equals(type[] a, type[] a2); // 判断数组元素相等 static void fill(type[] a, type val); // 数组所有元素都赋为 val static void fill(type[] a, int fromIndex, int toIndex, type val); // 数组元素都赋为 val static void sort(type[] a); // 按升序排序 static void sort(type[] a, int fromIndex, int toIndex); // 按升序排序 static String toString(type[] a); // 返回字符串表示形式 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:9","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#arrays-类"},{"categories":["编程语言"],"content":"3.10 for-each for (type varName : arrName) { // do something } ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:10","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#for-each"},{"categories":["编程语言"],"content":"4 面向对象","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#面向对象"},{"categories":["编程语言"],"content":"4.1 什么叫面向对象面向对象 (Object-Oriented，简称 OO) 就是一种常见的程序结构设计方法。面向对象思想的基础是将相关的数据和方法放在一起，形成一种新的复合数据类型。 面向对象的三个特征： 封装 继承 多态 面向过程强调的是具体的功能实现，面向对象强调的是具备功能的对象。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:1","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#什么叫面向对象"},{"categories":["编程语言"],"content":"4.2 类类 (class) 是Java 语言的最小编程单位，也是设计和实现Java 程序的基础。 类是一组事物共有特征和功能的描述。类是抽象的，对象是具体的。 类的定义格式： [修饰符] class 类名 { 构造方法; 字段; 方法; } ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:2","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#类"},{"categories":["编程语言"],"content":"4.3 构造方法 构造方法是用来构造类的实例，每一个类都有默认的无参构造方法。 字段是类或对象所包含的数据，对类状态的一种描述。 方法是类或对象的特征或行为。 作用：给类中的字段初始化，可以用来创建对象。 注意 构造方法与类名相同，没有返回值。多个构造方法以重载的形式存在。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:3","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#构造方法"},{"categories":["编程语言"],"content":"4.4 staticstatic 的特点： 随着类的加载而加载 优先于对象存在 被所有对象所共享 可以直接被类名调用 注意 静态方法只能访问静态成员，但是非静态方法可以访问静态成员。 静态方法中不可以使用 this、super 关键字 利用类名调用静态 main 方法会陷入死循环，导致内存溢出，jvm 自动停止！ static 修饰的字段和方法表示属于类共用，而不属于单个实例。既可以通过类调用，也可以通过实例调用。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:4","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#static"},{"categories":["编程语言"],"content":"4.5 匿名对象匿名对象是指一个没有名字的对象，只能调用一次。 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:5","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#匿名对象"},{"categories":["编程语言"],"content":"4.6 thisthis 表示当前对象。 在类的构造器中相互调用，this 只能写在构造方法的第一行！ TODO ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:6","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#this"},{"categories":["编程语言"],"content":"5 异常处理 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:5:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#异常处理"},{"categories":["编程语言"],"content":"6 常用类 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:6:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#常用类"},{"categories":["编程语言"],"content":"7 线程技术 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:7:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#线程技术"},{"categories":["编程语言"],"content":"8 集合框架 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#集合框架"},{"categories":["编程语言"],"content":"9 IO 操作 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:9:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#io-操作"},{"categories":["编程语言"],"content":"10 网络编程 ","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:10:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#网络编程"},{"categories":["编程语言"],"content":"11 反射机制","date":"2020-03-01","objectID":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:11:0","series":[],"tags":["编程语言","Java"],"title":"Java 基础语法","uri":"/blog/001_java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#反射机制"},{"categories":["编程语言"],"content":"1 简单介绍 Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML 文档。 – 维基百科 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:0","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#简单介绍"},{"categories":["编程语言"],"content":"2 基本语法","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:0","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#基本语法"},{"categories":["编程语言"],"content":"2.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:1","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#标题"},{"categories":["编程语言"],"content":"2.2 段落使用空行进行段落分割 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:2","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#段落"},{"categories":["编程语言"],"content":"2.3 字体设置 *斜体* _斜体_ **粗体** __粗体__ ***粗斜体*** ___粗斜体___ ~~删除线~~ ==高亮== \u003cu\u003e下划线\u003c/u\u003e ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:3","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#字体设置"},{"categories":["编程语言"],"content":"2.4 上标下标 上^标^ 下~标~ ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:4","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#上标下标"},{"categories":["编程语言"],"content":"2.5 注释 \u003c!--注释--\u003e ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:5","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#注释"},{"categories":["编程语言"],"content":"2.6 脚注 [^1] [^1]: Markdown ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:6","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#脚注"},{"categories":["编程语言"],"content":"2.7 链接 地址链接 [描述](路径) \u003c链接路径\u003e 图片链接 ![描述](路径) ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:7","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#链接"},{"categories":["编程语言"],"content":"2.8 分割线 **** ---- ____ ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:8","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#分割线"},{"categories":["编程语言"],"content":"2.9 代码块 ```language code ``` ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:9","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#代码块"},{"categories":["编程语言"],"content":"2.10 行内代码 `code` ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:10","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#行内代码"},{"categories":["编程语言"],"content":"2.11 引用 \u003e 引用的文字 \u003e\u003e 嵌套的引用 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:11","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#引用"},{"categories":["编程语言"],"content":"2.12 列表 无序列表 - list1 + list2 * list3 有序列表 1. list1 2. list2 3. list3 混合列表 - 1. list1 + 2. list2 * 3. list3 嵌套列表 1. list1 - list11 - list12 任务列表 - [ ] 未完成 - [x] 已完成 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:12","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#列表"},{"categories":["编程语言"],"content":"2.13 表格 | head | head | | ---- | ---- | | cell | cell | | cell | cell | :- 设置内容和标题栏居左对齐 :-: 设置内容和标题栏居中对齐 -: 设置内容和标题栏居右对齐 ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:13","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#表格"},{"categories":["编程语言"],"content":"3 博客因为 Markdown 使用十分简单，因此决定用 Markdown 整理笔记。将 Markdown 基本语法整理出来，仅作参考！ ","date":"2018-01-01","objectID":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:0","series":[],"tags":["编程语言","Markdown"],"title":"Markdown 语法详解","uri":"/blog/001_markdown%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/#博客"}]